<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/png" href="/src/assets/icon.png"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="茶理的博客" href="https://example.com/rss.xml"><meta name="generator" content="Astro v5.16.6"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://example.com/blog/subject/operate_system/chapter6/"><!-- Primary Meta Tags --><title>操作系统复习 第六章</title><meta name="title" content="操作系统复习 第六章"><meta name="description" content><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://example.com/blog/subject/operate_system/chapter6/"><meta property="og:title" content="操作系统复习 第六章"><meta property="og:description" content><meta property="og:image" content="https://example.com/_astro/default.DOL7xRHI.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://example.com/blog/subject/operate_system/chapter6/"><meta property="twitter:title" content="操作系统复习 第六章"><meta property="twitter:description" content><meta property="twitter:image" content="https://example.com/_astro/default.DOL7xRHI.png"><link rel="stylesheet" href="/_astro/about.CafuXOta.css">
<link rel="stylesheet" href="/_astro/about.B-Pvx2p8.css"></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>茶理的博客</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 首页 </a>  <a href="/tags" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 标签 </a>  <a href="/about" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 关于我 </a>  </div> <div class="social-links" data-astro-cid-3ef6ksr2> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg> </a> </div> </nav> </header>  <main class="blog-container" data-astro-cid-bvzihdzo> <article class="blog-article" data-astro-cid-bvzihdzo> <div class="hero-image" data-astro-cid-bvzihdzo>  </div> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 data-astro-cid-bvzihdzo>操作系统复习 第六章</h1> <hr data-astro-cid-bvzihdzo> </div>  <h1 id="第六章-输入输出设备">第六章 输入输出设备</h1>
<h2 id="io系统">I/O系统</h2>
<ul>
<li>
<p>I/O系统管理的主要对象是I/O设备和相应的设备控制器。</p>
</li>
<li>
<p>其最主要的任务是</p>
<ul>
<li>
<p>完成用户提出的I/O请求</p>
</li>
<li>
<p>提高I/O速率</p>
</li>
<li>
<p>提高设备的利用率</p>
</li>
<li>
<p>为更高层的进程方便地使用这些设备提供手段</p>
</li>
</ul>
</li>
<li>
<p>基本功能</p>
<ul>
<li>
<p>隐藏物理设备的细节</p>
</li>
<li>
<p>与设备的无关性</p>
</li>
<li>
<p>提高处理机和I/O设备的利用率</p>
</li>
<li>
<p>对I/O设备进行控制</p>
<ul>
<li>
<p>采用轮询的可编程1/O方式</p>
</li>
<li>
<p>采用中断的可编程I/O方式</p>
</li>
<li>
<p>直接存储器访问方式</p>
</li>
<li>
<p>I/O通道方式</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>确保对设备的正确共享</p>
<ul>
<li>
<p>独占设备，进程应互斥地访问这类设备，即系统一旦把这类设备分配给 了某进程后，便由该进程独占，直至用完释放。典型的独占设备有打印机、磁带机等。</p>
</li>
<li>
<p>共享设备，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正确性。</p>
</li>
</ul>
</li>
<li>
<p>错误处理</p>
</li>
</ul>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1920" height="1200" src="/_astro/default.DOL7xRHI_ZmS8NF.webp" ></p>
<h3 id="io软件">I/O软件</h3>
<ul>
<li>
<p>中断处理程序</p>
<ul>
<li>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</li>
</ul>
</li>
<li>
<p>设备驱动程序</p>
<ul>
<li>
<p>驱动程序一般会以一个独立进程的方式存在。</p>
</li>
<li>
<p>主要负责对硬件设备的具体控制，将上层发出的一系列命令(如read/write) 转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等</p>
</li>
<li>
<p>不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。</p>
</li>
</ul>
</li>
<li>
<p>设备独立性软件</p>
<ul>
<li>
<p>与设备的硬件特性无关的功能几乎都在这层实现。</p>
</li>
<li>
<p>他的主要功能有:</p>
<ul>
<li>
<p>向上层提供统一的调用接口，如read/write系统调用</p>
</li>
<li>
<p>设备的分配与回收</p>
</li>
<li>
<p>差错处理</p>
</li>
<li>
<p>数据缓冲区管理</p>
</li>
<li>
<p>建立逻辑设备名到物理设备名的映射关系:根据设备类型选择调用相应的驱动程序</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用户层软件</p>
<ul>
<li>实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。</li>
</ul>
</li>
</ul>
<h3 id="系统接口">系统接口</h3>
<ul>
<li>
<p>块设备接口</p>
<ul>
<li>
<p>块设备:用于存储信息。对于信息的存取总是以数据块为单位。典型例子是磁盘。该类设备基本特征是传输速率较高，另一特征是可寻址。工作方式常采用DMA方式。</p>
</li>
<li>
<p>隐藏了磁盘的二维结构。</p>
</li>
<li>
<p>将抽象命令映射为低层操作。</p>
</li>
</ul>
</li>
<li>
<p>流设备接口</p>
<ul>
<li>
<p>字符设备:用于数据的输入和输出。基本单位是字符。如交互式终端、打印机等。</p>
</li>
<li>
<p>其基本特征是传输速率较低，另一特征是不可寻址。</p>
</li>
<li>
<p>工作方式常采用中断方式。</p>
</li>
<li>
<p>get和put操作。</p>
</li>
<li>
<p>in-control指令。</p>
</li>
</ul>
</li>
<li>
<p>网络通信接口</p>
<ul>
<li>通过某种方式把计算机连接到网络上。同时操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络.上的其它计算机进行通信或上网浏览。</li>
</ul>
</li>
</ul>
<h2 id="io设备">I/O设备</h2>
<ul>
<li>
<p>部分</p>
<ul>
<li>
<p>I/O设备的机械部件主要用来执行具体I /O操作。如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</p>
</li>
<li>
<p>I/ O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</p>
</li>
</ul>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>按使用特性分类</p>
<ul>
<li>
<p>存储设备，也称外存或后备存储器、辅助存储器。</p>
</li>
<li>
<p>输入/输出设备</p>
<ul>
<li>
<p>输入设备,如键盘、鼠标、扫描仪、视频摄像、各类传感器等。</p>
</li>
<li>
<p>输出设备,如打印机、绘图仪、显示器、音箱等。</p>
</li>
<li>
<p>交互式设备，集成上述两类设备,利用输入设备接收用户命令信息，并通过输出设备同步显示用户命令以及命令执行的结果。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按传输速率分类</p>
<ul>
<li>
<p>低速设备，每秒钟几个字节至数百个字节</p>
<ul>
<li>键盘、鼠标器、语音的输入和输出设备</li>
</ul>
</li>
<li>
<p>中速设备，每秒钟数千个字节至数万个字节。</p>
<ul>
<li>行式打印机、激光打印机</li>
</ul>
</li>
<li>
<p>高速设备，数十万个字节至数千字节。</p>
<ul>
<li>磁盘机、光盘机</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备控制器">设备控制器</h3>
<ul>
<li>
<p>I/O设备与CPU之间通过设备控制器通信</p>
</li>
<li>
<p>三种信号线</p>
<ul>
<li>
<p>数据信号线</p>
</li>
<li>
<p>控制信号线</p>
</li>
<li>
<p>状态信号线</p>
</li>
</ul>
</li>
<li>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1920" height="1200" src="/_astro/default.DOL7xRHI_ZmS8NF.webp" ></p>
</li>
<li>
<p>设备控制器的基本功能</p>
<ul>
<li>
<p>接收和识别命令</p>
</li>
<li>
<p>数据交换</p>
</li>
<li>
<p>标识和报告设备的状态</p>
</li>
<li>
<p>地址识别</p>
</li>
<li>
<p>数据缓冲区</p>
</li>
<li>
<p>差错控制</p>
</li>
</ul>
</li>
<li>
<p>组成部分</p>
<ul>
<li>
<p>设备控制器与处理机的接口</p>
</li>
<li>
<p>设备控制器与设备的接口</p>
</li>
<li>
<p>I/O逻辑</p>
</li>
</ul>
</li>
</ul>
<h3 id="内存映像io">内存映像I/O</h3>
<h2 id="设备驱动程序">设备驱动程序</h2>
<ul>
<li>
<p>设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序</p>
</li>
<li>
<p>其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令,再;把它转换为具体要求后，发送给设备控制器，启动设备去执行;</p>
</li>
<li>
<p>反之，它也将由设备控制器发来的信号传送给上层软件。</p>
</li>
<li>
<p>由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。</p>
</li>
<li>
<p>设备驱动程序的功能</p>
<ul>
<li>
<p>接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。</p>
</li>
<li>
<p>检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。</p>
</li>
<li>
<p>发出I/O命令，如果设备空闲，便立即启动I/O设备,完成指定的I/O操作;如果设备忙碌，则将请求者的请求块挂在设备队列上等待。</p>
</li>
<li>
<p>及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。</p>
</li>
</ul>
</li>
<li>
<p>处理过程</p>
<ul>
<li>
<p>将抽象要求转换为具体要求</p>
</li>
<li>
<p>检查I/O请求的合法性</p>
</li>
<li>
<p>读出和检查设备的状态</p>
</li>
<li>
<p>传送必要的参数</p>
</li>
<li>
<p>启动I/O设备</p>
</li>
</ul>
</li>
<li>
<p>控制方式</p>
<ul>
<li>
<p>宗旨：尽量减少主机对I/O控制的干预，把主机从繁杂的IO控制事务中解脱出来</p>
</li>
<li>
<p>忙——等待方式</p>
<ul>
<li>
<p>CPU向控制器发出I/O指令,启动输入设备。</p>
</li>
<li>
<p>状态寄存器忙/闲标志busy置1。</p>
</li>
<li>
<p>循环测试busy, busy= 1输入未完成。</p>
</li>
<li>
<p>busy=0输入完成，将数据从控制器的数据寄存器读到内存</p>
</li>
<li>
<p>由于CPU高速,I/O设备低速致使CPU极大浪费。</p>
</li>
</ul>
</li>
<li>
<p>使用中断的可编程I/O方式</p>
<ul>
<li>
<p>CPU向控制器发出I/O指令，CPU返回继续原来的工作。</p>
</li>
<li>
<p>设备控制器控制I/O设备。CPU与I/O并行工作。</p>
</li>
<li>
<p>数据输入寄存器，控制器向CPU发出中断。</p>
</li>
<li>
<p>CPU检查数据正确性，数据写入内存。</p>
</li>
<li>
<p>优点</p>
<ul>
<li>CPU与I/O并行工作， 提高了资源利用率和吞吐量。</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>CPU每次处理的数据量少(通常不超过几个字节)，只适于传输率较低的设备</li>
</ul>
</li>
</ul>
</li>
<li>
<p>直接存储器访问(Direct Memory Access)</p>
<ul>
<li>
<p>特点</p>
<ul>
<li>
<p>数据传输的基本单位是数据块。</p>
</li>
<li>
<p>数据从设备直接送入内存，或者相反。</p>
</li>
<li>
<p>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p>
</li>
</ul>
</li>
<li>
<p>DMA控制器</p>
<ul>
<li>
<p>三部分</p>
<ul>
<li>
<p>主机与DMA控制器的接口</p>
</li>
<li>
<p>DMA控制器与块设备的接口</p>
</li>
<li>
<p>I/O控制逻辑</p>
</li>
</ul>
</li>
<li>
<p>四类寄存器</p>
<ul>
<li>
<p>数据寄存器DR</p>
</li>
<li>
<p>命令/状态寄存器CR</p>
</li>
<li>
<p>内存地址寄存器MAR</p>
</li>
<li>
<p>数据计数器DC</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DMA工作过程</p>
<ul>
<li>
<p>CPU发出指令，存入CR</p>
</li>
<li>
<p>内存起始目标地址送入MAR。</p>
</li>
<li>
<p>读取字节数送DC。</p>
</li>
<li>
<p>源地址送DMA的I/O控制逻辑。</p>
</li>
<li>
<p>启动DMA控制器，CPU处理其他任务。</p>
</li>
<li>
<p>DMA控制读入一个字(节)到DR。</p>
</li>
<li>
<p>将该字(节)送入MAR指向的内存单元。</p>
</li>
<li>
<p>MAR加1，DC减1。</p>
</li>
<li>
<p>DC&#x3C;> 0继续传输，DC=0发出中断。</p>
</li>
</ul>
</li>
<li>
<p>中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理。</p>
</li>
<li>
<p>DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数。</p>
</li>
<li>
<p>中断方式的数据传送是由CPU控制完成的，而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。</p>
</li>
</ul>
</li>
<li>
<p>I/O通道控制方式</p>
<ul>
<li>目的：CPU的I/O任务由通道来承担。</li>
<li>一种特殊的处理机，属于硬件技术。它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。</li>
<li>指令类型单一、 即由于通道硬件比较简单，其所能执行的指令，主要为与I/O有关的指令</li>
<li>通道没有自己的内存，与CPU共享内存</li>
<li>CPU一次读(或写)多个数据块。</li>
<li>多个数据块送入不同内存区域。</li>
<li>CPU、通道和I/O设备三者的并行操作。</li>
<li>工作过程:
<ul>
<li>CPU向通道发送一条I/O指令。</li>
<li>给出通道程序首址和要访问的I/O设备。</li>
<li>通过执行通道程序完成I/O任务。</li>
</ul>
</li>
<li>通道程序由一系列通道指令(通道命令)构成。</li>
<li>每条通道指令包含的信息:
<ul>
<li>操作码</li>
<li>内存地址</li>
<li>计数</li>
<li>通道程序结束位P (P= 1表示程序结束)</li>
<li>记录结束标志R (R=0表示与下一条指令处理的数据属于同一记录;R= 1表示某记录的最后一条指令)</li>
</ul>
</li>
<li>字节多路通道(Byte Multiplexor Channel)
<ul>
<li>字节多路通道以字节为单位传输信息</li>
<li>含有许多非分配型子通道</li>
<li>子通道按时间片轮转方式共享通道</li>
<li>只要扫描每个子通道的速度足够快，而连接到子同上的设备的速率较小的时，不丢数据</li>
<li>主要连接以字节为单位的低速I/O设备,如:打印机、终端</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="与设备无关的io软件">与设备无关的I/O软件</h2>
<p>设备独立性又叫设备无关性，应用程序中所使用的设备,不局限于使用某个具体的物理设备
应用程序中使用逻辑设备名称来请求使用某类设备;系统将其转换为物理设备名称。</p>
<ul>
<li>
<p>好处</p>
<ul>
<li>
<p>设备分配时的灵活性</p>
</li>
<li>
<p>易于实现I/O重定向</p>
</li>
</ul>
</li>
<li>
<p>设备独立性的实现</p>
<ul>
<li>系统有专门从逻辑设备到物理设备的转换机制，类似于存储器管理中所介绍的逻辑地址和物理地址的概念</li>
</ul>
</li>
<li>
<p>功能</p>
<ul>
<li>
<p>执行所有设备的公有操作。</p>
<ul>
<li>
<p>设备驱动程序的统一接口， 对设备进行保护，禁止用户直接访问设备</p>
<ul>
<li>
<p>缓冲管理</p>
</li>
<li>
<p>差错控制</p>
</li>
<li>
<p>对独立设备的分配与回收</p>
</li>
<li>
<p>独立于设备的逻辑数据块</p>
</li>
<li>
<p>将逻辑设备名映射为物理设备名，找到相应物理设备的驱动程序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备分配">设备分配</h3>
<p>一个通道可控制多个设备控制器每个设备控制器可控制多个设备。</p>
<ul>
<li>
<p>设备分配中的数据结构</p>
<ul>
<li>
<p>设备控制表DCT</p>
<ul>
<li>每个物理设备有一张，反映设备特性、设备和I/O控制器的连接情况，在设备和系统连接时创建，动态修改</li>
</ul>
</li>
<li>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1920" height="1200" src="/_astro/default.DOL7xRHI_ZmS8NF.webp" ></p>
</li>
</ul>
</li>
<li>
<p>设备分配时考虑的因素</p>
<ul>
<li>
<p>设备的固有属性</p>
<ul>
<li>
<p>独享设备</p>
</li>
<li>
<p>共享设备</p>
</li>
<li>
<p>虚拟设备</p>
</li>
</ul>
</li>
<li>
<p>设备分配算法</p>
<ul>
<li>
<p>先来先服务</p>
</li>
<li>
<p>优先级高者优先</p>
</li>
</ul>
</li>
<li>
<p>设备分配中的安全性</p>
<ul>
<li>
<p>安全分配方式</p>
</li>
<li>
<p>不安全分配方式</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>独占设备的分配程序</p>
<ul>
<li>
<p>分配设备</p>
</li>
<li>
<p>分配控制器</p>
</li>
<li>
<p>分配通道</p>
</li>
<li>
<p>增加设备的独立性</p>
<ul>
<li>使用逻辑设备名</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑设备表(LUT)</p>
<ul>
<li>
<p>逻辑设备表(LUT)建立了逻辑设备名与物理设备名之间的映射关系。</p>
</li>
<li>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求 操作系统根据用户进程指定的设备类型(逻辑设备名)查找系统设备表,找到一个空闲设备分配给进程,并在LUT中增加相应表项。</p>
</li>
<li>
<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备,则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了,并且也能知道该设备的驱动程序入口地址</p>
</li>
</ul>
</li>
</ul>
<h2 id="用户层io软件">用户层I/O软件</h2>
<ul>
<li>
<p>系统调用</p>
<ul>
<li>系统调用，应用程序可以通过它间接调用OS中的I/0过程，对I/O设备进行操作。</li>
</ul>
</li>
<li>
<p>库函数</p>
</li>
</ul>
<h3 id="假脱机系统spooling">假脱机系统(spooling)</h3>
<ul>
<li>
<p>假脱机技术</p>
<ul>
<li>
<p>在多道程序技术下，专门利用一道程序来模拟脱机输入操作,把低速I/O设备上的数据传送到高速磁盘上</p>
</li>
<li>
<p>再用另一道程序来模拟脱机输出操作，把数据从磁盘传送到输出设备上。</p>
</li>
<li>
<p>此时I/O设备与CPU并行工作。</p>
</li>
</ul>
</li>
<li>
<p>组成</p>
<ul>
<li>
<p>输入井和输出井。是磁盘上开辟的两个大存储空间。</p>
</li>
<li>
<p>输入缓冲区和输出缓冲区。在内存中开辟两个缓冲区，输入缓冲区暂存由输入设送来的数据，后送输入井</p>
</li>
<li>
<p>输出缓冲区暂存从输出井送来的数据，后送输出设备。</p>
</li>
<li>
<p>输入进程和输出进程。利用两个进程模拟脱机I/O时的外围处理机。</p>
</li>
</ul>
</li>
<li>
<p>假脱机打印机</p>
<ul>
<li>
<p>打印机是经常用到的输出设备，属于独占设备。、</p>
</li>
<li>
<p>利用假脱机技术可将它改造为一台可供多个用户共享的打印设备</p>
</li>
<li>
<p>假脱机打印系统主要有以下3三部分</p>
<ul>
<li>
<p>磁盘缓冲区。</p>
</li>
<li>
<p>打印缓冲区。</p>
</li>
<li>
<p>假脱机管理进程和假脱机打印进程</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>提高了I/O的速度</p>
</li>
<li>
<p>将独占设备改造为共享设备</p>
</li>
<li>
<p>实现了虚拟设备功能</p>
</li>
</ul>
</li>
</ul>
<h2 id="缓冲区管理">缓冲区管理</h2>
<ul>
<li>
<p>缓冲的引入</p>
<ul>
<li>
<p>缓和CPU与I/O设备间速度不匹配的矛盾。</p>
</li>
<li>
<p>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p>
</li>
<li>
<p>解决数据粒度不匹配的问题</p>
</li>
<li>
<p>提高CPU和1/O设备之间的并行性。</p>
</li>
</ul>
</li>
<li>
<p>单缓冲区(Single Buffer)</p>
<ul>
<li>
<p>进程发出一个I/O请求时，操作系统便在主存中为之分配一缓冲区。</p>
</li>
<li>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1920" height="1200" src="/_astro/default.DOL7xRHI_ZmS8NF.webp" ></p>
</li>
</ul>
</li>
<li>
<p>双缓冲区</p>
<ul>
<li>
<p>在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时OS可
以从第二缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。</p>
</li>
<li>
<p>为了实现两台机器间的双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另外一个用作接收缓冲区。</p>
</li>
</ul>
</li>
<li>
<p>环形缓冲区</p>
<ul>
<li>
<p>CPU和外设的处理速度可能相差较大。</p>
</li>
<li>
<p>在主存中分配一组大小相等的缓冲区， 并用指针将这些缓冲区-个循环链表。</p>
</li>
<li>
<p>多个缓冲区:空缓冲区R;满缓冲区G;工作缓冲区C。</p>
</li>
<li>
<p>多个指针:下一个可用缓冲区G的指针Nextg;下一个输入缓冲区R的指针Nexti;当前计算进程正在使用的缓冲区C的指针Current。</p>
</li>
</ul>
</li>
</ul>
<h2 id="磁盘">磁盘</h2>
<ul>
<li>
<p>结构</p>
<ul>
<li>
<p>磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面(Surface)</p>
</li>
<li>
<p>每个盘面上有若干个磁道(Track),磁道之间留有必要的间隙(Gap)。为使处理简单起见，在每条磁道上可存储相同数目的二进制位。</p>
</li>
<li>
<p>磁盘密度即每英寸所存储的位数</p>
</li>
<li>
<p>每条此道从逻辑上划分位若干扇区</p>
</li>
</ul>
</li>
<li>
<p>磁盘格式化</p>
<ul>
<li>
<p>磁盘低级格式化(温切斯特盘)</p>
<ul>
<li>
<p>将空白的磁盘划分出柱面和磁道，再将磁道划分为若干个扇区，</p>
</li>
<li>
<p>每个扇区又划分出标识部分ID,间隔区GAP和数据区DATA等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>磁盘分区</p>
<ul>
<li>每个分区是一个独立的逻辑磁盘分区情况记录在磁盘的主引导扇区中的分区表(MBR)中</li>
</ul>
</li>
<li>
<p>高级格式化</p>
<ul>
<li>设置引导块，空闲和已分配空间表，构件文件系统，在磁盘上初始化文件系统数据结构，根目录等</li>
</ul>
</li>
<li>
<p>类型</p>
<ul>
<li>硬盘、软盘</li>
<li>单片盘、多片盘</li>
<li>固定磁头盘、移动磁头盘</li>
</ul>
</li>
<li>
<p>磁盘访问时间</p>
<ul>
<li>
<p>寻道时间T<sub>s</sub> :在读/写数据前,将磁头移动到指定磁道所花的时间。</p>
<ul>
<li>
<p>启动磁头臂是需要时间的。假设耗时为s ;</p>
</li>
<li>
<p>移动磁头也是需要时间的。假设磁头匀速移动,每跨越一个磁道耗时为m ,总共需要跨越n条磁道。则:</p>
</li>
<li>
<p>$$
T_s=s+m*n
$$</p>
</li>
</ul>
</li>
<li>
<p>延迟时间Tt :</p>
<ul>
<li>
<p>通过旋转磁盘,使磁头定位到目标扇区所需要的时间。设磁盘转速为r (单位:转/秒,或转/分),则平均所需的延迟时间</p>
</li>
<li>
<p>$$
T_t=\frac{1}{2}*\frac{1}{r}=\frac{1}{2r}
$$</p>
</li>
</ul>
</li>
<li>
<p>传输时间Tt</p>
<ul>
<li>
<p>从磁盘读出或向磁盘写入数据所经历的时间,假设磁盘转速为r，此次读/写的字节数为b,每个磁道上的字节数为N</p>
</li>
<li>
<p>$$
T_t=\frac{b}{rN}
$$</p>
</li>
</ul>
</li>
<li>
<p>总的平均存取时间</p>
<ul>
<li>$$
T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
$$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<ul>
<li>
<p>先来先服务</p>
<ul>
<li>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
</li>
<li>
<p>优点</p>
<ul>
<li>
<p>公平，简单。</p>
</li>
<li>
<p>I/O负载较轻且每次读写多个连续扇区时，性能较好。</p>
</li>
<li>
<p>适用于l/O进程较少的场合。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>最短寻道优先算法</p>
<ul>
<li>
<p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。</p>
</li>
<li>
<p>可以保证每次的寻道时间最短,但是并不能保证总的寻道时间最短。(贪心算法)</p>
</li>
<li>
<p>可能会有进程处于“饥饿”状态。</p>
</li>
</ul>
</li>
<li>
<p>扫描算法</p>
<ul>
<li>
<p>只有磁头移动到最外侧磁道的时候才能往内移动,移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想。由于磁头移动的方式很像电梯,因此也叫电梯算法。</p>
</li>
<li>
<p>性能较好，平均寻道时间较短</p>
</li>
<li>
<p>防止“饥饿”现象。</p>
</li>
<li>
<p>被广泛应用。</p>
</li>
<li>
<p>SCAN算法对于各个位置磁道的响应频率不平均</p>
</li>
</ul>
</li>
<li>
<p>循环扫描算法</p>
<ul>
<li>
<p>磁头单向移动，磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>
</li>
<li>
<p>比起SCAN来,对于各个位置磁道的响应频率很平均。</p>
</li>
<li>
<p>比起SCAN算法来,平均寻道时间更长。</p>
</li>
</ul>
</li>
<li>
<p>NStepSCAN算法</p>
<ul>
<li>
<p>在高密度磁盘.上容易出现“磁臂粘着”情况。</p>
</li>
<li>
<p>将磁盘请求队列分成若干个长度为N的子队列。</p>
</li>
<li>
<p>队列之间使用FCFS算法。</p>
</li>
<li>
<p>队列内部使用SCAN算法。</p>
</li>
<li>
<p>新的I/O请求，放入其他队列，避免粘着现象。</p>
</li>
<li>
<p>当N值很大时，性能接近于SCAN算法。</p>
</li>
<li>
<p>当N=1时，蜕化为FCFS算法。</p>
</li>
</ul>
</li>
<li>
<p>FSCAN算法</p>
<ul>
<li>
<p>是N步SCAN算法的简化。</p>
</li>
<li>
<p>磁盘请求队列分成两个子队列。</p>
</li>
<li>
<p>一个是由当前所有请求磁盘I/O的进程形成的队列，按SCAN算法进行处理。</p>
</li>
<li>
<p>新出现的所有请求磁盘I/O的进程，放入另- -个等待处理的请求队列。</p>
</li>
</ul>
</li>
</ul>  <div class="date" data-astro-cid-bvzihdzo>
发布于：<time datetime="2025-12-19T02:24:19.000Z"> Dec 19, 2025 </time> <div class="last-updated-on" data-astro-cid-bvzihdzo>
编辑于：<time datetime="2025-12-19T02:24:19.000Z"> Dec 19, 2025 </time> </div> </div> </div> </article> <aside class="blog-sidebar" data-astro-cid-bvzihdzo> <nav class="table-of-contents" id="toc" data-astro-cid-xvrfupwn><div class="toc-title" data-astro-cid-xvrfupwn>目录</div><ul class="toc-list" data-astro-cid-xvrfupwn><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#io系统" data-astro-cid-xvrfupwn>I/O系统</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#io软件" data-astro-cid-xvrfupwn>I/O软件</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#系统接口" data-astro-cid-xvrfupwn>系统接口</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#io设备" data-astro-cid-xvrfupwn>I/O设备</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#设备控制器" data-astro-cid-xvrfupwn>设备控制器</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#内存映像io" data-astro-cid-xvrfupwn>内存映像I/O</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#设备驱动程序" data-astro-cid-xvrfupwn>设备驱动程序</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#与设备无关的io软件" data-astro-cid-xvrfupwn>与设备无关的I/O软件</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#设备分配" data-astro-cid-xvrfupwn>设备分配</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#用户层io软件" data-astro-cid-xvrfupwn>用户层I/O软件</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#假脱机系统spooling" data-astro-cid-xvrfupwn>假脱机系统(spooling)</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#缓冲区管理" data-astro-cid-xvrfupwn>缓冲区管理</a></li><li class="toc-item toc-level-2" data-astro-cid-xvrfupwn><a href="#磁盘" data-astro-cid-xvrfupwn>磁盘</a></li><li class="toc-item toc-level-3" data-astro-cid-xvrfupwn><a href="#磁盘调度算法" data-astro-cid-xvrfupwn>磁盘调度算法</a></li></ul></nav> </aside> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 @charlesix59. All rights reserved.
<div class="social-links" data-astro-cid-sz7xmlte> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg> </a> </div> </footer>  </body></html>