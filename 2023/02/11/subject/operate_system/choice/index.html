<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon.png"><link rel="icon" href="/images/icon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="charlesix59"><meta name="keywords" content=""><meta name="description" content="操作系统关键部分摘要引论操作系统的作用 作为用户与计算机硬件系统之间的接口 作为计算机系统资源的管理者 实现了对计算机资源的抽象  操作系统的种类 单道批处理系统： 批处理是指计算机系统对一批作业自动进行处理的一种技术。  为实现对作业的连续处理,需要先把一批作业以脱机方式输入到磁带上,并在系统中配上监督程序(Monitor) ,在它的控制下,使这批作业能一个接一地连续处理   多道批处理系统"><meta property="og:type" content="article"><meta property="og:title" content="操作系统复习 第八章"><meta property="og:url" content="2023/02/11/subject/operate_system/choice/index.html"><meta property="og:site_name" content="茶理的私人博客"><meta property="og:description" content="操作系统关键部分摘要引论操作系统的作用 作为用户与计算机硬件系统之间的接口 作为计算机系统资源的管理者 实现了对计算机资源的抽象  操作系统的种类 单道批处理系统： 批处理是指计算机系统对一批作业自动进行处理的一种技术。  为实现对作业的连续处理,需要先把一批作业以脱机方式输入到磁带上,并在系统中配上监督程序(Monitor) ,在它的控制下,使这批作业能一个接一地连续处理   多道批处理系统"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-02-11T09:49:58.539Z"><meta property="article:modified_time" content="2023-02-13T09:32:37.612Z"><meta property="article:author" content="charlesix59"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>操作系统复习 第八章 - 茶理的私人博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script type="text/javascript" src="/js/love.js"></script><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"https:/charlesix59.github.io",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><script type="text/javascript" color="0,160,230" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>茶理的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/moment/"><i class="iconfont icon-link-fill"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="操作系统复习 第八章"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-11 17:49" pubdate>2023年2月11日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 73 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统复习 第八章</h1><div class="markdown-body"><h1 id="操作系统关键部分摘要"><a href="#操作系统关键部分摘要" class="headerlink" title="操作系统关键部分摘要"></a>操作系统关键部分摘要</h1><h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li>作为用户与计算机硬件系统之间的接口</li><li>作为计算机系统资源的管理者</li><li>实现了对计算机资源的抽象</li></ul><h3 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h3><ul><li>单道批处理系统：<ul><li>批处理是指计算机系统对一批作业自动进行处理的一种技术。</li><li>为实现对作业的连续处理,需要先把一批作业以脱机方式输入到磁带上,并在系统中配上监督程序(Monitor) ,在它的控制下,使这批作业能一个接一地连续处理</li></ul></li><li>多道批处理系统<ul><li>在多道批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”; 然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</li></ul></li><li>分时系统<ul><li>采用时间片轮转的方法，同时为许多终端用户服务，对每个用户能保证足够快的响应时间，并提供交互会话的功能。</li><li>时间片：将CPU的时间划分成若干个片段，称为时间片，操作系统以时间片为单位，轮流为每个终端用户服务关键问题</li></ul></li><li>微机操作系统<ul><li>微型计算机操作系统 微型计算机操作系统简称微机操作系统，常用的有Windows、Mac OS、Linux。</li></ul></li></ul><h3 id="现代操作系统的特性"><a href="#现代操作系统的特性" class="headerlink" title="现代操作系统的特性"></a>现代操作系统的特性</h3><p><mark>并发性</mark>、<mark>共享性</mark>、虚拟性、异步性</p><h3 id="操作系统程序接口"><a href="#操作系统程序接口" class="headerlink" title="操作系统程序接口"></a>操作系统程序接口</h3><p>由一组系统调用组成,每一个系统调用都是一个能完成特定功能的子程序,每当应用程序要求OS提供某种服务时,便调用具有相应功能的系统调用。</p><h3 id="操作系统内核态与用户态"><a href="#操作系统内核态与用户态" class="headerlink" title="操作系统内核态与用户态"></a>操作系统内核态与用户态</h3><p><mark>内核态（管态）和用户态（目态）将内核程序和用户程序隔离</mark></p><ul><li><p><font color="red">特权指令</font></p><ul><li><p>涉及外部设备的输入&#x2F;输出指令</p></li><li><p>存取用于内存保护的寄存器</p></li><li><p>内存清零</p></li><li><p>置时钟</p></li><li><p>允许&#x2F;禁用中断</p></li></ul></li></ul><p><mark>中断指令</mark>是用户程序发起的调用内核代码的唯一方式</p><ul><li><p>中断机制</p><ul><li><p>提高多道程序环境下CPU利用率</p></li><li><p>外中断：中断信号来源于外部设备</p></li><li><p>内中断：中断信号来源于当前指令内</p></li></ul></li><li><p>内中断的三种情况</p><ul><li><p>陷阱&#x2F;陷入：由应用程序主动引发</p></li><li><p>故障：由错误条件引发</p></li><li><p>终止：由致命错误引发</p></li></ul></li><li><p>系统调用的核心</p><ul><li><p>用户程序中包含一段含有int指令的代码</p></li><li><p>操作系统写中断处理，获取想调用程序的编号</p></li><li><p>int指令将使CPL改成0 ，“进入内核”</p></li><li><p>操作系统根据编号执行相应代码</p></li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>程序段、数据段、<strong>PCB</strong>三部分构成了进程实体,简称”进程”。</p><h3 id="进程的三种状态"><a href="#进程的三种状态" class="headerlink" title="进程的三种状态"></a>进程的三种状态</h3><ul><li>就绪状态(Ready)<ul><li>进程已获得除CPU之外的所有必需的资源,一旦得到CPU控制权,立即可以运行</li></ul></li><li>运行状态(Running)<ul><li>进程已获得运行所必需的资源，它正在处理机上执行。</li></ul></li><li>阻塞状态(Blocked)<ul><li>正在执行的进程由于发生某事件而暂时无法执行时,便放弃处理机而处于暂停状态,称该进程处于阻塞状态或等待状态。</li></ul></li></ul><h3 id="PCB的定义"><a href="#PCB的定义" class="headerlink" title="PCB的定义"></a>PCB的定义</h3><p>PCB是内存中的一种数据结构，PCB的作用是使一个在多道程序环境下不能独立运行的程序(含数据) ,成为一个能独立运行的基本单位, 一个能与其他进程并发执行的进程</p><p><mark>PCB是进程存在的唯一标志</mark></p><h3 id="PCB的内容"><a href="#PCB的内容" class="headerlink" title="PCB的内容"></a>PCB的内容</h3><table><thead><tr><th>类型</th><th>内容</th><th>作用</th></tr></thead><tbody><tr><td>标识信息</td><td>1 )外部标识为方便用户<br>2 )内部标识为方便系统</td><td>标识一个进程</td></tr><tr><td>处理机状态(现场信息 )</td><td>1 ) CPU通用&#x2F;指令寄存器<br>2 ) CPU程序状态字PSW<br>3 )用户栈指针</td><td>记录处理机现场信息,以备恢复之用</td></tr><tr><td>调度信息</td><td>1 )进程状态<br>2 )进程优先级<br>3 )调度所需信息<br>4)事件</td><td>用户进程的调度管理</td></tr><tr><td>控制信息</td><td>1 )程序和数据地址<br>2 )进程同步和通信机制<br>3 )资源清单<br>4 )指向下一个进程的指针</td><td>用于进程的控制管理</td></tr></tbody></table><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul><li><p>引起创建进程的事件</p><ul><li><p>用户登录</p></li><li><p>作业调度</p></li><li><p>提供服务</p></li><li><p>应用请求</p></li></ul></li><li><p>创建过程</p><ul><li><p>申请进程标识,即申请空白PCB</p></li><li><p>为新进程分配内存和其它资源</p></li><li><p>初始化进程控制块</p></li><li><p>将创建的进程置于就绪队列</p></li></ul></li></ul><h3 id="进程控制的原语"><a href="#进程控制的原语" class="headerlink" title="进程控制的原语"></a>进程控制的原语</h3><ul><li><p>进程创建原语</p></li><li><p>进程撤销原语</p></li><li><p>阻塞原语</p></li><li><p>唤醒原语</p></li><li><p>挂起原语</p></li><li><p>激活原语</p></li></ul><h3 id="临界区的定义"><a href="#临界区的定义" class="headerlink" title="临界区的定义"></a>临界区的定义</h3><p>临界区：进程中访问临界资源的那段代码</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><font color="red">信号量</font></h3><ul><li><p>定义:把整型信号量定义为一个用于表示资源数目的整型量S ,除初始化外仅能通过两个原子操作wait(S)，signal(S)（低级原语）来访问</p></li><li><p>原子操作P :</p><ul><li><p>分配一个单位资源</p></li><li><p>wait(S)</p></li></ul></li><li><p>原子操作V :</p><ul><li>释放一个单位资源</li></ul></li></ul><p>当信号量sign 大于0时，表示该资源该有sign个。当sign小于0时，表示有sign个进程正在等待</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是由若干个公共变量和所有访问这些变量的过程所组成的一个特殊的模块或软件包</p><h3 id="其他进程同步机制（有各种各样的问题）"><a href="#其他进程同步机制（有各种各样的问题）" class="headerlink" title="其他进程同步机制（有各种各样的问题）"></a>其他进程同步机制（有各种各样的问题）</h3><ul><li>关中断法(开关中断指令)也称为”硬件锁”,在进入锁测试之前关闭中断,直到完成锁测试并上锁之后才能打开中断。</li><li>利用Test and Set指令实现互斥：这是一种借助一条硬件指令一“测试并建立”指令TS(Test- and-Set)以实<br>现互斥的方法。在许多计算机中都提供了这种指令。</li><li>利用swap指令实现线程互斥</li></ul><h3 id="管道的定义"><a href="#管道的定义" class="headerlink" title="管道的定义"></a>管道的定义</h3><ul><li><p>管道:指用于连接-个读进程和一个写进程以实现他们之间通信的一个打开的共享文件,又名pipe文件。</p></li><li><p>管道只能采取半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,则需要设置两个管道各个进程要互斥的访问管道</p></li><li><p>数据以字节流的形式写入管道,当管道写满时,写进程的write()系统调用将会被阻塞,等待读进程将数据取走。当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将会被阻塞</p></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程(thread)是一个可执行的实体单元。<mark>它代替以往的进程,成为现代操作系统中处理机调度的基本单位。</mark></p><p><strong>调度的基本单位</strong></p><ul><li><p>同一进程中的线程切换不会引起进程切换</p></li><li><p>不同进程中的线程切换必然引起进程切换</p></li></ul><p><strong>用户级线程</strong></p><ul><li><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能,都无须利用系统调用来实现。</p></li><li><p>对于用户级线程的切换,通常是发生在一个应用进程的诸多线程之间,无须内核的支持。</p></li><li><p>切换的规则远比进程调度和切换的规则简单</p></li></ul><p><strong>内核支持线程KST</strong></p><ul><li><p>在内核的支持下运行的，即无论是用户进程中的线程,还是系统进程中的线程,他,们的创建、撤消和切换等,也是依靠内核实现的。</p></li><li><p><strong>在内核空间还为每一个内核支持线程设置了一个线程控制块</strong> ,内核是根据该控制块而感知某线程的存在的,并对其加以控制。</p></li></ul><p>线程控制块TCB</p><ul><li><p>线程标识符;</p></li><li><p>组寄存器，它包括程序计数器PC、状态寄存器和通用寄存器;</p></li><li><p>线程运行状态,用于描述线程正处于何种运行状态;</p></li><li><p>优先级，描述线程执行的优先程度;</p></li><li><p>线程专有存储区，用于线程切换时存放现场保护信息,和相关统计信息;</p></li><li><p>信号屏蔽，即对某些信号加以屏蔽。</p></li><li><p>堆栈,用来保存局部变量和返回地址。</p><ul><li>用户栈和核心栈</li></ul></li></ul><h2 id="调度机制与死锁"><a href="#调度机制与死锁" class="headerlink" title="调度机制与死锁"></a>调度机制与死锁</h2><h3 id="作业调度——先来先服务算法（First-Come-First-Serve）"><a href="#作业调度——先来先服务算法（First-Come-First-Serve）" class="headerlink" title="作业调度——先来先服务算法（First Come First Serve）"></a>作业调度——先来先服务算法（First Come First Serve）</h3><p>基本原则是按照作业到达系统的先后次序来选择,或者说它是优先考虑在系统中等待时间最长的作业,而不管该作业所需执行时间的长短。</p><h3 id="作业调度——短作业优先（Short-Job-First）调度算法"><a href="#作业调度——短作业优先（Short-Job-First）调度算法" class="headerlink" title="作业调度——短作业优先（Short Job First）调度算法"></a>作业调度——<font color="red">短作业优先（Short Job First）调度算法</font></h3><p>SJF算法是以作业的长短来计算优先级,作业越短,其优先级越高。</p><h3 id="作业调度——高响应比优先调度算法"><a href="#作业调度——高响应比优先调度算法" class="headerlink" title="作业调度——高响应比优先调度算法"></a>作业调度——高响应比优先调度算法</h3><ul><li><p>为每个作业引入一个动态优先级,即优先级是可以改变的，令它随等待时间延长而增加,这将使长作业的优先级在等待期间不断地增加,等到足够的时间后,必然有机会获得处理机。该优先级的变化规律可描述为:</p><p>$$<br>R_p&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}&#x3D;\frac{响应时间}{要求服务时间}<br>$$</p></li></ul><h3 id="响应比"><a href="#响应比" class="headerlink" title="响应比"></a>响应比</h3><p>(等待时间+执行时间)&#x2F;执行时间</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a><a target="_blank" rel="noopener" href="https://charlesix59.github.io/2023/02/07/subject/operate_system/chapter3/#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">进程调度算法</a></h3><p>考得不大具体，了解即可</p><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁( Deadlock ) 是指多个进程在运行过程中因争夺资源而造成的一种僵局</p><p><strong>死锁原因</strong></p><ul><li><p>竞争不可抢占性资源</p></li><li><p>竞争可消耗资源</p></li><li><p>进程推进顺序不当</p></li></ul><p><strong>产生死锁的必要条件</strong></p><ul><li><p>互斥条件</p></li><li><p>请求和保持条件</p></li><li><p>不可抢占条件</p></li><li><p>循环等待条件</p></li></ul><h4 id="死锁的预防、避免、检查与解除"><a href="#死锁的预防、避免、检查与解除" class="headerlink" title="死锁的预防、避免、检查与解除"></a><a target="_blank" rel="noopener" href="https://charlesix59.github.io/2023/02/07/subject/operate_system/chapter3/#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81">死锁的预防、避免、检查与解除</a></h4><p>这一块内容很多还挺重要的，慢慢看吧</p><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>存储器管理的目的：提高内存利用率、方便用户</p><h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p><strong>重定位</strong>：<br>在装入时对目标程序中指令和数据的修改过程称为重定位。</p><p><strong>绝对装入方式</strong>：<br>在编译时,如果知道程序驻留在内存的什么位置,那么编译程序将产生绝对地址的目标代码。</p><p><strong>可重定位装入方式（Relocation Loading Mode）</strong>：<br>在多道程序环境下,可重定位装入方式,根据内存的当前情况,将装入模块装入到内存的适当位置。</p><p><strong>动态重定位</strong>：</p><ul><li>在把装入模块装入内存后,并不立即把装入模块中的相对地址转换为绝对地址,而是把这种地址转换推迟到程序真正要执行时(访问内存之前)才进行。</li></ul><h3 id="连续分配存储方式"><a href="#连续分配存储方式" class="headerlink" title="连续分配存储方式"></a>连续分配存储方式</h3><ul><li>单一连续分配：系统区加用户区，连续的分配</li><li>固定分区分配：将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业,便可以有多道作业并发执行。</li><li>动态分区分配：动态分区法在作业执行前并不建立分区,分区的建立是在作业的处理过程中进行的,且其大小可随作业或进程对内存的要求而改变。<mark>分区分配算法有</mark>：<ul><li>首次适应算法：要求按地址递增的次序组织空闲区表(链)。</li><li>循环首次适应算法（Next Fit）：每次分配不再从空闲分区链(表)的开始找起,而是从上次找到的空闲分区的下一个找起,找到一个能满足要求的空闲区。</li><li><font color="red">最佳适应算法（Best Fit)</font>：把能满足要求的最小空闲分区分配给作业,避免“大材小用”</li><li>最坏适应算法(Worst Fit)：总是挑选最大的空闲分区分割给作业使用</li><li>快速适应算法：将空闲分区按大小分类,每类具有相同容量，放入一个空闲分区链表</li><li>伙伴系统：无论已分配分区或空闲分区,分区大小必须是2的k次幂，k为整数, I≤k≤m</li><li>哈希算法:哈希算法就是利用哈希快速查找优点,以及空闲分区在可利用空间表中的分布规律,建立哈希函数,构造一张以空闲分区大小为关键字的哈希表,该表的每一个表项记录了一个对应的空闲分区链表表头指针。</li></ul></li></ul><h3 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h3><p><strong>页面</strong></p><ul><li><p>把进程的逻辑地址空间划分成若干大小相等的区域,每个区域称作<strong>页面</strong>或<strong>页</strong>。每个页都有一个编号,叫做页号。页号一般从0开始编号,如0 , 1, 2, …等。</p></li><li><p>把内存空间划分成若干和页大小相同的物理块，这些物理块叫<strong>页框</strong>(frame)或(物理)块。同样,每个物理块也有一个编号，块号从0开始依次顺序排列。</p></li><li><p>以<strong>页</strong>为单位进行内存分配,并按进程的页数多少来分配。逻辑上相邻的页,物理上不一定相邻。</p></li></ul><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>虚拟存储器:是指具有请求调入功能和置换功能,能从逻辑.上对内存容量加以扩充的一种存储器系统。</p><p><mark>虚拟内存的实际容量 &#x3D; min（内存与外存之和, CPU寻址范围）</mark></p><p><mark>虚拟存储器的实现都是建立在离散分配的存储管理方式的基础上。</mark></p><h3 id="请求分页系统"><a href="#请求分页系统" class="headerlink" title="请求分页系统"></a>请求分页系统</h3><p>在分页系统的基础上,增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。置换时以页面为单位。</p><p>硬件支持:</p><ul><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ul><h3 id="物理块分配策略"><a href="#物理块分配策略" class="headerlink" title="物理块分配策略"></a>物理块分配策略</h3><p>在请求分页系统中,可采取两种内存分配策略:</p><ul><li><p>固定分配策略:为每个进程分配一定数目的物理块,在整个运行期间不再改变</p></li><li><p>可变分配策略:先为每个进程分配一定数量的物理块,在整个运行期间可适当增多或减少。</p></li></ul><p>在进行置换时,也可采取两种策略</p><ul><li><p>全局置换:可以将操作系统保留的空闲物理快分配给进程,也可以将别的进程持有的物理块置换到外存,再分配给缺页进程。</p></li><li><p>局部置换:发生缺页时,只选进程自己的物理块置换</p></li></ul><p>组合出的三种策略：（不能采用固定分配全局置换）</p><ul><li><p>固定分配局部置换(Fixed Allocation , Local Replacement)</p><ul><li><p>为每个进程分配一定数目的物理块,在整个运行期间不再改变。</p></li><li><p>采用该策略时,如果进程在运行中发现缺页,只能从该进程在内存中的n个页面中选出一页换出,然后再调入一页。</p></li><li><p>困难:应为每个进程分配多少个物理块难以确定。</p></li></ul></li><li><p>可变分配全局置换(Variable Allocation , Global Replacement)</p><ul><li><p>在采用这种策略时,先为系统中的每个进程分配一定数目的物理块,而OS自身也保持一个空闲的物理块队列。</p></li><li><p>如果某进程发生缺页时,由系统从空闲的物理块队列中,取出一个物理块分配给该进程,并将欲调入的页装入其中。</p></li><li><p>当空闲物理块队列中的物理块用完后, OS才能从系统中的任一进程中选择一页调出。</p></li></ul></li><li><p>可变分配局部置换(Variable Allocation , Local Replacement)</p><ul><li><p>为每个进程分配一定数目的物理块,如果某进程发生缺页时,只允许从该进程在内存的页面中选出一页换出,不会影响其他进程执行。</p></li><li><p>如果进程在运行中频繁发生缺页中断,则系统再为进程分配若干物理块</p></li><li><p>如果进程在运行中缺页率特别低,则适当减少分配给该进程的物理块</p></li></ul></li></ul><p><strong>交换(swap)分区</strong>：<br>Swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li><p>最佳置换算法</p><ul><li>算法无法实现，但可评价其他算法。</li></ul></li><li><p>先入先出页面（FIFO）置换算法</p><ul><li>算法总是淘汰最先进入内存的页面,即选择在内存中驻留时间最久的页面予以淘汰。</li><li><strong>Belady现象</strong><ul><li>采用FIFO算法时,如果对一个进程未分配它所要求的全部页面,有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</li></ul></li></ul></li><li><p><font color="red">最近最久未使用（LeastRecently Used）算法</font></p><ul><li>算法根据页面调入内存后的使用情况进行决策。由于无法预测各页面将来的使用情况,只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。</li><li>该算法赋予每个页面一个访问字段,用来记录一个页面自上次被访问以来所经历的时间t ,当需淘汰一个页面时,选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</li><li>需有以下两类硬件之一的支持:<ul><li>寄存器</li><li>栈</li></ul></li></ul></li><li><p>最少使用置换（Least Frequently Used)算法</p><ul><li>在采用LFU算法时,应为在内存中的每个页面设置一个移位寄存器,用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。</li></ul></li><li><p>简单的Clock置换算法</p><ul><li><p>当采用简单Clock算法时,只需为每页设置一位访问位,再将内存中的所有页面都通过链接指针链接成一个循环队列。</p></li><li><p>当某页被访问时,其访问位被置1。</p></li><li><p>置换算法在选择一页淘汰时,只需检查页的访问位。如果是0 ,就选择该页换出;若为1 ,则重新将它置0 ,暂不换出,而给该页第二次驻留内存的机会</p></li><li><p>再按照FIFO算法检查下一个页面。</p></li><li><p>当检查到队列中的最后一个页面时,若其访问位仍为1 ,则再返回到队首去检查第一个页面。</p></li><li><p>因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描</p></li></ul></li><li><p><font color="red">改进型CLock算法</font></p><ul><li><p>在将一个页面换出时,如果该页已被修改过,便须将该页重新写回到磁盘上;但如果该页未被修改过,则不必将它拷回磁盘。</p></li><li><p>在改进型Clock算法中,除须考虑页面的使用情况外,还须再增加一个因素,即置换代价,这样,选择页面换出时,既要是未使用过的页面,又要是未被修改过的页面。</p></li><li><p>把同时满足这两个条件的页面作为首选淘汰的页面。</p></li><li><p>由访问位A和修改位M可以组合成下面四种类型的页面:</p><ul><li><p>1类(A&#x3D;0 , M&#x3D;0) :表示该页最近既未被访问,又未被修改,是最佳淘汰页。</p></li><li><p>2类(A&#x3D;0 , M&#x3D;1) :表示该页最近未被访问,但已被修改,并不是很好的淘汰页。</p></li><li><p>3类(A&#x3D;1 , M&#x3D;0) :表示该页最近已被访问,但未被修改,该页有可能再被访问。</p></li><li><p>4类(A&#x3D;1 , M&#x3D;1) :表示该页最近已被访问且被修改,该页可能再被访问。</p></li></ul></li><li><p>(1)从指针所指示的当前位置开始,扫描循环队列,寻找A&#x3D;0且M&#x3D;0的第一类页面,将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。</p></li><li><p>(2)如果第一步失败,则开始第二轮扫描,寻找A&#x3D;0且M&#x3D; 1的第二类页面,将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间,将所有扫描过的页面的访问位都置0。</p></li><li><p>(3)如果第二步也失败,则将指针返回到开始的位置,然后回到第一步重新开始,一定能找到被淘汰的页。</p></li><li><p>该算法与简单Clock算法比较，可减少磁盘的I&#x2F;O操作次数。但为了找到一个可置换的页，可能须经过几轮扫描。换言之,实现该算法的开销有所增加。</p></li></ul></li></ul><h3 id="预防抖动"><a href="#预防抖动" class="headerlink" title="预防抖动"></a>预防抖动</h3><p><mark>刚被淘汰的页面又马上被调回内存,调回内存不久后又被淘汰出去,如此频繁进行,这种现象称为抖动(或称颠簸)</mark></p><p><strong>所谓工作集,是指在某段时间间隔△里,进程实际所要访问页面的集合。</strong></p><p><font color="red">预防抖动的策略</font></p><ul><li><p>采取局部置换策略</p></li><li><p>把工作集算法融入到处理机调度中</p></li><li><p>利用”L&#x3D;S”准则调节缺页率</p></li><li><p>选择暂停的进程</p></li><li><p>当多道程序度偏高时,已影响到处理机的利用率,为了防止发生“抖动”,系统必须减少多道程序的数目,以便腾出内存空间分配给那些缺页率偏高的进程。</p></li></ul><h2 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h2><h3 id="I-x2F-O-系统-（四个层级从低到高）"><a href="#I-x2F-O-系统-（四个层级从低到高）" class="headerlink" title="I&#x2F;O 系统 （四个层级从低到高）"></a>I&#x2F;O 系统 （四个层级从低到高）</h3><ul><li><p>中断处理程序</p><ul><li>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</li></ul></li><li><p>设备驱动程序</p><ul><li>驱动程序一般会以一个独立进程的方式存在。</li><li>主要负责对硬件设备的具体控制，将上层发出的一系列命令(如read&#x2F;write) 转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等</li></ul></li><li><p>设备独立性软件</p><ul><li><p>他的主要功能有:</p><ul><li><p>向上层提供统一的调用接口，如read&#x2F;write系统调用</p></li><li><p>设备的分配与回收</p></li><li><p>差错处理</p></li><li><p>数据缓冲区管理</p></li><li><p>建立逻辑设备名到物理设备名的映射关系:根据设备类型选择调用相应的驱动程序</p></li></ul></li></ul></li><li><p>用户层软件</p><ul><li>实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作。</li></ul></li></ul><h3 id="设备驱动设备的控制方式"><a href="#设备驱动设备的控制方式" class="headerlink" title="设备驱动设备的控制方式"></a>设备驱动设备的控制方式</h3><p>控制方式</p><ul><li><p>宗旨：尽量减少主机对I&#x2F;O控制的干预，把主机从繁杂的IO控制事务中解脱出来</p></li><li><p>忙——等待方式</p><ul><li><p>CPU向控制器发出I&#x2F;O指令,启动输入设备。</p></li><li><p>状态寄存器忙&#x2F;闲标志busy置1。</p></li><li><p>循环测试busy, busy&#x3D; 1输入未完成。</p></li><li><p>busy&#x3D;0输入完成，将数据从控制器的数据寄存器读到内存</p></li><li><p>由于CPU高速,I&#x2F;O设备低速致使CPU极大浪费。</p></li></ul></li><li><p>使用中断的可编程I&#x2F;O方式</p><ul><li><p>CPU向控制器发出I&#x2F;O指令，CPU返回继续原来的工作。</p></li><li><p>设备控制器控制I&#x2F;O设备。CPU与I&#x2F;O并行工作。</p></li><li><p>数据输入寄存器，控制器向CPU发出中断。</p></li><li><p>CPU检查数据正确性，数据写入内存。</p></li></ul></li><li><p><font color="red">直接存储器访问(Direct Memory Access)</font></p><ul><li><p>特点</p><ul><li><p>数据传输的基本单位是数据块。</p></li><li><p>数据从设备直接送入内存，或者相反。</p></li><li><p>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p></li></ul></li><li><p>DMA控制器</p><ul><li><p>三部分</p><ul><li><p>主机与DMA控制器的接口</p></li><li><p>DMA控制器与块设备的接口</p></li><li><p>I&#x2F;O控制逻辑</p></li></ul></li><li><p>四类寄存器</p><ul><li><p>数据寄存器DR</p></li><li><p>命令&#x2F;状态寄存器CR</p></li><li><p>内存地址寄存器MAR</p></li><li><p>数据计数器DC</p></li></ul></li></ul></li><li><p>DMA工作过程</p><ul><li><p>CPU发出指令，存入CR</p></li><li><p>内存起始目标地址送入MAR。</p></li><li><p>读取字节数送DC。</p></li><li><p>源地址送DMA的I&#x2F;O控制逻辑。</p></li><li><p>启动DMA控制器，CPU处理其他任务。</p></li><li><p>DMA控制读入一个字(节)到DR。</p></li><li><p>将该字(节)送入MAR指向的内存单元。</p></li><li><p>MAR加1，DC减1。</p></li><li><p>DC&lt;&gt; 0继续传输，DC&#x3D;0发出中断。</p></li></ul></li><li><p>中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理。</p></li><li><p>DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数。</p></li><li><p>中断方式的数据传送是由CPU控制完成的，而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。</p></li></ul></li><li><p>I&#x2F;O通道控制方式</p><ul><li>目的：CPU的I&#x2F;O任务由通道来承担。</li><li>一种特殊的处理机，属于硬件技术。它具有执行I&#x2F;O指令的能力，并通过执行通道程序来控制I&#x2F;O操作。</li><li>指令类型单一、 即由于通道硬件比较简单，其所能执行的指令，主要为与I&#x2F;O有关的指令</li><li>通道没有自己的内存，与CPU共享内存</li><li>CPU一次读(或写)多个数据块。</li><li>多个数据块送入不同内存区域。</li><li>CPU、通道和I&#x2F;O设备三者的并行操作。</li><li>工作过程:<ul><li>CPU向通道发送一条I&#x2F;O指令。</li><li>给出通道程序首址和要访问的I&#x2F;O设备。</li><li>通过执行通道程序完成I&#x2F;O任务。</li></ul></li><li>通道程序由一系列通道指令(通道命令)构成。</li><li>每条通道指令包含的信息:<ul><li>操作码</li><li>内存地址</li><li>计数</li><li>通道程序结束位P (P&#x3D; 1表示程序结束)</li><li>记录结束标志R (R&#x3D;0表示与下一条指令处理的数据属于同一记录;R&#x3D; 1表示某记录的最后一条指令)</li></ul></li><li>字节多路通道(Byte Multiplexor Channel)<ul><li>字节多路通道以字节为单位传输信息</li><li>含有许多非分配型子通道</li><li>子通道按时间片轮转方式共享通道</li><li>只要扫描每个子通道的速度足够快，而连接到子同上的设备的速率较小的时，不丢数据</li><li>主要连接以字节为单位的低速I&#x2F;O设备,如:打印机、终端</li></ul></li></ul></li></ul><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p><font color="red">用户编程时使用的硬件名称与实际使用的设备名称不同</font></p><h3 id="假脱机系统-spooling"><a href="#假脱机系统-spooling" class="headerlink" title="假脱机系统(spooling)"></a>假脱机系统(spooling)</h3><p>在多道程序技术下，专门利用一道程序来模拟脱机输入操作，<font color="red">把低速I&#x2F;O设备上的数据传送到高速磁盘上</font>，<br>再用另一道程序来模拟脱机输出操作，把数据从磁盘传送到输出设备上。</p><ul><li>此时I&#x2F;O设备与CPU并行工作。</li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p>单缓冲区(Single Buffer)</p><ul><li>进程发出一个I&#x2F;O请求时，操作系统便在主存中为之分配一缓冲区。</li></ul><p>双缓冲区</p><ul><li><p>在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时OS可以从第二缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。</p></li><li><p>为了实现两台机器间的双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另外一个用作接收缓冲区。</p></li></ul><p><font color="red"></font></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="categories/课程笔记/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="tags/OS/">#OS</a></div></div><div class="license-box my-3"><div class="license-title"><div>操作系统复习 第八章</div><div>2023/02/11/subject/operate_system/choice/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>charlesix59</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月11日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="2023/02/07/subject/software_project/chapter11/" title="软件工程复习 第十一章"><span class="hidden-mobile">软件工程复习 第十一章</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.5.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.5.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://hexo-comment-qncm4vegj-charlesix59.vercel.app/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/bilibili"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class=":" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">create by Charles Min at 2022 @CopyRight</div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/about/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?charlesix59",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"charlesix59")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style>#github_container>.position-relative>.border{border:0!important}#github-calendar{position:relative;margin-top:-2rem;background-color:var(--board-bg-color);transition:background-color .2s ease-in-out;border-radius:.5rem;z-index:3;-webkit-box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%)}</style></body></html>