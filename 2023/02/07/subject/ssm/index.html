<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon.png"><link rel="icon" href="/images/icon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="charlesix59"><meta name="keywords" content=""><meta name="description" content="SSM 73问mybaits 21问Mybaits与Hibernate的异同？Hibernate与MyBatis都是ORM框架，都有相应的代码生成工具，可以生成简单基本的DAO层方法。 Mybaits是半ORM框架，Hibernate是全ORM框架 Mybaits需要手动写SQL语句，Hibernate不需要 什么是ORM？对象关系映射（英语：Object Relational Mapping，简"><meta property="og:type" content="article"><meta property="og:title" content="茶理的私人博客"><meta property="og:url" content="2023/02/07/subject/ssm/index.html"><meta property="og:site_name" content="茶理的私人博客"><meta property="og:description" content="SSM 73问mybaits 21问Mybaits与Hibernate的异同？Hibernate与MyBatis都是ORM框架，都有相应的代码生成工具，可以生成简单基本的DAO层方法。 Mybaits是半ORM框架，Hibernate是全ORM框架 Mybaits需要手动写SQL语句，Hibernate不需要 什么是ORM？对象关系映射（英语：Object Relational Mapping，简"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="2023/02/07/subject/ssm/core_container.png"><meta property="og:image" content="http://c.biancheng.net/uploads/allimg/220119/1F32KG1-0.png"><meta property="og:image" content="http://c.biancheng.net/uploads/allimg/210705/1139441444-0.png"><meta property="article:published_time" content="2023-02-07T07:29:34.542Z"><meta property="article:modified_time" content="2023-02-08T08:56:20.571Z"><meta property="article:author" content="charlesix59"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="2023/02/07/subject/ssm/core_container.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>茶理的私人博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script type="text/javascript" src="/js/love.js"></script><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"https:/charlesix59.github.io",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><script type="text/javascript" color="0,160,230" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>茶理的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/moment/"><i class="iconfont icon-link-fill"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text=""></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-07 15:29" pubdate>2023年2月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 46k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 387 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none"></h1><div class="markdown-body"><h1 id="SSM-73问"><a href="#SSM-73问" class="headerlink" title="SSM 73问"></a>SSM 73问</h1><h2 id="mybaits-21问"><a href="#mybaits-21问" class="headerlink" title="mybaits 21问"></a>mybaits 21问</h2><h3 id="Mybaits与Hibernate的异同？"><a href="#Mybaits与Hibernate的异同？" class="headerlink" title="Mybaits与Hibernate的异同？"></a>Mybaits与Hibernate的异同？</h3><p>Hibernate与MyBatis都是ORM框架，都有相应的代码生成工具，可以生成简单基本的DAO层方法。</p><p>Mybaits是半ORM框架，Hibernate是全ORM框架</p><p>Mybaits需要手动写SQL语句，Hibernate不需要</p><h3 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h3><p><strong>对象关系映射</strong>（英语：<strong>Object Relational Mapping</strong>，简称<strong>ORM</strong>，或<strong>O&#x2F;RM</strong>，或<strong>O&#x2F;R mapping</strong>），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。</p><p>目的是<strong>使用面向对象的方法操纵数据库</strong></p><h3 id="mybatis怎么配置环境信息？"><a href="#mybatis怎么配置环境信息？" class="headerlink" title="mybatis怎么配置环境信息？"></a>mybatis怎么配置环境信息？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        default:默认的环境 ID--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--            事务管理器的配置</span><br><span class="hljs-comment">如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器</span><br><span class="hljs-comment"> - JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。</span><br><span class="hljs-comment"> - MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期</span><br><span class="hljs-comment">--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><span class="hljs-comment">&lt;!--            数据源的配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="mybaits的setting有什么作用？"><a href="#mybaits的setting有什么作用？" class="headerlink" title="mybaits的setting有什么作用？"></a>mybaits的setting有什么作用？</h3><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。</p><table><thead><tr><th>设置参数</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>该配置影响的所有映射器中配置的缓存的全局开关。</td><td>true,false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置<code>fetchType</code>属性来覆盖该项的开关状态。</td><td>true,false</td><td>false</td></tr><tr><td>aggressiveLazyLoading</td><td>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。</td><td>true,false</td><td>false （在 3.4.1 及之前的版本中默认为 true）</td></tr><tr><td>multipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集（需要兼容驱动）。</td><td>true,false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td>true,false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</td><td>true,false</td><td>False</td></tr><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td>SIMPLE REUSE BATCH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数。</td><td>Any positive integer</td><td>Not Set (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td>允许在嵌套语句中使用分页（RowBounds）。</td><td>true,false</td><td>False</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td>true, false</td><td>False</td></tr><tr><td>localCacheScope</td><td>MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td>SESSION,STATEMENT</td><td>SESSION</td></tr><tr><td>jdbcTypeForNull</td><td>当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td><td>JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td><td>OTHER</td></tr><tr><td>lazyLoadTriggerMethods</td><td>指定哪个对象的方法触发一次延迟加载。</td><td>A method name list separated by commas</td><td>equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td>指定动态 SQL 生成的默认语言。</td><td>A type alias or fully qualified class name.</td><td>org.<br>apache<br>.ibatis.<br>scripting.<br>xmltags.<br>XMLDynamicLanguageDriver</td></tr><tr><td>callSettersOnNulls</td><td>指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</td><td>true,false</td><td>false</td></tr><tr><td>logPrefix</td><td>指定 MyBatis 增加到日志名称的前缀。</td><td>Any String</td><td>Not set</td></tr><tr><td>logImpl</td><td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td>SLF4J<br>,LOG4J<br>,LOG4J2,<br>JDK_LOGGING,<br>COMMONS_LOGGING,<br>STDOUT_LOGGING,<br>NO_LOGGING</td><td>Not set</td></tr><tr><td>proxyFactory<br><br></td><td>指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</td><td>CGLIB JAVASSIST</td><td>CGLIB<br><br></td></tr><tr><td>vfslmpl<br><br></td><td>指定 VFS 的实现</td><td>自定义 VFS 的实现的类全限定名，以逗号分隔。</td><td>no set<br><br></td></tr><tr><td>useActualParamName<br><br></td><td>允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）</td><td>true \</td><td>false</td></tr><tr><td>configurationFactory<br><br></td><td>指定一个提供 <code>Configuration</code> 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）</td><td>类型别名或者全类名.</td><td>no set</td></tr></tbody></table><p>一个配置完整的 settings 元素的示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipleResultSetsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useColumnLabel&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SIMPLE&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatementTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;safeRowBoundsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OTHER&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何配置类型别名？"><a href="#如何配置类型别名？" class="headerlink" title="如何配置类型别名？"></a>如何配置类型别名？</h3><p>类型别名是为 Java 类型设置一个短的名字,存在的意义仅在于用来减少类完全限定名的冗余。例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Author&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Blog&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Blog&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Comment&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Comment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Post&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Section&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Section&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Tag&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;domain.blog.Tag&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code>可以用在任何使用<code>domain.blog.Blog</code>的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;domain.blog&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;author&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Author</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三种数据源类型的区别？"><a href="#三种数据源类型的区别？" class="headerlink" title="三种数据源类型的区别？"></a>三种数据源类型的区别？</h3><p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。</p><p><strong>POOLED</strong>– 这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p><p><strong>JNDI</strong>– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p><h3 id="如何指定映射文件？"><a href="#如何指定映射文件？" class="headerlink" title="如何指定映射文件？"></a>如何指定映射文件？</h3><p>最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用相对类路径定义资源 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- 使用完全限定资源定位符 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- 使用包名+类名 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- 注册包内所有mapper --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br></code></pre></td></tr></table></figure><h3 id="select与属性的用法？"><a href="#select与属性的用法？" class="headerlink" title="select与属性的用法？"></a>select与属性的用法？</h3><p>简单查询的 select 元素是非常简单的。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span>&gt;</span><br>  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">id：查询的名称</span><br><span class="hljs-comment">parameterType：参数类型</span><br><span class="hljs-comment">resultType：返回值类型</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>select 元素有很多属性允许你配置，来决定每条语句的作用细节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span><br><span class="hljs-tag"> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">&quot;deprecated&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;personResultMap&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10000&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">fetchSize</span>=<span class="hljs-string">&quot;256&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">resultSetType</span>=<span class="hljs-string">&quot;FORWARD_ONLY&quot;</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>属性的含义：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr><tr><td>resultType</td><td>从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td>resultMap</td><td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td>flushCache</td><td>将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</td></tr><tr><td>useCache</td><td>将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td></tr><tr><td>fetchSize</td><td>这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</td></tr><tr><td>databaseId</td><td>如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr><tr><td>resultOrdered</td><td>这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td></tr><tr><td>resultSets</td><td>这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</td></tr></tbody></table><h3 id="insert、update、delete的用法？"><a href="#insert、update、delete的用法？" class="headerlink" title="insert、update、delete的用法？"></a>insert、update、delete的用法？</h3><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Insert, Update 和 Delete 的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>命名空间中的唯一标识符，可被用来代表这条语句。</td></tr><tr><td>parameterType</td><td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr><tr><td>flushCache</td><td>将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>databaseId</td><td>如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><p>下面就是 insert，update 和 delete 语句的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  insert into Author (id,username,password,email,bio)<br>  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span>&gt;</span><br>  update Author set<br>    username = #&#123;username&#125;,<br>    password = #&#123;password&#125;,<br>    email = #&#123;email&#125;,<br>    bio = #&#123;bio&#125;<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span>&gt;</span><br>  delete from Author where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="两种字符串替换的区别？"><a href="#两种字符串替换的区别？" class="headerlink" title="两种字符串替换的区别？"></a>两种字符串替换的区别？</h3><table><thead><tr><th>#{}</th><th>${}</th></tr></thead><tbody><tr><td>参数占位符，即预编译</td><td>字符串替换符，即SQL拼接</td></tr><tr><td>很大程度上能防止sql 注入</td><td>不能防止sql 注入</td></tr><tr><td>将传入的数据都当成一个字符串，会对传入的变量自动加一个单引号</td><td>将传入的参数直接显示生成在sql中，且不加任何引号</td></tr><tr><td></td><td>排序时使用order by 动态参数时需要注意，用$而不是#</td></tr></tbody></table><h3 id="三种自动映射等级？"><a href="#三种自动映射等级？" class="headerlink" title="三种自动映射等级？"></a>三种自动映射等级？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>NONE 表示取消自动映射</p><p>PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集</p><p>FULL 会自动映射任意复杂的结果集（无论是否嵌套）</p><h3 id="if标签的作用？"><a href="#if标签的作用？" class="headerlink" title="if标签的作用？"></a>if标签的作用？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogWithTitleLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG <br>  WHERE state = ‘ACTIVE’ <br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--      如果test为true则语句包含if内的内容--&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="foreach标签的用法？"><a href="#foreach标签的用法？" class="headerlink" title="foreach标签的用法？"></a>foreach标签的用法？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>  SELECT *<br>  FROM POST P<br>  WHERE ID in<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;item&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--        foreach 允许你指定一个集合，声明可以用在元素体内的集合项和索引变量--&gt;</span><br><span class="hljs-comment">&lt;!--        也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="怎么配置日志级别？"><a href="#怎么配置日志级别？" class="headerlink" title="怎么配置日志级别？"></a>怎么配置日志级别？</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 全局日志等级</span><br><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">ERROR, stdout</span><br><span class="hljs-comment"># mabatis mapper日志等级</span><br><span class="hljs-attr">log4j.logger.org.mybatis.example.BlogMapper</span>=<span class="hljs-string">TRACE</span><br></code></pre></td></tr></table></figure><h3 id="一级缓存和二级缓存的定义与区别？"><a href="#一级缓存和二级缓存的定义与区别？" class="headerlink" title="一级缓存和二级缓存的定义与区别？"></a>一级缓存和二级缓存的定义与区别？</h3><ul><li>一级缓存<ul><li>定义<ul><li>一级缓存作用域是sqlsession级别的，同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。</li><li>一级缓存是基于 PerpetualCache 的 HashMap 本地缓存，默认打开一级缓存。</li></ul></li><li>清空一级缓存<ul><li>如果中间sqlSession去执行commit操作（执行插入、更新、删除），则会清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</li><li>一级缓存时执行commit，close，增删改等操作，就会清空当前的一级缓存；当对SqlSession执行更新操作（update、delete、insert）后并执行commit时，不仅清空其自身的一级缓存（执行更新操作的效果），也清空二级缓存（执行commit()的效果）。</li></ul></li><li>一级缓存无过期时间，只有生命周期</li></ul></li><li>二级缓存<ul><li>简介<ul><li>它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</li><li>二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 、</li></ul></li><li>何时存入<ul><li>在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。</li><li>开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中。</li></ul></li><li>二级缓存有过期时间，但没有后台线程进行检测<ul><li>需要注意的是，并不是key-value的过期时间，而是这个cache的过期时间，是flushInterval，意味着整个清空缓存cache，所以不需要后台线程去定时检测。</li><li>每当存取数据的时候，都要检测一下cache的生命时间，默认是1小时，如果这个cache存活了一个小时，那么将整个清空一下。</li></ul></li><li>当 Mybatis 调用 Dao 层查询数据库时，先查询二级缓存，二级缓存中无对应数据，再去查询一级缓存，一级缓存中也没有，最后去数据库查找。</li></ul></li></ul><h3 id="useCache与flushCache的作用？"><a href="#useCache与flushCache的作用？" class="headerlink" title="useCache与flushCache的作用？"></a>useCache与flushCache的作用？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br><span class="hljs-comment">&lt;!--useCache:将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。--&gt;</span><br><span class="hljs-comment">&lt;!--flushCache：将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Redis的概念？"><a href="#Redis的概念？" class="headerlink" title="Redis的概念？"></a>Redis的概念？</h3><p>Redis 是一个高性能的key-value数据库。经常用作缓存</p><h3 id="那个注解是对dao组件的修饰？"><a href="#那个注解是对dao组件的修饰？" class="headerlink" title="那个注解是对dao组件的修饰？"></a>那个注解是对dao组件的修饰？</h3><p><mark>to_do</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span> <span class="hljs-comment">//Mybatis 需要找到对应的 mapper，在编译的时候动态生成代理类</span><br><span class="hljs-meta">@Repository</span> <span class="hljs-comment">//用于标注数据访问组件，即DAO组件</span><br></code></pre></td></tr></table></figure><h3 id="JavaModelGenerator配置、sqlMapperGenerator配置与JavaClientGenerator配置的作用？"><a href="#JavaModelGenerator配置、sqlMapperGenerator配置与JavaClientGenerator配置的作用？" class="headerlink" title="JavaModelGenerator配置、sqlMapperGenerator配置与JavaClientGenerator配置的作用？"></a>JavaModelGenerator配置、sqlMapperGenerator配置与JavaClientGenerator配置的作用？</h3><p><mark>to_do</mark></p><h3 id="如何实现分页？"><a href="#如何实现分页？" class="headerlink" title="如何实现分页？"></a>如何实现分页？</h3><p>导入依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#pagehelper配置</span><br><span class="hljs-attr">pagehelper.helper-dialect</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">pagehelper.reasonable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">pagehelper.support-methods-arguments</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">pagehelper.params</span>=<span class="hljs-string">count=countSql</span><br></code></pre></td></tr></table></figure><p>使用<br><mark>to_do</mark></p><h3 id="分页最后封装成什么数据？"><a href="#分页最后封装成什么数据？" class="headerlink" title="分页最后封装成什么数据？"></a>分页最后封装成什么数据？</h3><p><mark>to_do</mark></p><h2 id="spring-Framework-40问"><a href="#spring-Framework-40问" class="headerlink" title="spring Framework 40问"></a>spring Framework 40问</h2><h3 id="依赖注入的概念？"><a href="#依赖注入的概念？" class="headerlink" title="依赖注入的概念？"></a>依赖注入的概念？</h3><p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系.</p><p>控制反转核心思想就是由 Spring 负责对象的创建。DI是IOC的一种。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p><h3 id="springCoreContainer是什么？"><a href="#springCoreContainer是什么？" class="headerlink" title="springCoreContainer是什么？"></a>springCoreContainer是什么？</h3><p><img src="core_container.png" srcset="/img/loading.gif" lazyload alt="img.png"></p><ul><li>Core：核心工具包，包括字节码操作cglib、asm，资源的抽象Resource，对象实例化化工具等等。</li><li>Beans：Bean 的定义、Bean 的创建以及对 Bean 的解析。</li><li>Context：Context模块建立在Core和Beans模块之上，是Bean运行环境（即保存维护Bean的状态、数据，Bean之间的关系），又称之为Ioc容器。</li><li>SpEL：提供了一个强大的表达式语言，可以在运行时查询和操作对象。</li></ul><h3 id="springIoC容器的类型？"><a href="#springIoC容器的类型？" class="headerlink" title="springIoC容器的类型？"></a>springIoC容器的类型？</h3><p><mark>to_do</mark></p><h3 id="ApplicationContext容器的实现有哪些？"><a href="#ApplicationContext容器的实现有哪些？" class="headerlink" title="ApplicationContext容器的实现有哪些？"></a>ApplicationContext容器的实现有哪些？</h3><p>ApplicationContext 有两个直接子接口：WebApplicationContext 和 ConfigurableApplicationContext。</p><p>ConfigurableApplicationContext：扩展于ApplicationContext, 新增加两个主要方法。refresh()和close()，让ApplicationContext具有启动、刷新和关闭上下文的能力。ApplicationContext在初始化上下文时就实例化所有的单例Bean.</p><p>WebApplicationContext：WebApplicationContext是专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作。</p><p>最常用的两个实现类：</p><p>ClassPathXmlApplicationContext : 从类路径下加载配置文件。</p><p>FileSystemXmlApplicationContext : 从文件系统中加载配置文件。</p><p>两个都是继承ConfigurableApplicationContext</p><h3 id="bean标记的使用？"><a href="#bean标记的使用？" class="headerlink" title="bean标记的使用？"></a>bean标记的使用？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Bean 唯一标志符&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;包名+类名&quot;</span> <span class="hljs-attr">p:普通属性</span>=<span class="hljs-string">&quot;普通属性值&quot;</span> <span class="hljs-attr">p:对象属性-ref</span>=<span class="hljs-string">&quot;对象的引用&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring 框架提供了 2 种短命名空间，可以简化 Spring 的 XML 配置，如下表。</p><table><thead><tr><th>短命名空间</th><th>简化的 XML 配置</th><th>说明</th></tr></thead><tbody><tr><td>p 命名空间</td><td><bean>元素中嵌套的<property>元素</property></bean></td><td>是 setter 方式属性注入的一种快捷实现方式</td></tr><tr><td>c 命名空间</td><td><bean>元素中嵌套的<constructor>元素</constructor></bean></td><td>是构造函数属性注入的一种快捷实现方式</td></tr></tbody></table><h3 id="bean的范围有哪些？"><a href="#bean的范围有哪些？" class="headerlink" title="bean的范围有哪些？"></a>bean的范围有哪些？</h3><p>Spring 5 共提供了 6 种 scope 作用域，如下表。</p><table><thead><tr><th>作用范围</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例</td></tr><tr><td>prototype</td><td>原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。</td></tr><tr><td>request</td><td>每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。</td></tr><tr><td>session</td><td>同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。</td></tr><tr><td>application</td><td>同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 与 singleton 类似，但 singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而一个 Web 应用中可能会存在多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。</td></tr><tr><td>websocket</td><td>websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。</td></tr></tbody></table><h3 id="如何获取bean？"><a href="#如何获取bean？" class="headerlink" title="如何获取bean？"></a>如何获取bean？</h3><ol><li>在初始化时保存ApplicationContext对象</li><li>通过Spring提供的utils类获取ApplicationContext对象</li><li>继承自抽象类ApplicationObjectSupport</li><li>继承自抽象类WebApplicationObjectSupport</li><li>实现接口ApplicationContextAware</li><li>通过Spring提供的ContextLoader</li></ol><h3 id="bean的生命周期和生命周期方法？"><a href="#bean的生命周期和生命周期方法？" class="headerlink" title="bean的生命周期和生命周期方法？"></a>bean的生命周期和生命周期方法？</h3><p>在传统的 Java 应用中，Bean 的生命周期很简单，使用 Java 关键字 new 进行 Bean 的实例化后，这个 Bean 就可以使用了。一旦这个 Bean 长期不被使用，Java 自动进行垃圾回收。</p><p>相比之下，Spring 中 Bean 的生命周期较复杂，大致可以分为以下 5 个阶段：</p><ol><li>Bean 的实例化</li><li>Bean 属性赋值</li><li>Bean 的初始化</li><li>Bean 的使用</li><li>Bean 的销毁</li></ol><p>Spring 根据 Bean 的作用域来选择 Bean 的管理方式，</p><ul><li>对于 singleton 作用域的 Bean 来说，Spring IoC 容器能够精确地控制 Bean 何时被创建、何时初始化完成以及何时被销毁；</li><li>对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，然后就将 Bean 的实例交给客户端代码管理，Spring IoC 容器将不再跟踪其生命周期。</li></ul><p><img src="http://c.biancheng.net/uploads/allimg/220119/1F32KG1-0.png" srcset="/img/loading.gif" lazyload alt="Spring 生命周期流程"></p><p>Bean 的生命周期回调方法主要有两种：</p><ul><li>初始化回调方法：在 Spring Bean 被初始化后调用，执行一些自定义的回调操作。</li><li>销毁回调方法：在 Spring Bean 被销毁前调用，执行一些自定义的回调操作。</li></ul><p><strong>通过接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//in bean class</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   System.out<br>           .println(<span class="hljs-string">&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 这是DiposibleBean接口方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   System.out.println(<span class="hljs-string">&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过XML配置实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//in bean class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myInit</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myDestory</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;springBeanTest.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestory&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">p:address</span>=<span class="hljs-string">&quot;广州&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">p:phone</span>=<span class="hljs-string">&quot;15900000000&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>通过注解实现</strong></p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@PostConstruct</td><td>指定初始化回调方法，这个方法会在 Spring Bean 被初始化后被调用，执行一些自定义的回调操作。</td></tr><tr><td>@PreDestroy</td><td>指定销毁回调方法，这个方法会在 Spring Bean 被销毁前被调用，执行一些自定义的回调操作。</td></tr></tbody></table><p><strong>通过后置处理器实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;   <br>    Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException;   <br>    Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种显式装配？"><a href="#两种显式装配？" class="headerlink" title="两种显式装配？"></a>两种显式装配？</h3><p><mark>to_do</mark></p><h3 id="value和ref的区别？"><a href="#value和ref的区别？" class="headerlink" title="value和ref的区别？"></a>value和ref的区别？</h3><p>value用于注入字面量属性，ref用于注入引用属性</p><h3 id="如何注入集合？"><a href="#如何注入集合？" class="headerlink" title="如何注入集合？"></a>如何注入集合？</h3><p>标签说明<list>用于注入 list 类型的值，允许重复<set>用于注入 set 类型的值，不允许重复<map>用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型<props>用于注入 key-value 的集合，其中 key 和 value 都是字符串类型</props></map></set></list></p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;list&gt;</code></td><td>用于注入 list 类型的值，允许重复</td></tr><tr><td><code>&lt;set&gt;</code></td><td>用于注入 set 类型的值，不允许重复</td></tr><tr><td><code>&lt;map&gt;</code></td><td>用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型</td></tr><tr><td><code>&lt;props&gt;</code></td><td>用于注入 key-value 的集合，其中 key 和 value 都是字符串类型</td></tr></tbody></table><h3 id="构造函数注入？"><a href="#构造函数注入？" class="headerlink" title="构造函数注入？"></a>构造函数注入？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bean名&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;类&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;属性名&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;值&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;属性名&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;引用&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或使用c:命名空间</p><h3 id="parent属性的作用？"><a href="#parent属性的作用？" class="headerlink" title="parent属性的作用？"></a>parent属性的作用？</h3><p>在 Spring XML 配置中，我们通过子 Bean 的 parent 属性来指定需要继承的父 Bean，配置格式如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--父Bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parentBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.xxxx.xxx.ParentBean&quot;</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><span class="hljs-comment">&lt;!--子Bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;childBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.xxx.xxx.ChildBean&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;parentBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何使用工厂方法实现DI？"><a href="#如何使用工厂方法实现DI？" class="headerlink" title="如何使用工厂方法实现DI？"></a>如何使用工厂方法实现DI？</h3><p><mark>to_do</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.execise.factory;<br><br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    这是专门用来创建对象的工厂类</span><br><span class="hljs-comment">        1. 使用静态代码块来读取beans.properties</span><br><span class="hljs-comment">        2. 提供一个静态方法，供外面的人调用获取对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    <span class="hljs-keyword">static</span> Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String , String&gt;();<br>    <span class="hljs-comment">//1. 在这里读取beans.properties文件</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//1. 读取外部的properties文件，只要写名字即可</span><br>        <span class="hljs-type">ResourceBundle</span> <span class="hljs-variable">resourceBundle</span> <span class="hljs-operator">=</span> ResourceBundle.getBundle(<span class="hljs-string">&quot;beans&quot;</span>);<br>        <span class="hljs-comment">//2. 读取里面的内容</span><br>        Enumeration&lt;String&gt; keys = resourceBundle.getKeys();<br>        <span class="hljs-comment">//3. 遍历每一个key value</span><br>        <span class="hljs-keyword">while</span>(keys.hasMoreElements())&#123;<br>            <span class="hljs-comment">//4. 取出每一个key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keys.nextElement();<br>            <span class="hljs-comment">//5. 得到每一个value</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resourceBundle.getString(key);<br>            <span class="hljs-comment">//6. 把key和value保存到map集合</span><br>            map.put(key , value );<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 从map集合里面获取全路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> map.get(name);<br>        <span class="hljs-comment">//2. 判定</span><br>        <span class="hljs-keyword">if</span>(className != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Class.forName(className).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="自动装配的模式有哪些？"><a href="#自动装配的模式有哪些？" class="headerlink" title="自动装配的模式有哪些？"></a>自动装配的模式有哪些？</h3><p>Spring 共提供了 5 中自动装配规则，它们分别与 autowire 属性的 5 个取值对应，具体说明如下表。</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>byName</td><td>按名称自动装配。 Spring 会根据的 Java 类中对象属性的名称，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 id 或 name 属性值与这个对象属性的名称相同，则获取这个 Bean，并与当前的 Java 类 Bean 建立关联关系。</td></tr><tr><td>byType</td><td>按类型自动装配。 Spring 会根据 Java 类中的对象属性的类型，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 class 属性值与这个对象属性的类型相匹配，则获取这个 Bean，并与当前的 Java 类的 Bean 建立关联关系。</td></tr><tr><td>constructor</td><td>与 byType 模式相似，不同之处在与它应用于构造器参数（依赖项），如果在容器中没有找到与构造器参数类型一致的 Bean，那么将抛出异常。 其实就是根据构造器参数的数据类型，进行 byType 模式的自动装配。</td></tr><tr><td>default</td><td>表示默认采用上一级元素<beans>设置的自动装配规则（default-autowire）进行装配。</beans></td></tr><tr><td>no</td><td>默认值，表示不使用自动装配，Bean 的依赖关系必须通过<constructor-arg>和<property>元素的 ref 属性来定义。</property></constructor-arg></td></tr></tbody></table><p><strong>基于注解的自动装配</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启组件扫描--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br></code></pre></td></tr></table></figure><h3 id="显式装配与自动装配的关系？"><a href="#显式装配与自动装配的关系？" class="headerlink" title="显式装配与自动装配的关系？"></a>显式装配与自动装配的关系？</h3><p>显式装配是在 XML 配置中通过<constructor-arg>和<property>中的 ref 属性，手动维护 Bean 与 Bean 之间的依赖关系的。</property></constructor-arg></p><p>Spring 的自动装配功能可以让 Spring 容器依据某种规则（自动装配的规则，有五种），为指定的 Bean 从应用的上下文（AppplicationContext 容器）中查找它所依赖的 Bean，并自动建立 Bean 之间的依赖关系。而这一过程是在完全不使用任何<constructor-arg>和<property>元素 ref 属性的情况下进行的。</property></constructor-arg></p><h3 id="依赖注入使用哪些注解？"><a href="#依赖注入使用哪些注解？" class="headerlink" title="依赖注入使用哪些注解？"></a>依赖注入使用哪些注解？</h3><p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table><p>我们可以通过以下注解将定义好 Bean 装配到其它的 Bean 中。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Autowired</td><td>可以应用到 Bean 的属性变量、setter 方法、非 setter 方法及构造函数等，默认按照 Bean 的类型进行装配。 @Autowired 注解默认按照 Bean 的类型进行装配，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合 @Qualifier 注解一起使用</td></tr><tr><td>@Resource</td><td>作用与 Autowired 相同，区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 的名称进行装配。 @Resource 中有两个重要属性：name 和 type。 Spring 将 name 属性解析为 Bean 的实例名称，type 属性解析为 Bean 的实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配；如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</td></tr><tr><td>@Qualifier</td><td>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</td></tr></tbody></table><h3 id="Configuration和-Bean注解的作用"><a href="#Configuration和-Bean注解的作用" class="headerlink" title="@Configuration和@Bean注解的作用"></a>@Configuration和@Bean注解的作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@Configration 注解作用在类、接口（包含注解）上</span><br><span class="hljs-comment">@Configuration 用于定义配置类，可替换 xml 配置文件</span><br><span class="hljs-comment">@Configration 注解类中可以声明一个或多个 @Bean 方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    @Bean 注解作用在方法上</span><br><span class="hljs-comment">    @Bean 指示一个方法返回一个 Spring 容器管理的 Bean，也就是说方法返回值就是给Springr容器装配的bean</span><br><span class="hljs-comment">    @Bean 一般和 @Component 或者 @Configuration 一起使用，也可以在 @Service 里使用，没有特定要求，主要看项目的需求。</span><br><span class="hljs-comment">    @Bean 注解默认作用域为单例 singleton 作用域，可通过 @Scope(“prototype”) 设置为原型作用域</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>  &#125;<br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean1</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h3><p>AOP 的全称是“Aspect Oriented Programming”，译为“面向切面编程”，和 OOP（面向对象编程）类似，它也是一种编程思想。</p><h3 id="通知的概念？"><a href="#通知的概念？" class="headerlink" title="通知的概念？"></a>通知的概念？</h3><p>AOP的一套术语</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Joinpoint（连接点）</td><td>AOP 的核心概念，指的是程序执行期间明确定义的一个点，例如方法的调用、类初始化、对象实例化等。 在 Spring 中，连接点则指可以被动态代理拦截目标类的方法。</td></tr><tr><td>Pointcut（切入点）</td><td>又称切点，指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。</td></tr><tr><td>Advice（通知）</td><td>指拦截到 Joinpoint 之后要执行的代码，即对切入点增强的内容。</td></tr><tr><td>Target（目标）</td><td>指代理的目标对象，通常也被称为被通知（advised）对象。</td></tr><tr><td>Weaving（织入）</td><td>指把增强代码应用到目标对象上，生成代理对象的过程。</td></tr><tr><td>Proxy（代理）</td><td>指生成的代理对象。</td></tr><tr><td>Aspect（切面）</td><td>切面是切入点（Pointcut）和通知（Advice）的结合。</td></tr></tbody></table><h3 id="连接点的概念？"><a href="#连接点的概念？" class="headerlink" title="连接点的概念？"></a>连接点的概念？</h3><p>见上条</p><h3 id="通知的类型（位置）？"><a href="#通知的类型（位置）？" class="headerlink" title="通知的类型（位置）？"></a>通知的类型（位置）？</h3><p>共有5种：</p><table><thead><tr><th>通知</th><th>说明</th></tr></thead><tbody><tr><td>before（前置通知）</td><td>通知方法在目标方法调用之前执行</td></tr><tr><td>after（后置通知）</td><td>通知方法在目标方法返回或异常后调用</td></tr><tr><td>after-returning（返回后通知）</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>after-throwing（抛出异常通知）</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>around（环绕通知）</td><td>通知方法会将目标方法封装起来</td></tr></tbody></table><h3 id="用来创建通知的注解有哪些？"><a href="#用来创建通知的注解有哪些？" class="headerlink" title="用来创建通知的注解有哪些？"></a>用来创建通知的注解有哪些？</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面。</td></tr><tr><td>@Pointcut</td><td>用于定义一个切入点。</td></tr><tr><td>@Before</td><td>用于定义前置通知，相当于 BeforeAdvice。</td></tr><tr><td>@AfterReturning</td><td>用于定义后置通知，相当于 AfterReturningAdvice。</td></tr><tr><td>@Around</td><td>用于定义环绕通知，相当于 MethodInterceptor。</td></tr><tr><td>@AfterThrowing</td><td>用于定义抛出通知，相当于 ThrowAdvice。</td></tr><tr><td>@After</td><td>用于定义最终通知，不管是否异常，该通知都会执行。</td></tr><tr><td>@DeclareParents</td><td>用于定义引介通知，相当于 IntroductionInterceptor（不要求掌握）。</td></tr></tbody></table><h3 id="如何声明切入点？"><a href="#如何声明切入点？" class="headerlink" title="如何声明切入点？"></a>如何声明切入点？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Pointcut表示式</span><br><span class="hljs-comment">//我除了可以通过切入点表达式（execution）直接对切点进行定义外</span><br><span class="hljs-comment">//还可以通过切入点方法的名称来引用其他的切入点</span><br><span class="hljs-comment">//在使用方法名引用其他切入点时，还可以使用“&amp;&amp;”、“||”和“!”等表示“与”、“或”、“非”的含义</span><br><span class="hljs-meta">@Pointcut(&quot;execution(* com.savage.aop.MessageSender.*(..))&quot;)</span><br><span class="hljs-comment">//定义为切点的方法，它的返回值类型必须为 void</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="在返回后通知中如何获取目标方法的返回值？"><a href="#在返回后通知中如何获取目标方法的返回值？" class="headerlink" title="在返回后通知中如何获取目标方法的返回值？"></a>在返回后通知中如何获取目标方法的返回值？</h3><p><mark>to_do</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object ret)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterReturning advice ...&quot;</span>+ret);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="XML如何配置AOP？"><a href="#XML如何配置AOP？" class="headerlink" title="XML如何配置AOP？"></a>XML如何配置AOP？</h3><p><mark>to_do</mark></p><p>在 Spring 的 XML 配置文件中，添加以下内容启用 @AspectJ 注解支持。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启注解扫描 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--开启AspectJ 自动代理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JDBC-Template的CRUD操作有哪些？"><a href="#JDBC-Template的CRUD操作有哪些？" class="headerlink" title="JDBC Template的CRUD操作有哪些？"></a>JDBC Template的CRUD操作有哪些？</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public int update(String sql)</td><td>用于执行新增、更新、删除等语句；sql：需要执行的 SQL 语句；args 表示需要传入到 SQL 语句中的参数。</td></tr><tr><td>public int update(String sql,Object… args)</td><td></td></tr><tr><td>public void execute(String sql)</td><td>可以执行任意 SQL，一般用于执行 DDL 语句； sql：需要执行的 SQL 语句；action 表示执行完 SQL 语句后，要调用的函数。</td></tr><tr><td>public T execute(String sql, PreparedStatementCallback action)</td><td></td></tr><tr><td>public<t>List<t>query(String sql, RowMapper<t>rowMapper, @Nullable Object… args)</t></t></t></td><td>用于执行查询语句；sql：需要执行的 SQL 语句；rowMapper：用于确定返回的集合（List）的类型；args：表示需要传入到 SQL 语句的参数。</td></tr><tr><td>public<t>T queryForObject(String sql, RowMapper<t>rowMapper, @Nullable Object… args)</t></t></td><td></td></tr><tr><td>public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)</td><td>用于批量执行新增、更新、删除等语句； sql：需要执行的 SQL 语句；argTypes：需要注入的 SQL 参数的 JDBC 类型；batchArgs：表示需要传入到 SQL 语句的参数。</td></tr></tbody></table><h3 id="如何创建处理全局异常？"><a href="#如何创建处理全局异常？" class="headerlink" title="如何创建处理全局异常？"></a>如何创建处理全局异常？</h3><p><mark>to_do</mark></p><h3 id="JDBC-Template-和-NamedParameterJDBCTemplate的区别"><a href="#JDBC-Template-和-NamedParameterJDBCTemplate的区别" class="headerlink" title="JDBC Template 和 NamedParameterJDBCTemplate的区别"></a>JDBC Template 和 NamedParameterJDBCTemplate的区别</h3><p><mark>to_do</mark></p><h3 id="事务的特征？"><a href="#事务的特征？" class="headerlink" title="事务的特征？"></a>事务的特征？</h3><p>事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。</p><ul><li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li><li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li><li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li><li>持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li></ul><h3 id="事务的传播行为？"><a href="#事务的传播行为？" class="headerlink" title="事务的传播行为？"></a>事务的传播行为？</h3><p>事务传播行为（propagation behavior）指的是，当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。<br>Spring 提供了以下 7 种不同的事务传播行为。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_MANDATORY</td><td>支持当前事务，如果不存在当前事务，则引发异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前事务存在，则在嵌套事务中执行。</td></tr><tr><td>PROPAGATION_NEVER</td><td>不支持当前事务，如果当前事务存在，则引发异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>不支持当前事务，始终以非事务方式执行。</td></tr><tr><td>PROPAGATION_REQUIRED</td><td>默认传播行为，如果存在当前事务，则当前方法就在当前事务中运行，如果不存在，则创建一个新的事务，并在这个新建的事务中运行。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>创建新事务，如果已经存在事务则暂停当前事务。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果不存在事务，则以非事务方式执行。</td></tr></tbody></table><h3 id="事务并发可能导致的问题？"><a href="#事务并发可能导致的问题？" class="headerlink" title="事务并发可能导致的问题？"></a>事务并发可能导致的问题？</h3><p>事务的隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>在实际应用中，经常会出现多个事务同时对同一数据执行不同操作，来实现各自的任务的情况。此时就有可能导致脏读、幻读以及不可重复读等问题的出现。</p><p>在理想情况下，事务之间是完全隔离的，这自然不会出现上述问题。但完全的事务隔离会导致性能问题，而且并不是所有的应用都需要事务的完全隔离，因此有时应用程序在事务隔离上也有一定的灵活性。</p><p>Spring 中提供了以下隔离级别，我们可以根据自身的需求自行选择合适的隔离级别。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的更改，可能导致脏读、幻读和不可重复读</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>Oracle 默认级别，允许读取已提交的并发事务，防止脏读，可能出现幻读和不可重复读</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>MySQL 默认级别，多次读取相同字段的结果是一致的，防止脏读和不可重复读，可能出现幻读</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>完全服从 ACID 的隔离级别，防止脏读、不可重复读和幻读</td></tr></tbody></table><h3 id="回滚规则的作用？"><a href="#回滚规则的作用？" class="headerlink" title="回滚规则的作用？"></a>回滚规则的作用？</h3><p><mark>to_do</mark></p><h3 id="PlatformTransactionManager接口的作用？"><a href="#PlatformTransactionManager接口的作用？" class="headerlink" title="PlatformTransactionManager接口的作用？"></a>PlatformTransactionManager接口的作用？</h3><p>Spring 并不会直接管理事务，而是通过事务管理器对事务进行管理的。</p><p>在 Spring 中提供了一个 org.springframework.transaction.PlatformTransactionManager 接口，这个接口被称为 Spring 的事务管理器，其源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口中各方法说明如下：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus getTransaction(TransactionDefinition definition)</td><td>用于获取事务的状态信息</td></tr><tr><td>void commit(TransactionStatus status)</td><td>用于提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>用于回滚事务</td></tr></tbody></table><p>Spring 为不同的持久化框架或平台（例如 JDBC、Hibernate、JPA 以及 JTA 等）提供了不同的 PlatformTransactionManager 接口实现，这些实现类被称为事务管理器实现。</p><table><thead><tr><th>实现类</th><th>说明</th></tr></thead><tbody><tr><td>org.springframework.<br>jdbc.datasource.<br>DataSourceTransactionManager</td><td>使用 Spring JDBC 或 iBatis 进行持久化数据时使用。</td></tr><tr><td>org.springframework.<br>orm.hibernate3.<br>HibernateTransactionManager</td><td>使用 Hibernate 3.0 及以上版本进行持久化数据时使用。</td></tr><tr><td>org.springframework<br>.orm.jpa.<br>JpaTransactionManager</td><td>使用 JPA 进行持久化时使用。</td></tr><tr><td>org.springframework<br>.jdo.<br>JdoTransactionManager</td><td>当持久化机制是 Jdo 时使用。</td></tr><tr><td>org.springframework.<br>transaction.<br>jta.JtaTransactionManager</td><td>使用 JTA 来实现事务管理，在一个事务跨越多个不同的资源（即分布式事务）使用该实现。</td></tr></tbody></table><p>这些事务管理器的使用方式十分简单，我们只要根据持久化框架（或平台）选用相应的事务管理器实现，即可实现对事物的管理，而不必关心实际事务实现到底是什么。</p><h3 id="如何使用XML配置事务？"><a href="#如何使用XML配置事务？" class="headerlink" title="如何使用XML配置事务？"></a>如何使用XML配置事务？</h3><h4 id="1-引入-tx-命名空间"><a href="#1-引入-tx-命名空间" class="headerlink" title="1. 引入 tx 命名空间"></a>1. 引入 tx 命名空间</h4><p>Spring 提供了一个 tx 命名空间，借助它可以极大地简化 Spring 中的声明式事务的配置。</p><p>想要使用 tx 命名空间，第一步就是要在 XML 配置文件中添加 tx 命名空间的约束。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span>    <br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>由于 Spring 提供的声明式事务管理是依赖于 Spring AOP 实现的，因此我们在 XML 配置文件中还应该添加与 aop 命名空间相关的配置。</p></blockquote><h4 id="2-配置事务管理器"><a href="#2-配置事务管理器" class="headerlink" title="2. 配置事务管理器"></a>2. 配置事务管理器</h4><p>接下来，我们就需要借助数据源配置，定义相应的事务管理器实现（PlatformTransactionManager 接口的实现类）的 Bean，配置内容如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库连接地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库的用户名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库的密码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置事务管理器，以 JDBC 为例--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在以上配置中，配置的事务管理器实现为 DataSourceTransactionManager，即为 JDBC 和 iBatis 提供的 PlatformTransactionManager 接口实现。</p><h4 id="3-配置事务通知"><a href="#3-配置事务通知" class="headerlink" title="3. 配置事务通知"></a>3. 配置事务通知</h4><p>在 Spring 的 XML 配置文件中配置事务通知，指定事务作用的方法以及所需的事务属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置事务参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="事务管理器配置"><a href="#事务管理器配置" class="headerlink" title="事务管理器配置"></a>事务管理器配置</h5><p>当我们使用 <a href="tx:advice">tx:advice</a> 来声明事务时，需要通过 transaction-manager 参数来定义一个事务管理器，这个参数的取值默认为 transactionManager。</p><p>如果我们自己设置的事务管理器（第 2 步中设置的事务管理器 id）恰好与默认值相同，则可以省略对改参数的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span> &gt;</span><br>    <span class="hljs-comment">&lt;!--配置事务参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但如果我们自己设置的事务管理器 id 与默认值不同，则必须手动在 <a href="tx:advice">tx:advice</a> 元素中通过 transaction-manager 参数指定。</p><h5 id="事务属性配置"><a href="#事务属性配置" class="headerlink" title="事务属性配置"></a>事务属性配置</h5><p>对于<a href="tx:advice">tx:advice</a> 来说，事务属性是被定义在<a href="tx:attributes">tx:attributes</a> 中的，该元素可以包含一个或多个 <a href="tx:method">tx:method</a> 元素。</p><p><a href="tx:method">tx:method</a> 元素包含多个属性参数，可以为某个或某些指定的方法（name 属性定义的方法）定义事务属性，如下表所示。</p><table><thead><tr><th>事务属性</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>指定事务的传播行为。</td></tr><tr><td>isolation</td><td>指定事务的隔离级别。</td></tr><tr><td>read-only</td><td>指定是否为只读事务。</td></tr><tr><td>timeout</td><td>表示超时时间，单位为“秒”；声明的事务在指定的超时时间后，自动回滚，避免事务长时间不提交会回滚导致的数据库资源的占用。</td></tr><tr><td>rollback-for</td><td>指定事务对于那些类型的异常应当回滚，而不提交。</td></tr><tr><td>no-rollback-for</td><td>指定事务对于那些异常应当继续运行，而不回滚。</td></tr></tbody></table><h3 id="4-配置切点切面"><a href="#4-配置切点切面" class="headerlink" title="4. 配置切点切面"></a>4. 配置切点切面</h3><p><a href="tx:advice">tx:advice</a> 元素只是定义了一个 AOP 通知，它并不是一个完整的事务性切面。我们在 <a href="tx:advice">tx:advice</a> 元素中并没有定义哪些 Bean 应该被通知，因此我们需要一个切点来做这件事。</p><p>在 Spring 的 XML 配置中，我们可以利用 Spring AOP 技术将事务通知（tx-advice）和切点配置到切面中，配置内容如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置切点和切面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置切点--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-pt&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* net.biancheng.c.service.impl.OrderServiceImpl.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--配置切面--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx-advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;tx-pt&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何启用注解驱动的事务编程模型？"><a href="#如何启用注解驱动的事务编程模型？" class="headerlink" title="如何启用注解驱动的事务编程模型？"></a>如何启用注解驱动的事务编程模型？</h3><h4 id="1-开启注解事务"><a href="#1-开启注解事务" class="headerlink" title="1. 开启注解事务"></a>1. 开启注解事务</h4><p>tx 命名空间提供了一个 <a href="tx:annotation-driven">tx:annotation-driven</a> 元素，用来开启注解事务，简化 Spring 声明式事务的 XML 配置。</p><p><a href="tx:annotation-driven">tx:annotation-driven</a> 元素的使用方式也十分的简单，我们只要在 Spring 的 XML 配置中添加这样一行配置即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与 <a href="tx:advice">tx:advice</a> 元素一样，<a href="tx:annotation-driven">tx:annotation-driven</a> 也需要通过 transaction-manager 属性来定义一个事务管理器，这个参数的取值默认为 transactionManager。如果我们使用的事务管理器的 id 与默认值相同，则可以省略对该属性的配置，形式如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>通过 <a href="tx:annotation-driven">tx:annotation-driven</a> 元素开启注解事务后，Spring 会自动对容器中的 Bean 进行检查，找到使用 @Transactional 注解的 Bean，并为其提供事务支持。</p><h4 id="2-使用-Transactional-注解"><a href="#2-使用-Transactional-注解" class="headerlink" title="2. 使用 @Transactional 注解"></a>2. 使用 @Transactional 注解</h4><p>@Transactional 注解是 Spring 声明式事务编程的核心注解，该注解既可以在类上使用，也可以在方法上使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XXX</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">(Order order)</span> &#123;<br>    ……<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">(Order order)</span> &#123;<br>    ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若 @Transactional 注解在类上使用，则表示类中的所有方法都支持事务；若 @Transactional 注解在方法上使用，则表示当前方法支持事务。</p><p>Spring 在容器中查找所有使用了 @Transactional 注解的 Bean，并自动为它们添加事务通知，通知的事务属性则是通过 @Transactional 注解的属性来定义的。</p><p>@Transactional 注解包含多个属性，其中常用属性如下表。</p><table><thead><tr><th>事务属性</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>指定事务的传播行为。</td></tr><tr><td>isolation</td><td>指定事务的隔离级别。</td></tr><tr><td>read-only</td><td>指定是否为只读事务。</td></tr><tr><td>timeout</td><td>表示超时时间，单位为“秒”；声明的事务在指定的超时时间后，自动回滚，避免事务长时间不提交会回滚导致的数据库资源的占用。</td></tr><tr><td>rollback-for</td><td>指定事务对于那些类型的异常应当回滚，而不提交。</td></tr><tr><td>no-rollback-for</td><td>指定事务对于那些异常应当继续运行，而不回滚。</td></tr></tbody></table><h3 id="SQLSessionFactory的创建与使用？"><a href="#SQLSessionFactory的创建与使用？" class="headerlink" title="SQLSessionFactory的创建与使用？"></a>SQLSessionFactory的创建与使用？</h3><p><mark>to_do</mark></p><h3 id="如何使用Java类替换web-xml？"><a href="#如何使用Java类替换web-xml？" class="headerlink" title="如何使用Java类替换web.xml？"></a>如何使用Java类替换web.xml？</h3><p><mark>to_do</mark></p><h3 id="如何集成SSM？"><a href="#如何集成SSM？" class="headerlink" title="如何集成SSM？"></a>如何集成SSM？</h3><p><mark>to_do</mark></p><h3 id="如何配置Spring-Security？"><a href="#如何配置Spring-Security？" class="headerlink" title="如何配置Spring Security？"></a>如何配置Spring Security？</h3><p><mark>to_do</mark></p><h2 id="spring-MVC-12问"><a href="#spring-MVC-12问" class="headerlink" title="spring MVC 12问"></a>spring MVC 12问</h2><h3 id="MVC模式的概念？"><a href="#MVC模式的概念？" class="headerlink" title="MVC模式的概念？"></a>MVC模式的概念？</h3><p>MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。</p><h3 id="Spring-MVC包含的组件及其作用？"><a href="#Spring-MVC包含的组件及其作用？" class="headerlink" title="Spring MVC包含的组件及其作用？"></a>Spring MVC包含的组件及其作用？</h3><h4 id="1）DispatcherServlet"><a href="#1）DispatcherServlet" class="headerlink" title="1）DispatcherServlet"></a>1）DispatcherServlet</h4><p>DispatcherServlet 是前端控制器，从图 1 可以看出，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p><h4 id="2）HandlerMapping"><a href="#2）HandlerMapping" class="headerlink" title="2）HandlerMapping"></a>2）HandlerMapping</h4><p>HandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。</p><h4 id="3）HandlerAdapter"><a href="#3）HandlerAdapter" class="headerlink" title="3）HandlerAdapter"></a>3）HandlerAdapter</h4><p>HandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。</p><h4 id="4）Handler"><a href="#4）Handler" class="headerlink" title="4）Handler"></a>4）Handler</h4><p>Handler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。</p><h4 id="5）View-Resolver"><a href="#5）View-Resolver" class="headerlink" title="5）View Resolver"></a>5）View Resolver</h4><p>View Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。</p><h4 id="6）View"><a href="#6）View" class="headerlink" title="6）View"></a>6）View</h4><p>View 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。</p><p>以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。</p><h3 id="Spring-MVC处理请求的过程？"><a href="#Spring-MVC处理请求的过程？" class="headerlink" title="Spring MVC处理请求的过程？"></a>Spring MVC处理请求的过程？</h3><p><img src="http://c.biancheng.net/uploads/allimg/210705/1139441444-0.png" srcset="/img/loading.gif" lazyload alt="Spring MVC执行流程"></p><p>SpringMVC 的执行流程如下。</p><ol><li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li><li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li><li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li><li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li><li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li><li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li><li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li><li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li><li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li><li>视图负责将结果显示到浏览器（客户端）。</li></ol><h3 id="合法的URL模式？"><a href="#合法的URL模式？" class="headerlink" title="合法的URL模式？"></a>合法的URL模式？</h3><p><mark>to_do</mark></p><h3 id="如何配置DispatcherServlet？"><a href="#如何配置DispatcherServlet？" class="headerlink" title="如何配置DispatcherServlet？"></a>如何配置DispatcherServlet？</h3><p>xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--web.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-comment">&lt;!--  如果不指定&lt;context-param&gt;, 将会默认加载/WEB-INF/applicationContext.xml文件.--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Java配置:实现WebApplicationInitializer接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebApplicationInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebApplicationInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletCxt)</span> &#123;<br><br>        <span class="hljs-comment">// 加载spring 容器</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        ac.register(AppConfig.class);<br>        ac.refresh();<br><br>        <span class="hljs-comment">// 创建并注册DispatcherServlet</span><br>        <span class="hljs-type">DispatcherServlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispatcherServlet</span>(ac);<br>        ServletRegistration.<span class="hljs-type">Dynamic</span> <span class="hljs-variable">registration</span> <span class="hljs-operator">=</span> servletCxt.addServlet(<span class="hljs-string">&quot;app&quot;</span>, servlet);<br>        registration.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        registration.addMapping(<span class="hljs-string">&quot;/app/*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何配置Spring-MVC配置文件的位置？"><a href="#如何配置Spring-MVC配置文件的位置？" class="headerlink" title="如何配置Spring MVC配置文件的位置？"></a>如何配置Spring MVC配置文件的位置？</h3><p>Spring MVC 配置：在 web.xml 中配置 Servlet，创建 Spring MVC 的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置 DispatcherServlet 的一个初始化参数：spring mvc 配置文件按的位置和名称--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><br><span class="hljs-comment">            而这些操作放在第一次请求时才执行会严重影响访问速度</span><br><span class="hljs-comment">            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Spring-MVC配置文件的默认名称？"><a href="#Spring-MVC配置文件的默认名称？" class="headerlink" title="Spring MVC配置文件的默认名称？"></a>Spring MVC配置文件的默认名称？</h3><p><mark>to_do</mark></p><h3 id="如何配置视图解析器？"><a href="#如何配置视图解析器？" class="headerlink" title="如何配置视图解析器？"></a>如何配置视图解析器？</h3><p>in *-.servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启组件扫描--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 Thymeleaf 视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。</p><p>Spring MVC 提供了很多视图解析类，其中每一项都对应 Java Web 应用中特定的某些视图技术。下面介绍一些常用的视图解析类。</p><h4 id="URLBasedViewResolver"><a href="#URLBasedViewResolver" class="headerlink" title="URLBasedViewResolver"></a>URLBasedViewResolver</h4><p>UrlBasedViewResolver 是对 ViewResolver 的一种简单实现，主要提供了一种拼接 URL 的方式来解析视图。</p><p>UrlBasedViewResolver 通过 prefix 属性指定前缀，suffix 属性指定后缀。当 ModelAndView 对象返回具体的 View 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户。</p><p>使用 UrlBasedViewResolver 除了要配置前缀和后缀属性之外，还需要配置“viewClass”，表示解析成哪种视图。示例代码如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span>            <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--不能省略--&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="InternalResourceViewResolver"><a href="#InternalResourceViewResolver" class="headerlink" title="InternalResourceViewResolver"></a>InternalResourceViewResolver</h4><p>InternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性。</p><p>InternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL。也就是说，使用 InternalResourceViewResolver 视图解析时，无需再单独指定 viewClass 属性。示例代码如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--可以省略--&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建和使用控制器？"><a href="#创建和使用控制器？" class="headerlink" title="创建和使用控制器？"></a>创建和使用控制器？</h3><p>@Controller 注解用于声明某类的实例是一个控制器。例如，创建控制器类 IndexController，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> &#123;<br>    <span class="hljs-comment">// 处理请求的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Spring MVC 使用扫描机制找到应用中所有基于注解的控制器类，所以，为了让控制器类被 Spring MVC 框架扫描到，需要在配置文件中声明 spring-context，并使用 <code>&lt;context:component-scan/&gt;</code> 元素指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）。</p><p>例如，在 springmvcDemo 应用的配置文件 springmvc-servlet.xml 中添加以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example.controller&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何映射不同的请求？"><a href="#如何映射不同的请求？" class="headerlink" title="如何映射不同的请求？"></a>如何映射不同的请求？</h3><p>在基于注解的控制器类中可以为每个请求编写对应的处理方法。使用 @RequestMapping 注解将请求与处理方法一 一对应即可。</p><p>@RequestMapping 注解可用于类或方法上。用于类上，表示类中的所有响应请求的方法都以该地址作为父路径。</p><p>@RequestMapping 注解常用属性如下。</p><h4 id="1-value-属性"><a href="#1-value-属性" class="headerlink" title="1. value 属性"></a>1. value 属性</h4><p>value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称。如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;toUser&quot;)</span><br><span class="hljs-comment">//or</span><br><span class="hljs-meta">@RequestMapping(&quot;toUser&quot;)</span><br></code></pre></td></tr></table></figure><p>value 属性支持通配符匹配，如 <code>@RequestMapping(value=&quot;toUser/*&quot;)</code> 表示 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p><h4 id="2-path属性"><a href="#2-path属性" class="headerlink" title="2. path属性"></a>2. path属性</h4><p>path 属性和 value 属性都用来作为映射使用。即 <code>@RequestMapping(value=&quot;toUser&quot;)</code> 和 <code>@RequestMapping(path=&quot;toUser&quot;)</code> 都能访问 toUser() 方法。</p><p>path 属性支持通配符匹配，如 <code>@RequestMapping(path=&quot;toUser/*&quot;)</code> 表示 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p><h4 id="3-name属性"><a href="#3-name属性" class="headerlink" title="3. name属性"></a>3. name属性</h4><p>name属性相当于方法的注释，使方法更易理解。如 <code>@RequestMapping(value = &quot;toUser&quot;,name = &quot;获取用户信息&quot;)</code>。</p><h4 id="4-method属性"><a href="#4-method属性" class="headerlink" title="4. method属性"></a>4. method属性</h4><p>method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求。</p><p><code>@RequestMapping(value = &quot;toUser&quot;,method = RequestMethod.GET)</code>表示该方法只支持 GET 请求。</p><p>也可指定多个 HTTP 请求，如 <code>@RequestMapping(value = &quot;toUser&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</code>，说明该方法同时支持 GET 和 POST 请求。</p><h4 id="5-params属性"><a href="#5-params属性" class="headerlink" title="5. params属性"></a>5. params属性</h4><p>params 属性用于指定请求中规定的参数，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;showUser&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码表示请求中必须包含 type 参数时才能执行该请求。即 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser?type=xxx">http://localhost:8080/toUser?type=xxx</a> 能够正常访问 toUser() 方法，而 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser">http://localhost:8080/toUser</a> 则不能正常访问 toUser() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type=1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toUser</span><span class="hljs-params">()</span> &#123;        <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;showUser&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求。即 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser?type=1">http://localhost:8080/toUser?type=1</a> 能够正常访问 toUser() 方法，而 <a target="_blank" rel="noopener" href="http://localhost:8080/toUser?type=2">http://localhost:8080/toUser?type=2</a> 则不能正常访问 toUser() 方法。</p><h4 id="6-header属性"><a href="#6-header属性" class="headerlink" title="6. header属性"></a>6. header属性</h4><p>header 属性表示请求中必须包含某些指定的 header 值。</p><p><code>@RequestMapping(value = &quot;toUser&quot;,headers = &quot;Referer=http://www.xxx.com&quot;)</code> 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“<a target="_blank" rel="noopener" href="http://www.xxx.com”时,才能执行该请求./">http://www.xxx.com”时，才能执行该请求。</a></p><h4 id="7-consumers属性"><a href="#7-consumers属性" class="headerlink" title="7. consumers属性"></a>7. consumers属性</h4><p>consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html。如<br><code>@RequestMapping(value = &quot;toUser&quot;,consumes = &quot;application/json&quot;)</code>。</p><h4 id="8-produces属性"><a href="#8-produces属性" class="headerlink" title="8. produces属性"></a>8. produces属性</h4><p>produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json”)。</p><p>除此之外，produces 属性还可以指定返回值的编码。如 <code>@RequestMapping(value = &quot;toUser&quot;,produces = &quot;application/json,charset=utf-8&quot;)</code>，表示返回 utf-8 编码。</p><p>使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头。</p><h3 id="如何配置静态资源？"><a href="#如何配置静态资源？" class="headerlink" title="如何配置静态资源？"></a>如何配置静态资源？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/css/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/img/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/img/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- 在配置了mvc:resources标签之后必须配置mvc:annotation-driven标签静态资源</span><br><span class="hljs-comment">	才可以访问，否则不仅静态资源不能访问，其他的所有请求也都无法正常处理了 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何构建Restful-API？"><a href="#如何构建Restful-API？" class="headerlink" title="如何构建Restful API？"></a>如何构建Restful API？</h3><p>REST（Representational State Transfer）即表述性转移，是目前最流行的一种软件架构风格。它结构清晰、易于理解、有较好的扩展性。</p><p>Spring REST 风格可以简单理解为：使用 URL 表示资源时，每个资源都用一个独一无二的 URL 来表示，并使用 HTTP 方法表示操作，即准确描述服务器对资源的处理动作（GET、POST、PUT、DELETE），实现资源的增删改查。</p><ul><li>GET：表示获取资源</li><li>POST：表示新建资源</li><li>PUT：表示更新资源</li><li>DELETE：表示删除资源</li></ul><h1 id="Spring-Boot-66问"><a href="#Spring-Boot-66问" class="headerlink" title="Spring Boot 66问"></a>Spring Boot 66问</h1><h2 id="框架23问"><a href="#框架23问" class="headerlink" title="框架23问"></a>框架23问</h2><h3 id="启动依赖是什么？"><a href="#启动依赖是什么？" class="headerlink" title="启动依赖是什么？"></a>启动依赖是什么？</h3><p>Spring Boot就可以指定基于功能依赖。Spring Boot通过起步依赖为项目的依赖管理提供帮助。如果应用程序是Web应用程序（功能），不需要向项目pom.xml文件中添加一堆单独的依赖，可以直接向项目中添加Web起步依赖。如果应用程序需要用到JPA持久化（功能），加入jpa起步依赖；如果需要安全功能（功能），就加入security起步依赖。添加依赖时不需要指定依赖的版本号，依赖的版本号由当前是使用的Spring Boot版本号来决定。</p><p>起步依赖就是特殊的Maven依赖，利用了传递依赖解析，把常用库聚合在一起，组成几个为特定功能而定制的依赖。Spring Boot通过起步依赖：直接引入相关起步依赖就行，我们不需要考虑支持某种功能需要什么库， 减少了依赖数量，而且不需要考虑这些库的那些版本。如果我们需要什么功能，就往项目中加入该功能的起步依赖就好了。</p><h3 id="Actuator的作用？"><a href="#Actuator的作用？" class="headerlink" title="Actuator的作用？"></a>Actuator的作用？</h3><p>Actuator用于监视和管理应用程序</p><p>Spring Boot Actuator 模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理Spring Boot 应用。</p><p>这个模块是一个采集应用内部信息暴露给外部的模块，上述的功能都可以通过HTTP 和 JMX 访问。</p><p>因为暴露内部信息的特性，Actuator 也可以和一些外部的应用监控系统整合（Prometheus, Graphite, DataDog, Influx, Wavefront, New Relic等）。</p><h3 id="Spring-Boot-配置依赖？"><a href="#Spring-Boot-配置依赖？" class="headerlink" title="Spring Boot 配置依赖？"></a>Spring Boot 配置依赖？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="如何修饰启动类？"><a href="#如何修饰启动类？" class="headerlink" title="如何修饰启动类？"></a>如何修饰启动类？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--排除依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--用指定依赖版本 覆盖 传递依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="SpringBootApplication是哪三合一？"><a href="#SpringBootApplication是哪三合一？" class="headerlink" title="@SpringBootApplication是哪三合一？"></a>@SpringBootApplication是哪三合一？</h3><p>@SpringBootApplication &#x3D; (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><p>@Configuration：建一个简单的spring配置类，可以用来替代相应的xml配置文件，见词条 @Configuration和@Bean注解的作用</p><p>@EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置</p><p>@ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service,@Repository,@Controller</p><h3 id="如何关闭或动配置？"><a href="#如何关闭或动配置？" class="headerlink" title="如何关闭或动配置？"></a>如何关闭或动配置？</h3><p><mark>to_do</mark></p><h3 id="如何排除指定的自动配置？"><a href="#如何排除指定的自动配置？" class="headerlink" title="如何排除指定的自动配置？"></a>如何排除指定的自动配置？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(exclude=&#123;RedisAutoConfiguration.class&#125;)</span><br></code></pre></td></tr></table></figure><h3 id="一个启动类能否同时作为控制器类？"><a href="#一个启动类能否同时作为控制器类？" class="headerlink" title="一个启动类能否同时作为控制器类？"></a>一个启动类能否同时作为控制器类？</h3><p>能</p><h3 id="如何自定义banner？"><a href="#如何自定义banner？" class="headerlink" title="如何自定义banner？"></a>如何自定义banner？</h3><p><mark>to_do</mark></p><h3 id="SpringBoot如何实现自动配置？"><a href="#SpringBoot如何实现自动配置？" class="headerlink" title="SpringBoot如何实现自动配置？"></a>SpringBoot如何实现自动配置？</h3><p><mark>to_do</mark></p><h3 id="SpringBoot如何配置视图解析器？"><a href="#SpringBoot如何配置视图解析器？" class="headerlink" title="SpringBoot如何配置视图解析器？"></a>SpringBoot如何配置视图解析器？</h3><p><strong>配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.mvc.view.prefix</span>=<span class="hljs-string">/pages/</span><br><span class="hljs-attr">spring.mvc.view.suffix</span>=<span class="hljs-string">.html</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/pages/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.html</span><br></code></pre></td></tr></table></figure><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title function_">configureInternalResourceViewResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InternalResourceViewResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalResourceViewResolver</span>();<br>        resolver.setPrefix(<span class="hljs-string">&quot;/pages/&quot;</span>);<br>        resolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>        <span class="hljs-keyword">return</span> resolver;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何配置端口号？"><a href="#如何配置端口号？" class="headerlink" title="如何配置端口号？"></a>如何配置端口号？</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><h3 id="properties与yml的异同？"><a href="#properties与yml的异同？" class="headerlink" title="properties与yml的异同？"></a>properties与yml的异同？</h3><p><mark>properties的优先级会高于yml</mark></p><p>yml采用树形结构，更有层次感，可读性很强；相反，properties 则更为直接</p><p>properties 的基本语法格式是“key&#x3D;value”的形式；yml 的基本语法格式是“key: value”的形式,冒号后面需要加空格</p><h3 id="静态资源默认位置在哪？"><a href="#静态资源默认位置在哪？" class="headerlink" title="静态资源默认位置在哪？"></a>静态资源默认位置在哪？</h3><p>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</p><p>classpath:&#x2F;resources&#x2F;</p><p>classpath:&#x2F;static&#x2F;</p><p>classpath:&#x2F;public&#x2F;</p><h3 id="如何自定义静态资源的位置？"><a href="#如何自定义静态资源的位置？" class="headerlink" title="如何自定义静态资源的位置？"></a>如何自定义静态资源的位置？</h3><p><strong>在配置文件中配置</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#静态资源访问路径</span><br><span class="hljs-attr">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/upload/**</span><br><span class="hljs-comment">#静态资源映射路径</span><br><span class="hljs-attr">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/upload/</span><br></code></pre></td></tr></table></figure><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;　　　　　<span class="hljs-comment">// 这里之所以多了一&quot;/&quot;,是为了解决打war时访问不到问题</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;classpath:/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有哪些常用的JSON解析器？"><a href="#有哪些常用的JSON解析器？" class="headerlink" title="有哪些常用的JSON解析器？"></a>有哪些常用的JSON解析器？</h3><p>1）json-lib</p><p>json-lib 最早也是应用广泛的 JSON 解析工具，缺点是依赖很多的第三方包</p><p>对于复杂类型的转换，json-lib 在将 JSON 转换成 Bean 时还有缺陷，比如一个类里包含另一个类的 List 或者 Map 集合，json-lib 从 JSON 到 Bean 的转换就会出现问题。</p><h4 id="2）开源的Jackson"><a href="#2）开源的Jackson" class="headerlink" title="2）开源的Jackson"></a>2）开源的Jackson</h4><p>开源的 Jackson 是 Spring MVC 内置的 JSON 转换工具。</p><p>但是 Jackson 对于复杂类型的 JSON 转换 Bean 会出现问题</p><h4 id="3）Google的Gson"><a href="#3）Google的Gson" class="headerlink" title="3）Google的Gson"></a>3）Google的Gson</h4><p>Gson 是目前功能最全的 JSON 解析神器</p><p>Gson 完全可以将复杂类型的 JSON 到 Bean 或 Bean 到 JSON 的转换，是 JSON 解析的神器。Gson 在功能上面无可挑剔，但性能比 FastJson 有所差距。</p><h4 id="4）阿里巴巴的FastJson"><a href="#4）阿里巴巴的FastJson" class="headerlink" title="4）阿里巴巴的FastJson"></a>4）阿里巴巴的FastJson</h4><p>FastJson 是用 Java 语言编写的高性能 JSON 处理器，由阿里巴巴公司开发。</p><p>FastJson 在复杂类型的 Bean 转换 JSON 上会出现一些问题，可能会出现引用的类型，导致 JSON 转换出错，需要制定引用。</p><h3 id="为哪些JSON解析器提供了自动配置？"><a href="#为哪些JSON解析器提供了自动配置？" class="headerlink" title="为哪些JSON解析器提供了自动配置？"></a>为哪些JSON解析器提供了自动配置？</h3><p>Gson 、Jackson 、JSON-B</p><h3 id="如何使用fastjson？"><a href="#如何使用fastjson？" class="headerlink" title="如何使用fastjson？"></a>如何使用fastjson？</h3><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>直接用。。。</p><p><mark>to_do</mark></p><h3 id="如何自定义错误界面的位置？"><a href="#如何自定义错误界面的位置？" class="headerlink" title="如何自定义错误界面的位置？"></a>如何自定义错误界面的位置？</h3><p><strong>静态</strong></p><p>在 resource&#x2F;static 目录下创建 error 目录，然后在 error 目录中创建错误展示页面。错误展示页面命名规则有如下两种：</p><p>一种是直接使用具体的响应码命名文件，比如：404.html、405.html、500.html<br>另一种可以使用 4xx.html、5xx.html 这样的命名</p><p><strong>动态</strong></p><p>在 resource&#x2F;templates 目录下创建 error 目录，然后在 error 目录中创建错误展示页面。</p><h3 id="错误界面使用的顺序如何？"><a href="#错误界面使用的顺序如何？" class="headerlink" title="错误界面使用的顺序如何？"></a>错误界面使用的顺序如何？</h3><p>优先级：</p><p>动态错误码&gt;静态错误码&gt;动态模糊错误码&gt;静态模糊错误码</p><p>找到一个后便不往下寻找</p><h3 id="如何定义局部异常handler？"><a href="#如何定义局部异常handler？" class="headerlink" title="如何定义局部异常handler？"></a>如何定义局部异常handler？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(value = &#123;java.lang.ArithmeticException.class&#125;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">arithmeticExceptionHandler</span><span class="hljs-params">(Exception e)</span>&#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    mv.addObject(<span class="hljs-string">&quot;errorMsg&quot;</span>,e);<br>    mv.setViewName(<span class="hljs-string">&quot;error&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何定义全局异常handler？"><a href="#如何定义全局异常handler？" class="headerlink" title="如何定义全局异常handler？"></a>如何定义全局异常handler？</h3><p><mark>to_do</mark></p><h3 id="如何使用RestController？"><a href="#如何使用RestController？" class="headerlink" title="如何使用RestController？"></a>如何使用RestController？</h3><p>如果在类上加上@RestController，该类中的所有SpringMVCUrl接口映射都是返回json格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hello</span>&#123;<br>  <span class="hljs-comment">//something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Thymeleaf-11问"><a href="#Thymeleaf-11问" class="headerlink" title="Thymeleaf 11问"></a>Thymeleaf 11问</h2><h3 id="Thymeleaf如何使用变量表达式页面获取不同范围的属性？"><a href="#Thymeleaf如何使用变量表达式页面获取不同范围的属性？" class="headerlink" title="Thymeleaf如何使用变量表达式页面获取不同范围的属性？"></a>Thymeleaf如何使用变量表达式页面获取不同范围的属性？</h3><h3 id="Thymeleaf的五种表达式？"><a href="#Thymeleaf的五种表达式？" class="headerlink" title="Thymeleaf的五种表达式？"></a>Thymeleaf的五种表达式？</h3><h3 id="如何使用选择变量表达式？"><a href="#如何使用选择变量表达式？" class="headerlink" title="如何使用选择变量表达式？"></a>如何使用选择变量表达式？</h3><h3 id="链接表达式的四种写法？"><a href="#链接表达式的四种写法？" class="headerlink" title="链接表达式的四种写法？"></a>链接表达式的四种写法？</h3><h3 id="怎么定义和引用片段？"><a href="#怎么定义和引用片段？" class="headerlink" title="怎么定义和引用片段？"></a>怎么定义和引用片段？</h3><h3 id="哪些字面标记不合法？"><a href="#哪些字面标记不合法？" class="headerlink" title="哪些字面标记不合法？"></a>哪些字面标记不合法？</h3><h3 id="th：-属性的作用？"><a href="#th：-属性的作用？" class="headerlink" title="th：*属性的作用？"></a>th：*属性的作用？</h3><h3 id="Thymeleaf的名称空间？"><a href="#Thymeleaf的名称空间？" class="headerlink" title="Thymeleaf的名称空间？"></a>Thymeleaf的名称空间？</h3><h3 id="常用的表达式？"><a href="#常用的表达式？" class="headerlink" title="常用的表达式？"></a>常用的表达式？</h3><h3 id="有哪些基本对象？"><a href="#有哪些基本对象？" class="headerlink" title="有哪些基本对象？"></a>有哪些基本对象？</h3><h3 id="表达式工具对象如何使用？"><a href="#表达式工具对象如何使用？" class="headerlink" title="表达式工具对象如何使用？"></a>表达式工具对象如何使用？</h3><h2 id="Spring-Boot-JPA-13问"><a href="#Spring-Boot-JPA-13问" class="headerlink" title="Spring Boot JPA 13问"></a>Spring Boot JPA 13问</h2><h3 id="springboot支持的三种数据源是什么？"><a href="#springboot支持的三种数据源是什么？" class="headerlink" title="springboot支持的三种数据源是什么？"></a>springboot支持的三种数据源是什么？</h3><h3 id="如何配置数据源？"><a href="#如何配置数据源？" class="headerlink" title="如何配置数据源？"></a>如何配置数据源？</h3><h3 id="SpringDataJPA是什么？"><a href="#SpringDataJPA是什么？" class="headerlink" title="SpringDataJPA是什么？"></a>SpringDataJPA是什么？</h3><h3 id="SpringData-JPA-需不需要JPA提供程序？"><a href="#SpringData-JPA-需不需要JPA提供程序？" class="headerlink" title="SpringData JPA 需不需要JPA提供程序？"></a>SpringData JPA 需不需要JPA提供程序？</h3><h3 id="JPA个各个属性都有什么作用？"><a href="#JPA个各个属性都有什么作用？" class="headerlink" title="JPA个各个属性都有什么作用？"></a>JPA个各个属性都有什么作用？</h3><h3 id="有哪些常用的注解？"><a href="#有哪些常用的注解？" class="headerlink" title="有哪些常用的注解？"></a>有哪些常用的注解？</h3><h3 id="Repository接口和他的派生类型？"><a href="#Repository接口和他的派生类型？" class="headerlink" title="Repository接口和他的派生类型？"></a>Repository接口和他的派生类型？</h3><h3 id="如何构建简单的条件查询？"><a href="#如何构建简单的条件查询？" class="headerlink" title="如何构建简单的条件查询？"></a>如何构建简单的条件查询？</h3><h3 id="如何使用-Query查询？"><a href="#如何使用-Query查询？" class="headerlink" title="如何使用@Query查询？"></a>如何使用@Query查询？</h3><h3 id="如何进行增删改？"><a href="#如何进行增删改？" class="headerlink" title="如何进行增删改？"></a>如何进行增删改？</h3><h3 id="如何声明事务？"><a href="#如何声明事务？" class="headerlink" title="如何声明事务？"></a>如何声明事务？</h3><h3 id="如何配置mapper映射文件的位置？"><a href="#如何配置mapper映射文件的位置？" class="headerlink" title="如何配置mapper映射文件的位置？"></a>如何配置mapper映射文件的位置？</h3><h3 id="如何开启对mapper包的扫描？"><a href="#如何开启对mapper包的扫描？" class="headerlink" title="如何开启对mapper包的扫描？"></a>如何开启对mapper包的扫描？</h3><h2 id="消息传递-10问"><a href="#消息传递-10问" class="headerlink" title="消息传递 10问"></a>消息传递 10问</h2><h3 id="消息传递的概念？"><a href="#消息传递的概念？" class="headerlink" title="消息传递的概念？"></a>消息传递的概念？</h3><h3 id="JMS的概念？"><a href="#JMS的概念？" class="headerlink" title="JMS的概念？"></a>JMS的概念？</h3><h3 id="点对点模型有什么特点？"><a href="#点对点模型有什么特点？" class="headerlink" title="点对点模型有什么特点？"></a>点对点模型有什么特点？</h3><h3 id="发布订阅模型的特点？"><a href="#发布订阅模型的特点？" class="headerlink" title="发布订阅模型的特点？"></a>发布订阅模型的特点？</h3><h3 id="ActiveMQ是什么？"><a href="#ActiveMQ是什么？" class="headerlink" title="ActiveMQ是什么？"></a>ActiveMQ是什么？</h3><h3 id="如何启动ActiveMQ？"><a href="#如何启动ActiveMQ？" class="headerlink" title="如何启动ActiveMQ？"></a>如何启动ActiveMQ？</h3><h3 id="JMS创建什么链接实例？"><a href="#JMS创建什么链接实例？" class="headerlink" title="JMS创建什么链接实例？"></a>JMS创建什么链接实例？</h3><h3 id="如何配置ActiveMQ？"><a href="#如何配置ActiveMQ？" class="headerlink" title="如何配置ActiveMQ？"></a>如何配置ActiveMQ？</h3><h3 id="JMSListener有什么用？"><a href="#JMSListener有什么用？" class="headerlink" title="@JMSListener有什么用？"></a>@JMSListener有什么用？</h3><h3 id="如何使用发布订阅模型？"><a href="#如何使用发布订阅模型？" class="headerlink" title="如何使用发布订阅模型？"></a>如何使用发布订阅模型？</h3><h2 id="测试-9问"><a href="#测试-9问" class="headerlink" title="测试 9问"></a>测试 9问</h2><h3 id="单元测试与集成测试？"><a href="#单元测试与集成测试？" class="headerlink" title="单元测试与集成测试？"></a>单元测试与集成测试？</h3><h3 id="Junit5的三个组件是什么？"><a href="#Junit5的三个组件是什么？" class="headerlink" title="Junit5的三个组件是什么？"></a>Junit5的三个组件是什么？</h3><h3 id="Junit的常用注解？"><a href="#Junit的常用注解？" class="headerlink" title="Junit的常用注解？"></a>Junit的常用注解？</h3><h3 id="Junit的测试方法与注意事项？"><a href="#Junit的测试方法与注意事项？" class="headerlink" title="Junit的测试方法与注意事项？"></a>Junit的测试方法与注意事项？</h3><h3 id="Test依赖包含的库有哪些？"><a href="#Test依赖包含的库有哪些？" class="headerlink" title="Test依赖包含的库有哪些？"></a>Test依赖包含的库有哪些？</h3><h3 id="如何测试Spring-Boot程序？"><a href="#如何测试Spring-Boot程序？" class="headerlink" title="如何测试Spring Boot程序？"></a>如何测试Spring Boot程序？</h3><h3 id="MockMvc是什么？"><a href="#MockMvc是什么？" class="headerlink" title="MockMvc是什么？"></a>MockMvc是什么？</h3><h3 id="WebMvcTest有什么用？"><a href="#WebMvcTest有什么用？" class="headerlink" title="@WebMvcTest有什么用？"></a>@WebMvcTest有什么用？</h3></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div></div><div>2023/02/07/subject/ssm/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>charlesix59</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/02/07/subject/software_project/chapter1/" title="软件工程复习 第一章"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">软件工程复习 第一章</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="2023/02/07/subject/operate_system/chapter8/" title="操作系统复习 第八章"><span class="hidden-mobile">操作系统复习 第八章</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.5.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.5.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://hexo-comment-qncm4vegj-charlesix59.vercel.app/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/bilibili"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class=":" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">create by Charles Min at 2022 @CopyRight</div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/about/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?charlesix59",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"charlesix59")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style>#github_container>.position-relative>.border{border:0!important}#github-calendar{position:relative;margin-top:-2rem;background-color:var(--board-bg-color);transition:background-color .2s ease-in-out;border-radius:.5rem;z-index:3;-webkit-box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%)}</style></body></html>