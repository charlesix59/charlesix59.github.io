<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon.png"><link rel="icon" href="/images/icon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="charlesix59"><meta name="keywords" content=""><meta name="description" content="第二章 进程的描述与控制程序的执行顺序程序的顺序执行一个具有独立功能的程序独占处理机，直到得到最终结果的过程 前驱图一个有向无环图（DAG），用于描述进程间执行的前后的关系  节点：表示一个程序段或进程，或一条语句  有向边：节点之间的偏序或前驱关系  初始节点：没有前驱关系的点  终止节点：没有后继的节点   程序顺序执行的特性：  顺序性：处理机的操作严格按照顺序进行  封闭性：程序一旦开始执"><meta property="og:type" content="article"><meta property="og:title" content="操作系统复习 第二章"><meta property="og:url" content="2023/02/07/subject/operate_system/chapter2/index.html"><meta property="og:site_name" content="茶理的私人博客"><meta property="og:description" content="第二章 进程的描述与控制程序的执行顺序程序的顺序执行一个具有独立功能的程序独占处理机，直到得到最终结果的过程 前驱图一个有向无环图（DAG），用于描述进程间执行的前后的关系  节点：表示一个程序段或进程，或一条语句  有向边：节点之间的偏序或前驱关系  初始节点：没有前驱关系的点  终止节点：没有后继的节点   程序顺序执行的特性：  顺序性：处理机的操作严格按照顺序进行  封闭性：程序一旦开始执"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="/img/images/2023-01-23-14-34-25-image.png"><meta property="og:image" content="/img/images/2023-01-23-15-45-35-image.png"><meta property="article:published_time" content="2023-02-07T05:32:45.000Z"><meta property="article:modified_time" content="2023-02-07T05:59:20.782Z"><meta property="article:author" content="charlesix59"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="/img/images/2023-01-23-14-34-25-image.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>操作系统复习 第二章 - 茶理的私人博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script type="text/javascript" src="/js/love.js"></script><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"https:/charlesix59.github.io",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><script type="text/javascript" color="0,160,230" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>茶理的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="操作系统复习 第二章"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-07 13:32" pubdate>2023年2月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 68 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统复习 第二章</h1><div class="markdown-body"><h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="程序的执行顺序"><a href="#程序的执行顺序" class="headerlink" title="程序的执行顺序"></a>程序的执行顺序</h2><h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><p>一个具有独立功能的程序独占处理机，直到得到最终结果的过程</p><h4 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h4><p>一个有向无环图（DAG），用于描述进程间执行的前后的关系</p><ul><li><p>节点：表示一个程序段或进程，或一条语句</p></li><li><p>有向边：节点之间的偏序或前驱关系</p></li><li><p>初始节点：没有前驱关系的点</p></li><li><p>终止节点：没有后继的节点</p></li></ul><p>程序顺序执行的特性：</p><ul><li><p>顺序性：处理机的操作严格按照顺序进行</p></li><li><p>封闭性：程序一旦开始执行，结果不受外因影响</p></li><li><p>可再现性：程序结果与执行速度无关，只与初始条件有关</p></li></ul><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>内存中同时装入多道程序，他们共享系统资源，并发执行</p><p>特性：</p><ul><li><p>间断性:程序并发执行时,由于它们共享资源或程序之间相互合作完成-项共同任务,因而使程序之间相互制约。相互制约导致并发程序具有”执行一暂停-执行”这种间断性的活动规律。</p></li><li><p>失去封闭性: 程序在并发执行时,多个程序共享资源,因而资源的状态将由多个程序来改变,致使程序的运行失去了封闭性。</p></li><li><p>不可再现性:程序在并发执行时,多次运行初始条件相同的同-一程序会得出不同的运行结果。</p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li><p>定义：</p><ul><li><p>程序段、数据段、PCB三部分构成了进程实体,简称”进程”。</p></li><li><p>注意：</p><ul><li><p>进程是[程序J的「一次执行J</p></li><li><p>进程是一个程序及其数据在处理机上顺序执行时所发生的「活动」</p></li><li><p>进程是程序在一个「数据集合J」运行的过程</p></li><li><p>进程是系统进行「资源分配和调度J的- -个「独立」单位(或者说基本单位)</p></li></ul></li></ul></li><li><p>特征</p><ul><li><p>动态性:进程的实质是程序的一次执行过程</p><ul><li>进程是动态产生,动态消亡的,进程在其生命周期内,在3种基本状态之间转换</li></ul></li><li><p>并发性:任何进程都可以同其他进程一起向前推进</p></li><li><p>独立性:进程是一个能独立运行的基本单位,同时也是系统分配资源和调度的独立单位</p></li><li><p>异步性:由于进程间的相互制约,使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p></li></ul></li><li><p>三种状态</p><ul><li><p>就绪状态(Ready)</p><ul><li>进程已获得除CPU之外的所有必需的资源,一旦得到CPU控制权,立即可以运行</li></ul></li><li><p>运行状态(Running)</p><ul><li>进程已获得运行所必需的资源，它正在处理机上执行。</li></ul></li><li><p>阻塞状态(Blocked)</p><ul><li>正在执行的进程由于发生某事件而暂时无法执行时,便放弃处理机而处于暂停状态,称该进程处于阻塞状态或等待状态。</li></ul></li></ul></li><li><p>其他状态</p><ul><li><p>创建(New)</p><ul><li>为了保证进程的调度必须在创建工作完成后进行,同时为了增加管理的灵活性, OS可以根据系统性能或主存容量的限制,推迟创建状态进程的提交,产生进程的创建状态。</li></ul></li><li><p>终止( Terminated )</p><ul><li><p>进程到达自然结束点、出现无法克服的错误、被操作系统所终结</p></li><li><p>等待操作系统善后处理,将其PCB清零,将PCB空间返还系统</p></li></ul></li><li><p>挂起</p><ul><li><p>有的系统有时希望能人为地把进程挂起,使之处于静止状态,以便研究其执行情况或对它进行修改。</p></li><li><p>挂起:把进程从内存转向外存</p></li><li><p>引入挂起操作的原因</p><ul><li><p>终端用户的请求。</p></li><li><p>父进程请求。</p></li><li><p>负荷调节的需要。</p></li><li><p>操作系统的需要。</p></li></ul></li></ul></li><li><p>激活</p><ul><li>对应挂起</li></ul></li></ul></li><li><p><img src="/img/images/2023-01-23-14-34-25-image.png" srcset="/img/loading.gif" lazyload></p></li></ul><h3 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h3><ul><li><p>操作系统中，对每个资源和每个进程都设置了-个数据结构,用于表征其实体,称之为:资源信息表和进程信息表。</p></li><li><p>OS管理的这些数据结构分为四类:内存表、设备表、文件表、进程表。</p></li></ul><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>PCB的作用是使一个在多道程序环境下不能独立运行的程序(含数据) ,成为一个能独立运行的基本单位, 一个能与其他进程并发执行的进程</p><p><mark>PCB是进程存在的唯一标志</mark></p><ul><li><p>作用</p><ul><li><p>作为独立运行基本单位的标志。</p></li><li><p>能实现间断性运行方式。</p></li><li><p>提供进程管理所需要的信息。</p></li><li><p>提供进程调度所需要的信息。</p></li><li><p>实现与其它进程的同步与通信。</p></li></ul></li><li><p>内容</p></li><li><table><thead><tr><th>类型</th><th>内容</th><th>作用</th></tr></thead><tbody><tr><td>标识信息</td><td>1 )外部标识为方便用户<br>2 )内部标识为方便系统</td><td>标识一个进程</td></tr><tr><td>处理机状态(现场信息 )</td><td>1 ) CPU通用&#x2F;指令寄存器<br>2 ) CPU程序状态字PSW<br>3 )用户栈指针</td><td>记录处理机现场信息,以备恢复之用</td></tr><tr><td>调度信息</td><td>1 )进程状态<br>2 )进程优先级<br>3 )调度所需信息<br>4)事件</td><td>用户进程的调度管理</td></tr><tr><td>控制信息</td><td>1 )程序和数据地址<br>2 )进程同步和通信机制<br>3 )资源清单<br>4 )指向下一个进程的指针</td><td>用于进程的控制管理</td></tr></tbody></table></li><li><p>组织方式</p><ul><li><p>线性方式：即将系统中所有的PCB都组织在一张线性表中,将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小,但每次查找时都需要扫描整张表,因此适合进程数目不多的系统</p></li><li><p>链接方式：把具有同一状态的PCB用其中的链接字链接成一个队列。</p><ul><li><p>就绪队列</p></li><li><p>若干个堵塞队列</p></li></ul></li><li><p>索引方式：系统根据所有进程的状态建立几张索引表,把各表的内存首地址记录在内存的专用单元中。索引表的表目中记录了相应状态的某个PCB在PCB表中的地址。</p></li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制是对系统中所有进程从产生、存在到消亡的全过程实行有效的管理和控制。<br>进程控制一般是由操作系统的内核来实现,内核在执行操作时,往往是通过执行各种原语操作来实现的。</p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ul><li><p>功能</p><ul><li><p>支撑功能</p><ul><li><p>中断管理</p></li><li><p>时钟管理</p><ul><li><p>计时</p></li><li><p>时钟中断</p></li></ul></li><li><p>原语操作</p><ul><li><p>由若干条指令组成</p></li><li><p>用来完成某个特定功能</p></li><li><p>执行过程不会中断</p></li></ul></li></ul></li><li><p>资源管理功能</p><ul><li><p>进程管理</p></li><li><p>存储器管理</p></li><li><p>设备管理</p></li></ul></li></ul></li><li><p>进程控制</p><ul><li><p>原语种类</p><ul><li><p>进程创建原语</p></li><li><p>进程撤销原语</p></li><li><p>阻塞原语</p></li><li><p>唤醒原语</p></li><li><p>挂起原语</p></li><li><p>激活原语</p></li></ul></li><li><p>控制过程</p><ul><li><p>更新PCB中的信息(如修改进程状态标识、将运行环境保存到PCB、从<br>PCB恢复运行环境)<br>➢所有的进程控制原语一定会修改进程状态标志<br>➢剥夺当前运行进程的CPU使用权必然需要保存其运行环境(玩游戏的存档)<br>➢某进程开始运行钱必然要恢复运行环境(玩游戏的读档)</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配&#x2F;回收资源</p></li></ul></li></ul></li></ul><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul><li><p>层次结构</p><ul><li><p>在OS中允许一个进程创建另-个进程,通常把创建进程的进程称为父进程,而把被创建的进程称为子进程。</p></li><li><p>在UNIX中子进程可继续创建更多的孙进程,由此便形成了- -个进程的层次<br>结构。</p><ul><li><p>子进程可以继承父进程所拥有的资源，</p></li><li><p>当子进程被撤消时,应将其从父进程那里获得的资源归还给父进程。</p></li><li><p>在撤消父进程时,也必须同时撤消其所有的子进程。</p></li></ul></li><li><p>Windows中不存在任何进程层次结构的概念</p></li></ul></li><li><p>引起创建进程的事件</p><ul><li><p>用户登录</p></li><li><p>作业调度</p></li><li><p>提供服务</p></li><li><p>应用请求</p></li></ul></li><li><p>创建过程</p><ul><li><p>申请进程标识,即申请空白PCB</p></li><li><p>为新进程分配内存和其它资源</p></li><li><p>初始化进程控制块</p></li><li><p>将创建的进程置于就绪队列</p></li></ul></li></ul><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ul><li><p>引起进程终止的事件</p><ul><li><p>正常:</p><ul><li>任务完成&#x3D;&gt; halt&#x2F; logs off指令&#x3D;&gt;中断</li></ul></li><li><p>异常:</p><ul><li><p>访问控制(存储越界、资源访问越界、指令越界)</p></li><li><p>运行超时、等待超时</p></li><li><p>被禁止的运算</p></li><li><p>I&#x2F;O错误等</p></li></ul></li><li><p>外界干预:</p><ul><li><p>OS或用户干预</p></li><li><p>父进程请求</p></li><li><p>父进程终止</p></li></ul></li></ul></li><li><p>终止过程</p><ul><li><p>根据被终止进程的标识符,从PCB集合中检索出该进程的PCB ,从中读出该进程的状态</p></li><li><p>若被终止进程正处于执行状态,应立即终止该进程的执行,并置调度标志为真，用于指示该进程被终止后应重新进行调度;</p></li><li><p>若该进程还有子孙进程,还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程;</p></li><li><p>将被终止进程所拥有的全部资源或者归还给其父进程,或者归还给系统;</p></li><li><p>将被终止进程( PCB )从所在队列(或链表)中移出,等待其它程序来搜集信息。</p></li></ul></li></ul><h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><ul><li><p>引起的事件</p><ul><li><p>请求资源失败(如临界资源被占用，属于内部同步)</p></li><li><p>等待某种操作完成(如磁盘l&#x2F;O操作,属于内部同步)</p></li><li><p>等待新数据的到来(如多进程协作时，属于外部同步)</p></li><li><p>等待新任务(如Deamon服务进程，属于外部同步)</p></li></ul></li><li><p>进程的阻塞( block原语)</p><ul><li><p>进程停止执行</p></li><li><p>状态改为“阻塞”</p></li><li><p>进程被插入阻塞队列</p></li></ul></li><li><p>进程的唤醒( wakeup原语)</p><ul><li><p>状态改为“就绪”</p></li><li><p>进程被插入就绪队列</p></li></ul></li></ul><h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><h4 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h4><p>当出现了引起进程挂起的事件时，比如,用户进程请求将自己挂起,或父进程请求将自己的某个子进程挂起，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。<br>挂起原语的执行过程:</p><ul><li><p>检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程,则将之改为静止阻塞。</p></li><li><p>把该进程的PCB插入相应的挂起队列上,将程序段、数据段移除内存。最后,若被挂起的进程正在执行,则转向调度程序重新调度。</p></li></ul><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><ul><li><p>当发生激活进程的事件时,若该进程驻留在外存而内存中已有足够的空间时,则可将在外存上处于静止就绪状态的进程换入内存。</p></li><li><p>系统将利用激活原语active( )将指定进程激活。</p></li><li><p>激活过程:</p><ul><li><p>先将进程从外存调入内存,检查该进程的现行状态,若是静止就绪,便将之改为活动就绪;若为静止阻塞便将之改为活动阻塞。</p></li><li><p>假如采用的是抢占调度策略,则每当有新进程进入就绪队列时,应检查是否要进行重新调度,即由调度程序将被激活进程与当前进程进行优先级的比较,如果被激活进程的优先级更低,就不必重新调度;否则,立即剥夺当前进程的运行,把处理机分配给刚被激活的进程。</p></li></ul></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p><strong>引入进程的好处</strong>：支持多道程序并发,提高资源利用率<br><strong>引入进程的缺点</strong>：系统更复杂,破坏了程序运行的封闭性和不可再现性</p><p><strong>引入进程同步</strong>：对多个进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源,并能相互协作,使得程序的执行具有可再现性</p><ul><li><p>两种形式的制约关系</p><ul><li><p>间接相互制约：多个进程只能互斥执行</p><ul><li><p>互斥：对某个系统资源，多个进程不能同时使用</p></li><li><p>临界资源：一段时间内只允许一个进程访问的资源</p></li><li><p>问题</p><ul><li>死锁</li></ul></li></ul></li><li><p>直接相互制约：多个进程之间相互合作共同完成一件事</p></li></ul></li><li><p>临界区：进程中访问临界资源的那段代码</p><ul><li><p>访问临界区的程序设计为:</p><ul><li><p>对欲访问的临界资源进行检查,</p></li><li><p>若此刻未被访问,设正在访问的标志——进入区</p></li><li><p>访问临界资源——临界区</p></li><li><p>将正在访问的标志恢复为未被访问的标志——退出区</p></li><li><p>其余部分——剩余区</p></li></ul></li></ul></li><li><p>同步机制应遵循的规则</p><ul><li><p>空闲让进:当无进程在临界区时,任何有权使用临界区的进程可进入。</p></li><li><p>忙则等待:不允许两个以上的进程同时进入临界区。</p></li><li><p>有限等待:任何进入临界区的要求应在有限的时间内得到满足。</p></li><li><p>让权等待:处于等待状态的进程应放弃占用CPU ,以使其他进程有机会得到CPU的使用权。</p></li></ul></li></ul><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><ul><li><p>关中断法(开关中断指令)也称为”硬件锁”, 是实现互斥最简单的方法。</p><ul><li><p>做法:在进入锁测试之前关闭中断,直到完成锁测试并上锁之后才能打开中断。这样,进程在临界区执行期间,计算机系统不响应中断,从而不会引发调度,也就不会发生进程或线程切换。由此,保证了对锁的测试和关锁操作的连续性和完整性,有效地保证了互斥。</p></li><li><p>缺点:</p><ul><li><p>滥用关中断权力可能导致严重后果;</p></li><li><p>关中断时间过长,会影响系统效率,限制了处理器交叉执行程序的能力;</p></li><li><p>关中断方法也不适用于多CPU系统,因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</p></li></ul></li></ul></li><li><p>利用Test and Set指令实现互斥</p><ul><li><p>做法：这是一种借助一条硬件指令一-‘ 测试并建立”指令TS(Test- and-Set)以实<br>现互斥的方法。在许多计算机中都提供了这种指令。</p></li><li><p>缺点：</p><ul><li>不符合“让权等待”原则</li></ul></li></ul></li><li><p>利用swap指令实现线程互斥</p><ul><li><p>缺点：</p><ul><li>不符合”让权等待“原则</li></ul></li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>1965年荷兰Dijkstra提出的信号量( Semaphores )是-种卓有成效的进程同步工具,在长期的应用中,得到了很大的发展,从整型信号量经过记录型信号量,进而发展为”信号量集”机制。</p><ul><li><p>优点</p><ul><li><p>信号量就是OS提供的管理公有资源的有效手段。</p></li><li><p>信号量代表可用资源实体的数量。</p></li></ul></li></ul><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><ul><li><p>定义:把整型信号量定义为-个用于表示资源数目的整型量S ,除初始化外仅能通过两个原子操作wait(S),signal(S)来访问</p></li><li><p>原子操作P :</p><ul><li><p>荷兰语”proberen”一-“检测” 之意。意味着请求分配一个单位资源</p></li><li><p>wait(S)</p></li></ul></li><li><p>原子操作V :</p><ul><li><p>荷兰语“verhogen”一- “增量”之意，意味着释放一个单位资源</p></li><li><p>signal(S)</p></li></ul></li></ul><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><ul><li><p>在信号量机制中，除了需要一个用于代表资源数目的整型变量value外 ,还应增加一个进程链表L，用于链接上述的所有等待进程。</p></li><li><p>记录型信号量是由于它采用”了记录型的数据结构而得名的。</p></li></ul><h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><ul><li><p>AND同步机制的基本思想是:将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程,待进程使用完后再一起释放。</p></li><li><p>只要尚有一个资源未能分配给进程,其它所有可能为之分配的资源,也不分配给他。</p></li><li><p>在wait操作中,增加了一个”AND”条件,故称为AND同步,或称为同时wait操作。</p></li></ul><h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><ul><li><p>一次申请多个单位的临界资源</p></li><li><p>资源数量低于预设下限值时不予分配</p></li><li><p><img src="/img/images/2023-01-23-15-45-35-image.png" srcset="/img/loading.gif" lazyload></p></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>利用信号量实现进程互斥</p><ul><li>为使多个进程互斥的访问某临界资源,须为该资源设置一互斥信号量mutex ,并设其初始值为1 ,然后将各进程访问资源的临界区CS置于wait(mutex)和signal(mutex)之间即可。</li></ul></li><li><p>利用信号量实现前驱关系</p><ul><li>希望S1→S2 ,只需使进程P1和P2共享一个公用信号量S&#x3D;0 ,将signal(S)放在语句S1后,将wait(S)放在语句S2前。</li></ul></li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul><li><p>信号量的缺点</p><ul><li><p>同步操作分散:信号量机制中,同步操作分散在各个进程中,使用不当就可能导致各进程死锁(如P、V操作的次序错误、重复或遗漏) ;</p></li><li><p>易读性差:要了解对于一组共享变量及信号量的操作是否正确,必须通读整个系统</p></li></ul></li><li><p>管程的优点</p><ul><li>把分散在各进程中的临界区集中起来进行管理,并把系统中的共享资源用数据结构抽象地表示出来。由于临界区是访问共享资源的代码段,建立一个“秘书”程序管理来到的访问。”秘书” 每次仅让一个进程来访,这样既便于对共享资源的管理，又实现了互斥访问。</li></ul></li></ul><p>管程是由若干个公共变量和所有访问这些变量的过程所组成的一个特殊的模块或软件包</p><ul><li><p>基本思想:</p><ul><li>集中管理各进程中的临界区:管程把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理。</li></ul></li><li><p>特点</p><ul><li><p>管程的局部变量只能由该管程的过程存取;</p></li><li><p>系统保证进程只能互斥地调用管程中的过程。</p></li></ul></li><li><p>条件变量</p><ul><li>管程中对每个条件变量,都须予以说明, 其形式为: condition x, y。该变<br>量应置于wait和signal之前,即可表示为X.wait和X.signal。</li></ul></li><li><p>特征</p><ul><li><p>模块化: 一个管程是一个基本程序单位，可以单独编译;</p></li><li><p>抽象数据类型:管程是一种特殊的数据类型,其中不仅有数据,而且有对数据进行操作的代码,是对数据和操作的封装。</p></li><li><p>信息掩蔽:管程如何实现其功能相对于外部程序是半透明的。</p></li></ul></li><li><p>优点</p><ul><li><p>安全性:共享变量外部不可见，只能由管程中的操作存取;</p></li><li><p>互斥性:管程在任何一个时刻只能有一个进程进入;</p></li><li><p>等待机制:设置有等待队列及相应的操作，对资源进行管理。</p></li></ul></li><li><p>管程和进程的区别</p><ul><li><p>设置目的不同:管程是对共享资源进行管理,进程是资源分配和执行的基本单位。</p></li><li><p>数据结构不同:管程定义公用数据结构,进程定义私有数据结构PCB。</p></li><li><p>存在方式不同:进程有生命周期，管程是操作系统固有的部分,没有生命周期。</p></li><li><p>执行方式不同:管程被进程调用,没有并发性,进程具有并发执行性。</p></li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><ul><li><p>模式：</p><ul><li><p>共享数据结构</p><ul><li><p>进程公用某些数据结构,借以实现诸进程间的信息交换。</p></li><li><p>实现:公用数据结构的设置及对进程间同步的处理,都是程序员的职责。操作系统提供共享存储器</p></li><li><p>特点:低效。只适合传递相对少量的数据。</p></li></ul></li><li><p>共享存储区</p><ul><li>在存储器中划出一块共享存储区,诸进程可通过对共享存储区中数据的读或写<br>来实现通信。</li></ul></li></ul></li></ul><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><ul><li><p>管道:指用于连接-个读进程和一个写进程以实现他们之间通信的一个打开的共享文件,又名pipe文件。</p></li><li><p>管道只能采取半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,则需要设置两个管道各个进程要互斥的访问管道</p></li><li><p>数据以字节流的形式写入管道,当管道写满时,写进程的write()系统调用将会被阻塞,等待读进程将数据取走。当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将会被阻塞</p></li></ul><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><ul><li><p>用格式化消息封装所需传输的数据,消息长度可以固定,也可以变化。</p></li><li><p>直接利用系统提供的一组通信命令(原语)进行通信。</p></li><li><p>操作系统隐藏了通信的实现细节,大大减化了通信程序编制的复杂性</p></li><li><p>应用广泛:微内核、多处理机系统、分布式系统、计算机网络等</p></li><li><p>消息传递系统的通信方式属于高级通信方式。又因其实现方式的不同而进一步分成</p><ul><li><p>直接通信方式</p><ul><li><p>发送进程利用OS提供的发送命令,直接把消息发送给目标进程。发送进程和接收进程都以显式方式提供对方的标识符。</p></li><li><p>通信原语:</p><ul><li><p>Send(Receiver, message);发送一个消息给接收进程</p></li><li><p>Receive(Sender, message);接收Sender发来的消息</p></li></ul></li></ul></li><li><p>间接通信方式。</p><ul><li><p>信箱用来暂存发送进程发送给目标进程的消息,接收进程则从信箱中取出发送给自己的消息。</p></li><li><p>消息在信箱中可安全保存,只允许核准的目标用户随时读取</p></li><li><p>利用信箱通信方式,既可实时通信,又可非实时通信。</p></li><li><p>通信原语:</p><ul><li><p>Send (MailBox, Message) ;</p></li><li><p>Receive (MailBox, Message) ;</p></li></ul></li><li><p>信箱可由操作系统创建,也可由用户进程创建,创建者是信箱的拥有者。</p></li><li><p>信箱分类:</p><ul><li><p>私用信箱</p></li><li><p>公用信箱</p></li><li><p>共享信箱</p></li></ul></li></ul></li></ul></li></ul><h3 id="客户-服务器系统"><a href="#客户-服务器系统" class="headerlink" title="客户-服务器系统"></a>客户-服务器系统</h3><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><ul><li><p>进程的两个基本属性:</p><ul><li><p>进程是一个可拥有资源的独立单位</p></li><li><p>进程同时又是一个可独立调度和分派的基本单位。</p></li></ul></li><li><p>为使程序能并发执行,系统还必须进行以下的一系列操作。</p><ul><li><p>创建进程</p></li><li><p>撤消进程</p></li><li><p>进程切换</p></li><li><p>这样系统必须为之付出较大的时空开销。因此应分开进程的两个属性。即对于作为调度和分派的基本单位,不同时作为拥有资源的单位，以”轻装上阵”,反之亦然。</p></li></ul></li><li><p>进程切换过程</p><ul><li><p>切换页目录以使用新的地址空间</p></li><li><p>切换内核栈和硬件上下文</p></li></ul></li></ul><h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p>线程(thread)是一个可执行的实体单元。<mark>它代替以往的进程,成为现代操作系统中处理机调度的基本单位。</mark></p><ul><li><p>特性</p><ul><li><p>调度的基本单位</p><ul><li><p>同一进程中的线程切换不会引起进程切换</p></li><li><p>不同进程中的线程切换必然引起进程切换</p></li></ul></li><li><p>并发性</p></li><li><p>拥有资源</p></li><li><p>独立性</p></li><li><p>系统开销</p></li><li><p>支持多处理机系统</p></li></ul></li><li><p>线程运行的三个状态</p><ul><li><p>执行状态,表示线程正获得处理机而运行;</p></li><li><p>就绪状态，指线程已具备了各种执行条件, 一旦获得CPU便可执行的状态;</p></li><li><p>阻塞状态,指线程在执行中因某事件而受阻,处于暂停执行时的状态。</p></li></ul></li><li><p>线程控制块TCB</p><ul><li><p>线程标识符;</p></li><li><p>组寄存器，它包括程序计数器PC、状态寄存器和通用寄存器;</p></li><li><p>线程运行状态,用于描述线程正处于何种运行状态;</p></li><li><p>优先级，描述线程执行的优先程度;</p></li><li><p>线程专有存储区，用于线程切换时存放现场保护信息,和相关统计信息;</p></li><li><p>信号屏蔽，即对某些信号加以屏蔽。</p></li><li><p>堆栈,用来保存局部变量和返回地址。</p><ul><li>用户栈和核心栈</li></ul></li></ul></li><li><p>用户级线程</p><ul><li><p>定义</p><ul><li><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能,都无须利用系统调用来实现。</p></li><li><p>对于用户级线程的切换,通常是发生在一个应用进程的诸多线程之间,无须内核的支持。</p></li><li><p>切换的规则远比进程调度和切换的规则简单</p></li></ul></li><li><p>实现</p><ul><li><p>用于管理和控制线程的函数(过程)的集合,其中包括用于创建和撤消线程的函数、线程同步和通信的函数以及实现线程调度的函数等<br>➢pthread_ creat , pthread_ exit , pthread_ join , pthread_ yield</p></li><li><p>运行时系统中的所有函数都驻留在用户空间,并作为用户级线程与内核之间的接口。</p></li></ul></li><li><p>优点</p><ul><li><p>线程切换不需要转换到内核空间</p></li><li><p>调度算法可以是进程专用的</p></li><li><p>用户级线程的实现与OS平台无关</p></li><li><p>用户线程不占用内核内存,本身的内核空间开销也更小一些,可以节约资源</p></li></ul></li><li><p>缺点</p><ul><li><p>系统调用的阻塞问题。当线程执行一个系统调用时,不仅该线程被阻塞,而且,进程内的所有线程会被阻塞。而在内核支持线程方式中则进程中的其它线程仍然可以运行。</p></li><li><p>在单纯的用户级线程实现方式中,多线程应用不能利用多处理机进行多重处理的优点,内核每次分配给一个进程的仅有一个CPU ,因此,进程中仅有一个线程能执行,在该线程放弃CPU之前,其它线程只能等待。</p></li></ul></li></ul></li><li><p>内核支持线程KST</p><ul><li><p>定义</p><ul><li><p>在内核的支持下运行的，即无论是用户进程中的线程,还是系统进程中的线程,他,们的创建、撤消和切换等,也是依靠内核实现的。</p></li><li><p>在内核空间还为每一个内核支持线程设置了一 个线程控制块 ,内核是根据该控制块而感知某线程的存在的,并对其加以控制。</p></li></ul></li><li><p>实现</p><ul><li>在支持线程的OS中,系统在创建进程时,便为他分配一个任务数据区,包括若干线程控制块空间。</li></ul></li><li><p>优点</p><ul><li><p>在多处理器系统中,内核能够同时调度同-进程的多个线程并行执行。</p></li><li><p>一个线程被阻塞,内核可以调度该进程的其它线程运行,也可以运行其它进程中的线程。</p></li><li><p>线程切换比较快,开销小。</p></li><li><p>内核本身也可以采用多线程技术,提高执行速度和效率</p></li></ul></li><li><p>缺点</p><ul><li>在同一进程间的线程控制权转移时,用户级与核心级的切换开销很大。</li></ul></li></ul></li><li><p>组合方式</p><ul><li><p>内核支持多线程的建立、调度和管理,同时,也允许用户应用程序建立、调度和管理用户级线程。</p></li><li><p>这种方式能够结合两者的优点,克服其各自的不足。</p></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="categories/课程笔记/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="tags/OS/">#OS</a></div></div><div class="license-box my-3"><div class="license-title"><div>操作系统复习 第二章</div><div>2023/02/07/subject/operate_system/chapter2/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>charlesix59</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/02/07/subject/operate_system/chapter3/" title="操作系统复习 第三章"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统复习 第三章</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="2023/02/07/subject/operate_system/chapter1/" title="操作系统复习 第一章"><span class="hidden-mobile">操作系统复习 第一章</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.5.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.5.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://hexo-comment-qncm4vegj-charlesix59.vercel.app/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/bilibili"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class=":" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">create by Charles Min at 2022 @CopyRight</div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/about/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?charlesix59",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"charlesix59")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style>#github_container>.position-relative>.border{border:0!important}#github-calendar{position:relative;margin-top:-2rem;background-color:var(--board-bg-color);transition:background-color .2s ease-in-out;border-radius:.5rem;z-index:3;-webkit-box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%)}</style></body></html>