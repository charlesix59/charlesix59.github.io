<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon.png"><link rel="icon" href="/images/icon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="charlesix59"><meta name="keywords" content=""><meta name="description" content="第三章 处理机调度与死锁处理机调度的层次 进程:是一个程序对某个数据集的执行过程,是分配资源的基本单位。  作业:是用户需要计算机完成的某项任务,是要求计算机所做工作的集合  一个作业通常包括几个进程,几个进程共同完成一个任务,即作业。  用户提交作业以后,当作业被调度，系统会为作业创建进程, 一个进程无法完成时,系统会为这个进程创建子进程。  作业的概念更多地用在批处理系统中。  进程的概念几乎"><meta property="og:type" content="article"><meta property="og:title" content="操作系统复习 第三章"><meta property="og:url" content="2023/02/07/subject/operate_system/chapter3/index.html"><meta property="og:site_name" content="茶理的私人博客"><meta property="og:description" content="第三章 处理机调度与死锁处理机调度的层次 进程:是一个程序对某个数据集的执行过程,是分配资源的基本单位。  作业:是用户需要计算机完成的某项任务,是要求计算机所做工作的集合  一个作业通常包括几个进程,几个进程共同完成一个任务,即作业。  用户提交作业以后,当作业被调度，系统会为作业创建进程, 一个进程无法完成时,系统会为这个进程创建子进程。  作业的概念更多地用在批处理系统中。  进程的概念几乎"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="/img/images/2023-01-25-11-09-07-image.png"><meta property="og:image" content="/img/images/2023-01-25-11-54-57-image.png"><meta property="og:image" content="/img/images/2023-01-26-10-16-34-image.png"><meta property="og:image" content="/img/images/2023-01-26-11-05-56-image.png"><meta property="article:published_time" content="2023-02-07T05:32:46.000Z"><meta property="article:modified_time" content="2023-02-07T06:07:58.656Z"><meta property="article:author" content="charlesix59"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="/img/images/2023-01-25-11-09-07-image.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>操作系统复习 第三章 - 茶理的私人博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script type="text/javascript" src="/js/love.js"></script><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"https:/charlesix59.github.io",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><script type="text/javascript" color="0,160,230" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>茶理的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="操作系统复习 第三章"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-07 13:32" pubdate>2023年2月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 80 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统复习 第三章</h1><div class="markdown-body"><h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><ul><li><p>进程:是一个程序对某个数据集的执行过程,是分配资源的基本单位。</p></li><li><p>作业:是用户需要计算机完成的某项任务,是要求计算机所做工作的集合</p></li><li><p>一个作业通常包括几个进程,几个进程共同完成一个任务,即作业。</p></li><li><p>用户提交作业以后,当作业被调度，系统会为作业创建进程, 一个进程无法完成时,系统会为这个进程创建子进程。</p></li><li><p>作业的概念更多地用在批处理系统中。</p></li><li><p><mark>进程的概念几乎可以用在所有的多道程序系统中</mark>。</p></li></ul><p><mark>调度</mark>是多道程序的关键</p><p><strong>调度算法的目标：</strong></p><ul><li><p>提高资源利用率</p></li><li><p><strong>公平性</strong>。公平性是指应使诸进程都获得合理的CPU时间,不会发生进程<br>饥饿现象。</p></li><li><p><strong>平衡性</strong>。由于在系统中可能具有多种类型的进程,有的属于计算型作业,<br>有的属于I&#x2F;O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态,<br>调度算法应尽可能保持系统资源使用的平衡性。</p></li><li><p><strong>策略强制执行</strong>。对所制订的策略其中包括安全策略,只要需要,就必须<br>予以准确地执行,即使会造成某些工作的延迟也要执行。</p></li></ul><p><strong>批处理系统的目标</strong>：</p><ul><li><p>平均周转周期更短</p><ul><li><p>周转时间&#x3D;作业完成时间-作业到达时间</p></li><li><p>平均周转时间&#x3D;作业周转总时间&#x2F;进程个数</p></li><li><p>带权周转时间:即作业的周转时间T与系统为它提供服务的时间T,之比,即.W &#x3D; T&#x2F;Ts。</p><ul><li>可进一步反映调度的性能,更清晰地描述各进程在其周转时间中,等待和执行时间的具体分配状况.</li></ul></li></ul></li><li><p>系统吞吐量高</p><ul><li><p>由于吞吐量是指在单位时间内系统所完成的作业数</p></li><li><p>它与批处理作业的平均长度有关</p></li><li><p>如果单纯是为了获得高的系统吞吐量,就应尽量多地选择短作业运行。</p></li></ul></li><li><p>处理机利用率高</p><ul><li>如果单纯是为使处理机利用率高,应尽量多地选择计算量大的作业运行</li></ul></li></ul><p><strong>分时系统的目标</strong>：</p><ul><li><p>响应时间快</p><ul><li>响应时间指用户提交请求到系统首次响应为止的时间。</li></ul></li><li><p>均衡性。</p><ul><li>系统响应时间的快慢应与用户所请求的复杂性相适应。</li></ul></li></ul><p><strong>实时系统的目标</strong>：</p><ul><li><p>截止时间的保证</p><ul><li><p>开始执行的最迟时间</p></li><li><p>必须完成的最迟时间。</p></li></ul></li><li><p>可预测性</p></li></ul><h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li><p>作业(Job)</p><ul><li><p>用户提交给计算机系统的任务。</p></li><li><p>由程序、数据、作业说明书组成。</p></li></ul></li><li><p>作业步(Job Step)</p><ul><li><p>作业执行期间所经历在加工步骤。</p></li><li><p>典型的作业控制过程分:“编译” “ 链接装配“ ”运行“</p></li></ul></li><li><p>作业控制块(Job Control Block , JCB)</p><ul><li><p>作业控制块是批处理作业存在的标志,保存有系统对于作业进行管理所需要的全部信息,位于磁盘区域中</p></li><li><p>作业开始,系统输入程序为其建立一个作业控制块,进行初始化,大部分信息取自作业说明书。</p></li><li><p>系统输入程序、作业调度程序、作业控制程序、系统输出程序等需要访问作业控制块。</p></li><li><p>作业完成后,其作业控制块由系统输出程序撤消。</p></li><li><p><img src="/img/images/2023-01-25-11-09-07-image.png" srcset="/img/loading.gif" lazyload></p></li></ul></li></ul><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><ul><li><p>先来先服务算法（First Come First Serve）</p><ul><li><p>FCFS是最简单的调度算法,该算法既可用于作业调度,也可用于进程调度。</p></li><li><p>基本原则是按照作业到达系统的先后次序来选择,或者说它是优先考虑在系统中等待时间最长的作业,而不管该作业所需执行时间的长短。</p></li></ul></li><li><p>短作业优先（Short Job First）调度算法</p><ul><li><p>对短作业或短进程优先调度的算法。可以分别用于作业调度和进程调度。</p></li><li><p>SJF算法是以作业的长短来计算优先级,作业越短,其优先级越高。</p></li><li><p>SJF调度算法:从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p></li><li><p>缺点</p><ul><li><p>(1)必须预知作业的运行时间。</p></li><li><p>(2)对长作业非常不利,长作业的周转时间会明显地增长，更严重的是,该算法<br>完全忽视作业的等待时间,可能使作业等待时间过长,出现饥饿现象。</p></li><li><p>(3)在采用SJF算法时,人一机无法实现交互。</p></li><li><p>(4)该调度算法完全未考虑作业的紧迫程度,故不能保证紧迫性作业能得到及时处理。</p></li></ul></li></ul></li><li><p>优先级调度算法（Priority-Scheduling Algorithm）</p><ul><li>反应作业的紧迫性</li></ul></li><li><p>高响应比优先调度算法</p><ul><li><p>高响应比优先调度算法则是既考虑了作业的等待时间,又考虑作业运行时间的调度算法,因此既照顾了短作业,又不致使长作业的等待时间过长,从而改善了处理机调度的性能</p></li><li><p>为每个作业引入一个动态优先级,即优先级是可以改变的，令它随等待时间延长而增加,这将使长作业的优先级在等待期间不断地增加,等到足够的时间后,必然有机会获得处理机。该优先级的变化规律可描述为:</p><p>$$<br>优先权&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p></li></ul></li><li><p>由于等待时间与服务时间之和就是系统对该作业的响应时间,故该优先级又相当于响应比RP。据此,优先又可表示为:</p><p>$$<br>R_p&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}&#x3D;\frac{响应时间}{要求服务时间}<br>$$</p></li><li><p>特点</p><ul><li><p>(1)如果作业的等待时间相同,则要求服务的时间愈短,其优先权愈高,<br>因而该算法有利于短作业。</p></li><li><p>(2)当要求服务的时间相同时,作业的优先权决定于其等待时间,等待时<br>间愈长,其优先权愈高,因而它实现的是先来先服务。</p></li><li><p>(3)对于长作业,作业的优先级可以随等待时间的增加而提高，当其等待<br>时间足够长时,其优先级便可升到很高，从而也可获得处理机。</p></li></ul></li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul><li><p>任务</p><ul><li><p>保存处理机的现场信息。</p></li><li><p>按某种算法选取进程。</p></li><li><p>把处理器分配给进程。</p></li></ul></li><li><p>组成部分</p><ul><li><p>排队器</p></li><li><p>分派器</p></li><li><p>上下文切换器</p></li></ul></li><li><p>调度方式</p><ul><li><p>非抢占方式：</p><ul><li><p>处理机分配给某进程后,就一直让它运行下去,决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成,或发生某事件而被阻塞时,才把处理机分配给其它进程。</p></li><li><p>评价</p><ul><li><p>实现简单、系统开销小</p></li><li><p>适用于大多数的批处理OS ,但在分时系统和要求比较严格的实时系统中,不宜采用这种调度方式</p></li></ul></li></ul></li><li><p>抢占方式</p><ul><li><p>允许调度程序根据某种原则,去暂停某个正在执行的进程,将处理机重<br>新分配给另一进程。</p></li><li><p>在现代OS中广泛采用抢占方式,这是因为:</p><ul><li><p>对于批处理机系统,可以防止一-个长进程长时间地占用处理机,以确保处理机能为所有进程提供更为公平的服务。</p></li><li><p>在分时系统中,只有采用抢占方式才有可能实现人一机交互</p></li><li><p>在实时系统中,抢占方式能满足实时任务的需求。</p></li></ul></li><li><p>抢占原则</p><ul><li><p>优先权原则:优先权高的可以抢占优先权低的进程的处理机。</p></li><li><p>短作业(进程)优先原则:短作业(进程)可以抢占长作业(进程)的处理机。</p></li><li><p>时间片原则:各进程按时间片运行,一个时间片用完时,停止该进程执行重新进行调度。</p></li></ul></li></ul></li></ul></li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>轮转调度算法</p><ul><li><p>在分时系统中,为保证能及时响应用户的请求,必须采用基于时间片轮转式进程调度算法。</p></li><li><p>在早期,分时系统中采用的是简单的时间片轮转法</p><ul><li><p>系统将所有的就绪进程按FCFS策略排成一个就绪队列</p></li><li><p>系统可设置每隔一定时间(如30 ms)便产生一次中断,去激活进程调度程序进行调度,把CPU分配给队首进程,并令其执行一个时间片。</p></li><li><p>当它运行完毕后,又把处理机分配给就绪队列中新的队首进程,也让它执行一个时间片。</p></li><li><p>这样,就可以保证就绪队列中的所有进程在确定的时间段内,都能获得一个时间片的处理机时间。</p></li><li><p>在RR调度算法中,应在何时进行进程的切换,可分为两种情况:</p><ul><li><p>若一个时间片尚未用完,正在运行的进程便已经完成,就立即激活调度程序,将它从就绪队列中删除,再调度就绪队列中队首的进程运行,并启动一个新的时间片。</p></li><li><p>在一个时间片用完时,计时器中断处理程序被激活。如果进程尚未运行完毕,调度程序将把它送往就绪队列的末尾。</p></li></ul></li><li><p>时间片大小：</p><ul><li><p>如果太小利于短作业,但是会频繁中断,进程.上下文切换,增加系统开销;</p></li><li><p>如果太大则每个进程都能在时间片内完成,则退化为FCFS算法,无法满足交互式用户的需求。</p></li><li><p>一个比较可取的大小是,时间片略大于一次典型的交互所需要的时间。</p></li></ul></li></ul></li></ul></li><li><p>优先级调度算法</p><ul><li><p>优先级进程调度算法,是把处理机分配给就绪队列中优先级最高的进程。这时,又可进一步把该算法分成如下两种</p><ul><li><p>非抢占式优先级调度算法。</p></li><li><p>抢占式优先级调度算法。</p></li></ul></li><li><p>优先级类型</p><ul><li><p>静态优先级是在创建进程时确定的,在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的,例如0 ~ 255中的某一整数,又把该整数称为优先数。确定进程优先级大小的依据有如下三个:</p><ul><li><p>进程类型。</p></li><li><p>进程对资源的需求。</p></li><li><p>用户要求。</p></li></ul></li></ul></li><li><p>动态优先级</p><ul><li><p>动态优先级是指在创建进程之初,先赋予其-个优先级,然后其值随进程的推进或等待时间的增加而改变,以便获得更好的调度性能。</p><ul><li><p>若所有进程都具有相同的优先级初值,则最先进入就绪队列的进程会因其优先级变得最高,从而得到cpu ,等于FCFS。</p></li><li><p>若所有就绪进程具有各不相同的优先级初值,那么对于优先级初值低的进程,在等待了足够的时间后,也可以获得处理机。</p></li><li><p>也可以规定,当运行的进程随着运行时间的推移动态降低其优先级,防止一个进程长期垄断cpu。</p></li></ul></li></ul></li></ul></li><li><p>多队列调度算法</p><ul><li>在多处理机系统中可以为每个处理机设置一个单独的就绪队列</li></ul></li><li><p>多级反馈队列调度算法</p><ul><li><p>是时间片轮转算法和优先级调度算法的综合和发展,通过动态调整进程优先级和时间片大小,不必事先估计进程的执行时间。</p></li><li><p><mark>FCFS+优先级+RR+抢占</mark></p></li><li><p>多级反馈队列可兼顾多方面的系统目标,是目前公认的一种<mark>较好</mark>的进程调度算法</p></li><li><p>调度机制</p><ul><li><p>设置多个就绪队列并为各个队列赋予不同的优先级,第一个最高,依次降低。各个队列中进程执行时间片的大小设置为:优先权越高，时间片越短</p></li><li><p>每个队列都采用FCFS算法。当新进程进入内存后,首先将它放入第一队列的末尾,按FCFS原则等待调度。当轮到该进程执行时,如它能在该时间片内完成,便可撤离系统。否则,即它在一个时间片结束时尚未完成,调度程序将其转入第二队列的末尾等待调度;如果它在第二队列中运行一个时间片后仍未完成,再依次将它放入第三队列, …..<br>依此类推。当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。</p></li><li><p>按队列优先级调度。调度程序首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列中的进程运行;换言之,仅当第1~ (i-1)所有队列均空时,才会调度第队列中的进程运行。如果处理机正在第队列中为某进程服务时又有新进程进入任-优先级较高的队列,此时须立即把正在运行的进程放回到第队列的末尾,而把处理机分配给新到的高优先级进程。</p></li><li><p>注意</p><ul><li><p>当现行进程正在执行它的C P U周期时,如果发生了时间片中断或有进程进入更高级的就绪队列时将引起剥夺,对前一-种情况,现行进程将进入下一级队列,对后一种情况,现行进程则进入本级队列末尾。</p></li><li><p>当一进程被唤醒时,它进入的是原先离开的那个队列，即与其当前优先级对<br>应的就绪队列。</p></li><li><p>一个进程的优先级被降低,仅发生在因时间片中断而被剥夺的时候。</p></li></ul></li><li><p><img src="/img/images/2023-01-25-11-54-57-image.png" srcset="/img/loading.gif" lazyload></p></li></ul></li><li><p>多级反馈队列调度算法具有较好的性能,能较好的满足各种类用户的需要。</p><ul><li><p>终端型作业用户。大多属于较小的交互性作业,只要能使作业在第一队列的时间片内完成,便可令用户满意。</p></li><li><p>短批处理作业用户。周转时间仍然较短,至多在第二到三队列即可完成。</p></li><li><p>长批处理作业用户。将依次在1 ~ n级队列中轮转执行，不必担心作业长期得不到处理。</p></li></ul></li></ul></li><li><p>保证调度算法</p><ul><li><p>在系统中有n个相同类型的进程同时运行,为公平起见,须保证每个进程都获得相同的处理机时间1&#x2F;n。</p><ul><li><p>跟踪计算每个进程自创建以来已经执行的处理时间。</p></li><li><p>计算每个进程应获得的处理机时间,即自创建以来的时间除以n。</p></li><li><p>计算进程获得处理机时间的比率,即进程实际执行的处理时间和应获得的处理机时间之比。</p></li><li><p>比较各进程获得处理机时间的比率。如进程A的比率最低,为0.5 ,而进程B的比率为0.8 ,进程C的比率为1.2等。</p></li><li><p>调度程序应选择比率最小的进程将处理机分配给它,并让该进程一-直运行,直到超过最接近它的进程比率为止。</p></li></ul></li></ul></li><li><p>公平共享调度算法</p><ul><li><p>分配给每个进程相同的处理机时间，显然,这对诸进程而言,是体现了一定程度的公平,但如果各个用户所拥有的进程数不同,就会发生对用户的不公平问题。</p></li><li><p>用户1有4个进程A、B、C、D ,用户2只有一-个进程E。强制调度序列为:<br>A E B E C E D E A E B E C E D E</p></li><li><p>如果希望用户1所获得的处理机时间是用户2的2倍,则强制调度序列为:<br>A B E C D E A B E C D E</p></li></ul></li></ul><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实时调度的条件"><a href="#实时调度的条件" class="headerlink" title="实时调度的条件"></a>实时调度的条件</h3><ul><li><p>实时系统</p><ul><li><p>两种任务</p><ul><li><p>硬实时任务( HRT )指必须满足最后期限的限制,否则会给系统带来不可接受的破坏或者致命错误。</p></li><li><p>软实时任务( SRT)也有一个与之关联的最后期限,并希望能满足这个期限的要求,但这并不是强制的,即使超过了最后期限,调度和完成这个任务仍然是有意义的。</p></li></ul></li></ul></li><li><p>提供必要的信息</p><ul><li><p>就绪时间。</p></li><li><p>开始截止时间和完成截止时间。</p></li><li><p>处理时间。</p></li><li><p>资源要求。</p></li><li><p>优先级。</p></li></ul></li><li><p>系统处理能力强</p><ul><li>单处理机实时调度条件<ul><li>$$<br>\sum_{i+1}^{n}\frac{C_i}{P_i}\leq1<br>$$</li><li>其中C表示处理时间，P表示周期时间</li></ul></li><li>提高处理能力的途径<ul><li>采用单处理机系统,增强处理能力,减少每个任务处理时间;</li><li>采用多处理机调度</li><li>$$<br>\sum_{i+1}^{n}\frac{C_i}{P_i}\leq N<br>$$</li><li>N表示处理机个数</li></ul></li></ul></li><li><p>采用抢占式调度机制</p><ul><li>在含有硬实时任务的实时系统中，广泛采用抢占机制。</li><li>当一个优先权更高的任务到达时,允许将当前任务暂时挂起,令高优先权任务立即投入运行,这样可满足该硬实时任务对截止时间的要求。但此种机制较复杂。</li><li>对于一些小的实时系统,如果能预知任务的开始截止时间,则对实时任务的调度可采用非抢占调度机制,以简化调度程序和对任务调度时所花费的系统开销。</li></ul></li><li><p>具有快速切换机制</p><ul><li>为保证要求较高的硬实时任务能及时运行,在实时系统中还应具有快速切换机制,以保证任务的快速切换。需要以下两种能力:<ul><li>对外部中断的快速响应能力。要求系统具有快速硬件中断机构,使可在紧迫的外部事件请求中断时及时响应。</li><li>快速的任务分派能力。在完成任务调度后,便应进行任务切换,为提高速度,应使系统中的运行功能单位适当的小,以减少任务切换的时间开销。</li></ul></li></ul></li></ul><h3 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h3><ul><li><p>分类</p><ul><li><p>根据实时任务性质,可将实时调度的算法分为:</p><ul><li><p>硬实时调度算法</p></li><li><p>软实时调度算法</p></li></ul></li><li><p>按调度方式,则可分为:</p><ul><li><p>非抢占调度算法</p><ul><li><p>非抢占式轮转调度算法。</p></li><li><p>非抢占式优先调度算法。</p></li></ul></li><li><p>抢占调度算法</p><ul><li><p>基于时钟中断的抢占式优先级调度算法。</p></li><li><p>立即抢占(Immediate Preemption)的优先级调度算法。</p></li></ul></li></ul></li><li><p><img src="/img/images/2023-01-26-10-16-34-image.png" srcset="/img/loading.gif" lazyload></p></li></ul></li><li><p>最早截止时间优先（Earliest Deadline First）算法</p><ul><li><p>根据任务的截止时间来确定任务的优先级。截止时间越早,其优先级越高。</p></li><li><p>该算法要求在系统中保持一个实时任务就绪队列,该队列按各任务截止时间的早晚排序,调度程序在选择任务时总是选择就绪队列中的第一个任务,为之分配处理机,使之投入运行。</p></li><li><p>EDF算法既可以用于抢占式调度,也可用于非抢占式调度。</p></li></ul></li><li><p>最低松弛度优先（Least Lexity First）算法</p><ul><li><p>该算法是根据任务紧急(或松弛)的程度,来确定任务的优先级。任务的紧急程度越高,为之赋予的优先级就越高。</p></li><li><p>例如,任务A在200ms时必须完成,本身运行时间100ms ,则必须在100ms之前调度执行, A任务的紧急(松弛)程度为100ms ,又如任务B在400ms是必须完成,需运行150ms ,其松弛程度为250ms.</p></li><li><p>该算法主要用于抢占调度方式中。</p></li></ul></li><li><p>优先级倒置（Priority Inversion Problem）</p><ul><li><p>形成</p><ul><li>当前OS广泛采用优先级调度算法和抢占方式,然而在系统中存在着影响进程运行的资源而可能产生”优先级倒置”的现象,即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞</li></ul></li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3><p>死锁( Deadlock ) 是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时,若无外力作用,它们都将无法再向前推进。</p><table><thead><tr><th></th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法向前推进的现象。</td><td>1.一定是循环等待对方手里的资源导致的<br>2.至少有2个或2个以上进程同时发生<br>3.进程处于阻塞态<br>4.操作系统分配资源的策略不合理导致<br>5.是管理者（操作系统）的问题</td></tr><tr><td>饥饿</td><td></td><td>1.只能由一个进程发生饥饿<br>2.可能在阻塞态，也可能在就绪态<br>3.操作系统分配资源的策略不合理导致<br>4.是管理者（操作系统）的问题</td></tr><tr><td>死循环</td><td></td><td>1.可能只有一个<br>2.可以是运行态<br>3.由代码逻辑错误导致的<br>4.是被管理者的问题</td></tr></tbody></table><ul><li><p>资源</p><ul><li><p>可重用性资源</p><ul><li><p>每一个可重用性资源中的单元只能分配给一个进程使用,不允许多个进程共享。进程在使用可重用性资源时,须按照这样的顺序:</p><ul><li><p>请求资源</p></li><li><p>使用资源。</p></li><li><p>释放资源。</p></li></ul></li><li><p>系统中每一类可重用性资源中的单元数目是相对固定的,进程在运行期间既不能创建也不能删除它。</p></li></ul></li><li><p>可消耗性资源</p><ul><li><p>可消耗性资源又称为临时性资源,它是在进程运行期间,由进程动态地创建和消耗的,它具有如下性质:</p><ul><li><p>每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的,有时它可以有许多,有时可能为0 ;</p></li><li><p>进程在运行过程中,可以不断地创造可消耗性资源的单元,将它们放入该资源类的缓冲区中,以增加该资源类的单元数目。</p></li><li><p>进程在运行过程中,可以请求若干个可消耗性资源单元,用于进程自己<br>的消耗,不再将它们返回给该资源类中。</p></li></ul></li></ul></li><li><p>可抢占性资源(CPU、内存等)</p><ul><li>某进程在获得这类资源后,该资源可以再被其它进程或系统抢占。</li></ul></li><li><p>不可抢占性资源(打印机、磁带机等)</p><ul><li>一旦系统把某资源分配给该进程后,就不能将它强行收回,只能在进程用完后自行释放。</li></ul></li></ul></li><li><p>死锁原因</p><ul><li><p>竞争不可抢占性资源</p></li><li><p>竞争可消耗资源</p></li><li><p>进程推进顺序不当</p></li></ul></li><li><p>产生死锁的必要条件</p><ul><li><p>互斥条件</p></li><li><p>请求和保持条件</p></li><li><p>不可抢占条件</p></li><li><p>循环等待条件</p></li></ul></li></ul><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>预防死锁的方法是使四个必要条件中的第2、3、4条件之一不能成立来避免发生死锁。<br>必要条件1 ,因为它是由设备的固有条件所决定的,不仅不能改变,还应加以保证。、</p><ul><li><p>破坏请求和保持条件</p><ul><li><p>第一种协议</p><ul><li><p>系统规定所有进程在开始运行之前,都必须-次性的申请其在整个运行过程所需的全部资源。</p></li><li><p>优点:算法简单、易于实现且很安全。</p></li><li><p>缺点:资源浪费严重和使进程经常会发生饥饿现象。</p></li></ul></li><li><p>第二种协议</p><ul><li><p>进程提出申请资源前必须释放已占有的一切资源。</p></li><li><p>当一个已经保持了某些不可被抢占资源的进程,提出新的资源请求而不能得到满足时,它必须释放已经保持的所有资源,待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放,或者说是被抢占了,从而破坏了”不可抢占”条件。</p></li><li><p>缺点：实现起来比较复杂且付出很大代价。可能会前功尽弃,反复申请和释放等情况,延长了周转时间,增加系统开销。</p></li></ul></li></ul></li><li><p>破坏循环等待条件</p><ul><li><p>采用资源顺序分配法,可以破坏循环等待条件</p></li><li><p>采用资源顺序分配法,系统不会出现循环等待。因为在任何时刻,总有一个进程占有较高序号的资源,该进程继续请示的资源必然是空闲的。故该进程可一直向前推进。</p></li><li><p>优点:</p><ul><li>有序资源分配法提高了资源利用率</li></ul></li><li><p>缺点:</p><ul><li><p>不方便增加新的设备,因为可能需要重新分配所有编号</p></li><li><p>进程实际使用资源的顺序可能和编号递增顺序不一致,会导致资源浪费;</p></li><li><p>必须按规定申请资源,用户编程麻烦,</p></li></ul></li></ul></li></ul><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul><li><p>系统安全状态</p><ul><li><p>该方法允许进程动态地申请资源,系统在进行资源分配之前,先计算资源分配的安全性。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程;否则不分配资源,进程必须阻塞等待。从而避免发生死锁。</p></li><li><p>安全状态:在此状态系统能按某种顺序P1, P2… Pn来为各个进程分配其所需资源,使每个进程都可顺序地一个个地完成。这个序列{P1,P….Pn}称为安全序列。</p></li><li><p>不安全状态:系统不存在任何一个安全序列</p></li></ul></li><li><p>银行家算法</p><ul><li><p>银行家算法的数据结构</p><ul><li><p>可利用资源向量Available [m]</p><ul><li>m为系统中资源种类数, Available[j] &#x3D;k表示系统中第j类资源数为k个。</li></ul></li><li><p>最大需求矩阵Max[n][m]</p><ul><li>n为系统中进程数, Max[i][j] &#x3D;k表示进程对j类资源的最大需求数为k。</li></ul></li><li><p>分配矩阵Allocation[n][m]</p><ul><li>Allocation[i][j]&#x3D;k表示进程i记分得j类资源的数目为k个。</li></ul></li><li><p>需求矩阵Need[n][m]</p><ul><li><p>Need[i][j]&#x3D;k表示进程i还需要j类资源k个。</p></li><li><p>Need[i][j] &#x3D;Max[i][j]-Allocation[i][j]</p></li></ul></li></ul></li><li><p>内容</p><ul><li><p>设Request;[j]&#x3D;k,表示进程P:需要k个R;类型的资源</p></li><li><p>如果Request;[j] &lt;&#x3D; Need[i,j],便转向步骤2 ;否则认为出错,因为它所请求的资源数已超过它所需要的最大值。</p></li><li><p>如果Request;[j] &lt;&#x3D; Available[j],便转向步骤3 ;否则,表示尚无足够资源，P需等待</p></li><li><p>系统试探着把资源分配给进程P，并修改下面数据结构中数值</p><ul><li><p>Available[j] &#x3D; Available[j]- Request;[j];</p></li><li><p>Allocation[ij] &#x3D; Allocation[;j]+ Request;[j];</p></li><li><p>Need[ij] &#x3D;Need[ij]-Request;[j];</p></li></ul></li></ul></li><li><p>安全性</p><ul><li><p>(1 )设置两个向量:</p><ul><li><p>工作向量work :表示系统可提供给进程继续运行所需的各类资源数目,含有m个元素的一维数组,初始时, work &#x3D;Available;</p></li><li><p>Finish:含n个元素的一维数组,表示系统是否有足够的资源分配给n个进程,使之运行完成。开始时先令Finish[i] &#x3D;false (i&#x3D;1..n);当有足够资源分配给进程时,再令Finish[i]&#x3D;true。</p></li></ul></li><li><p>( 2 )从进程集合中找到一个能满足下述条件的进程:</p><ul><li><p>Finish[i]&#x3D;false;</p></li><li><p>Need[ij] &lt; &#x3D;work[j];</p></li><li><p>若找到，执行步骤( 3)，否则执行步骤( 4)。</p></li></ul></li><li><p>( 3 )当进程Pi获得资源后,可顺利执行,直至完成,并释放出分配给它的资源,故应执行:</p><ul><li><p>work[j]&#x3D; work[j]+ Allocation[ij] ;</p></li><li><p>Finish[i]&#x3D;true;</p></li><li><p>go tostep (2);</p></li></ul></li><li><p>( 4 )如果所有进程的Finish[i] &#x3D;true都满足,则表示系统处于安全状态;否则,系统处于不安全状态。</p></li></ul></li></ul></li></ul><h3 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h3><ul><li><p>为了能对系统中是否已发生了死锁进行检测,在系统中必须</p><ul><li><p>①保存有关资源的请求和分配信息;</p></li><li><p>②提供一种算法,它利用这些信息来检测系统是否已进入死锁状态。</p></li></ul></li><li><p><img src="/img/images/2023-01-26-11-05-56-image.png" srcset="/img/loading.gif" lazyload></p></li><li><p>死锁定理</p><ul><li><p>如果资源分配图中没有环路,则系统中没有死锁;</p></li><li><p>如果图中存在环路则系统中可能存在死锁</p><ul><li><p>如果每个资源类中只包含一个资源实例,则环路是死锁存在的充分必要条件</p></li><li><p>如果每个资源类中资源实例个数不全为1 , 则环路是死锁存在的必要条件</p></li></ul></li></ul></li><li><p>死锁定理2</p><ul><li><p>资源分配图化简</p><ul><li><p>找到资源分配图中一个不孤立、不阻塞的进程节点,消去请求边与分配边,使之成为孤立点。</p></li><li><p>孤立点的资源释放后,可以分给其它进程,即将某进程的申请边变为分配边。</p></li><li><p>重复上述过程,当资源分配图中所有进程都成为孤立点时,称该资源分配图是可以完全简化的,否则称该资源分配图是不可完全简化的。</p></li><li><p><strong>不孤立</strong>:是指该进程存在有与之相连的有向边;</p></li><li><p><strong>不阻塞</strong>:是指该进程除了已经分配的资源外,对它尚需要的资源,系统都能够满足,因此该进程不会被阻塞。</p></li><li><p><strong>孤立点</strong>:是指该进程既无请求边,也无分配边,即没有与之相连的有向边。</p></li></ul></li><li><p><mark>一种资源分配状态为死锁状态的充要条件是资源分配图是不可完全简化的。</mark></p></li></ul></li></ul><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><ul><li><p>当发现进程死锁时,便应立即把它们从死锁状态中解脱出来。常采用的方法是:</p><ul><li><p>抢占资源:从其他进程剥夺足够数量的资源给死锁进程以解除死锁状态。</p></li><li><p>终止进程:最简单的是让全部进程都死掉;温和一点的是按照某种顺序逐个撤销进程，直至有足够的资源可用,使死锁状态消除为止。</p><ul><li><p>终止所有死锁进程</p><ul><li>这是一种最简单的方法,即是终止所有的死锁进程,死锁自然也就解除了,但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间,已接近结束，一旦被终止真可谓“功亏一篑”,以后还得从头再来。</li></ul></li><li><p>逐个终止进程</p><ul><li><p>按照某种顺序,逐个地终止进程,直至有足够的资源,以打破循环等待,把系统从死锁状态解脱出来为止。</p></li><li><p>每终止一个进程,都需要用死锁检测算法确定系统死锁是否已经被解除,若末解除还需再终止另一个进程。</p></li><li><p>在采取逐个终止进程策略时,还涉及到应采用什么策略选择一个要终止的进程</p></li></ul></li></ul></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="categories/课程笔记/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="tags/OS/">#OS</a></div></div><div class="license-box my-3"><div class="license-title"><div>操作系统复习 第三章</div><div>2023/02/07/subject/operate_system/chapter3/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>charlesix59</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/02/07/subject/operate_system/chapter4/" title="操作系统复习 第四章"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统复习 第四章</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="2023/02/07/subject/operate_system/chapter2/" title="操作系统复习 第二章"><span class="hidden-mobile">操作系统复习 第二章</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.5.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.5.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://hexo-comment-qncm4vegj-charlesix59.vercel.app/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/bilibili"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class=":" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">create by Charles Min at 2022 @CopyRight</div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/about/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?charlesix59",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"charlesix59")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style>#github_container>.position-relative>.border{border:0!important}#github-calendar{position:relative;margin-top:-2rem;background-color:var(--board-bg-color);transition:background-color .2s ease-in-out;border-radius:.5rem;z-index:3;-webkit-box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow:0 12px 15px 0 rgb(0 0 0 / 24%),0 17px 50px 0 rgb(0 0 0 / 19%)}</style></body></html>