<!DOCTYPE html><html lang="en" data-astro-cid-tge3q7ae> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/png" href="/src/assets/icon.png"><link rel="stylesheet" href="/styles/global.css"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="茶理的博客" href="https://charlesix59.github.io/rss.xml"><meta name="generator" content="Astro v5.16.6"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://charlesix59.github.io/tags/OS/"><!-- Primary Meta Tags --><title>OS - 茶理的博客</title><meta name="title" content="OS - 茶理的博客"><meta name="description" content="查看所有关于 OS 的文章 (11 篇)"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://charlesix59.github.io/tags/OS/"><meta property="og:title" content="OS - 茶理的博客"><meta property="og:description" content="查看所有关于 OS 的文章 (11 篇)"><meta property="og:image" content="https://charlesix59.github.io/_astro/default.DOL7xRHI.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://charlesix59.github.io/tags/OS/"><meta property="twitter:title" content="OS - 茶理的博客"><meta property="twitter:description" content="查看所有关于 OS 的文章 (11 篇)"><meta property="twitter:image" content="https://charlesix59.github.io/_astro/default.DOL7xRHI.png"><link rel="stylesheet" href="/_astro/about.CafuXOta.css">
<style>.card-link[data-astro-cid-dohjnao5]{text-decoration:none;color:inherit}.card[data-astro-cid-dohjnao5]{display:flex;gap:1.5rem;padding:1.5rem;border-radius:0;transition:all .3s ease;background:#fff;box-shadow:0 2px 8px #0000001a}.card[data-astro-cid-dohjnao5]:hover{box-shadow:0 4px 16px #00000026;transform:translateY(-2px)}.card-image[data-astro-cid-dohjnao5]{flex-shrink:0;width:10rem;height:10rem;border-radius:0;overflow:hidden;background:#f0f0f0}.card-image[data-astro-cid-dohjnao5] img[data-astro-cid-dohjnao5]{width:100%;height:100%;object-fit:cover}.card-content[data-astro-cid-dohjnao5]{flex:1;display:flex;flex-direction:column;justify-content:center;min-width:0}.card-title[data-astro-cid-dohjnao5]{margin:0 0 .5rem;font-size:1.1rem;font-weight:600;color:rgb(var(--black));line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.card-description[data-astro-cid-dohjnao5]{margin:0;font-size:.95rem;color:rgb(var(--gray));line-height:1.5;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis}@media(max-width:640px){.card[data-astro-cid-dohjnao5]{padding:1rem;gap:1rem}.card-image[data-astro-cid-dohjnao5]{width:8rem;height:8rem}.card-title[data-astro-cid-dohjnao5]{font-size:1rem}.card-description[data-astro-cid-dohjnao5]{font-size:.9rem;-webkit-line-clamp:1}}.card-list[data-astro-cid-p3vyftr4]{display:flex;flex-direction:column;gap:2px;margin-top:2rem}.card-item[data-astro-cid-p3vyftr4]{background:transparent}@media(max-width:640px){.card-list[data-astro-cid-p3vyftr4]{gap:2px;margin-top:1.5rem}}
main[data-astro-cid-tge3q7ae]{width:100%;max-width:960px;margin:0 auto;padding:2rem 1rem;box-sizing:border-box}.tag-header[data-astro-cid-tge3q7ae]{margin-bottom:3rem}.tag-header-content[data-astro-cid-tge3q7ae]{display:flex;align-items:center;gap:1rem;margin-bottom:1rem}.back-link[data-astro-cid-tge3q7ae]{display:inline-flex;align-items:center;gap:.5rem;color:rgb(var(--accent));text-decoration:none;font-weight:500;transition:all .3s ease}.back-link[data-astro-cid-tge3q7ae]:hover{gap:1rem}.back-link[data-astro-cid-tge3q7ae]:before{content:"←"}.tag-title[data-astro-cid-tge3q7ae]{display:inline-block;font-size:2.5rem;margin:0;color:rgb(var(--black));padding:.5rem 1.5rem;background:linear-gradient(135deg,#2680d9,#26d980);color:#fff;border-radius:20px}.tag-info[data-astro-cid-tge3q7ae]{display:flex;gap:2rem;margin-top:1rem;color:rgb(var(--gray));font-size:1.1rem}.tag-info-item[data-astro-cid-tge3q7ae]{display:flex;align-items:center;gap:.5rem}.tag-info-icon[data-astro-cid-tge3q7ae]{font-size:1.3rem}.empty-state[data-astro-cid-tge3q7ae]{text-align:center;padding:3rem 1rem;color:rgb(var(--gray))}.empty-state[data-astro-cid-tge3q7ae] p[data-astro-cid-tge3q7ae]{font-size:1.1rem}@media(max-width:768px){main[data-astro-cid-tge3q7ae]{padding:1.5rem .75rem}.tag-header[data-astro-cid-tge3q7ae]{margin-bottom:2rem}.tag-header-content[data-astro-cid-tge3q7ae]{flex-direction:column;align-items:flex-start;gap:.5rem}.back-link[data-astro-cid-tge3q7ae]{font-size:.95rem}.tag-title[data-astro-cid-tge3q7ae]{font-size:2rem;padding:.4rem 1rem}.tag-info[data-astro-cid-tge3q7ae]{flex-direction:column;gap:.5rem;font-size:1rem}}@media(max-width:480px){main[data-astro-cid-tge3q7ae]{padding:1rem .5rem}.tag-header[data-astro-cid-tge3q7ae]{margin-bottom:1.5rem}.tag-title[data-astro-cid-tge3q7ae]{font-size:1.5rem;padding:.3rem .8rem}.tag-info[data-astro-cid-tge3q7ae]{font-size:.9rem;gap:.3rem}.tag-info-icon[data-astro-cid-tge3q7ae]{font-size:1.1rem}.back-link[data-astro-cid-tge3q7ae]{font-size:.9rem}}
</style></head> <body data-astro-cid-tge3q7ae> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>茶理的博客</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 首页 </a>  <a href="/tags" class="active" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 标签 </a>  <a href="/about" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 关于我 </a>  </div> <div class="social-links" data-astro-cid-3ef6ksr2> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg> </a> </div> </nav> </header>  <main data-astro-cid-tge3q7ae> <section class="tag-header" data-astro-cid-tge3q7ae> <div class="tag-header-content" data-astro-cid-tge3q7ae> <a href="/tags/" class="back-link" data-astro-cid-tge3q7ae>返回标签云</a> </div> <h1 class="tag-title" data-astro-cid-tge3q7ae>OS</h1> <div class="tag-info" data-astro-cid-tge3q7ae> <div class="tag-info-item" data-astro-cid-tge3q7ae> <span class="tag-info-icon" data-astro-cid-tge3q7ae>📝</span> <span data-astro-cid-tge3q7ae>11 篇文章</span> </div> <div class="tag-info-item" data-astro-cid-tge3q7ae> <span class="tag-info-icon" data-astro-cid-tge3q7ae>📅</span> <span data-astro-cid-tge3q7ae>最新: 2024/12/19</span> </div> </div> </section> <div class="card-list" data-astro-cid-p3vyftr4> <div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter1/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第一章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第一章 引论

**操作系统：**

- 目标：
  
  - 方便性
  
  - 有效性
    
    - 提高系统资源利用率
    
    - 提高系统吞吐量
  
  - 可拓展性
  
  - 开放性

- 作用：
  
  - 作为用户与计算机硬件系统之间的接口
    
    - 程序接口
    
    - 命令接口
    
    - GUI
  
  - 作为计算机系统资源的管理者
    
    - 处理机管理
    
    - 存储器管理
    
    - I/O设备管理
    
    - 文件管理
  
  - 实现了对计算机资源的抽象
    
    - 将具体的计算机硬件资源抽象为软件资源，方便用户使用和拓展
    
    - 开放了简单的访问方式，隐藏了实现细节

- 发展动力
  
  - 不断提高计算机资源利用率
  
  - 方便用户
  
  - 器件的不断更新迭代
  
  - 计算机体系结构的不断发展
  
  - 不断提出新的应用需求

## 计算机的发展历程

### 人工操作方式

- 优点
  
  - 用户独占全机
  
  - CPU等待人工操作

- 缺点
  
  - 计算机资源浪费
  
  - 效率低
  
  - CPU与I/O设备之间速度不匹配

### 脱机输入输出方式

- 优点
  
  - 解决了人际矛盾
  
  - 减少了CPU的空闲时间
  
  - 提高了I/O速度

- 缺点
  
  - 一次只能执行一个程序

### 单道批处理系统

批处理是指计算机系统对一批作业自动进行处理的一种技术。
为实现对作业的连续处理,需要先把一批作业以脱机方式输入到磁带上,并在系统中配上监督程序(Monitor) ,在它的控制下,使这批作业能一个接一地连续处理

- 优点
  
  - 自动性
  
  - 顺序性
  
  - 单道性

- 缺点
  
  - 内存中只有一道程序
  
  - CPU需要等待I/O完成

### 多道批处理系统

在多道批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”; 然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。

- 优点
  
  - 提高CPU的利用率
  
  - 可提高内存I/O设备利用率
  
  - 增加系统吞吐量

- 缺点
  
  - 平均周转周期长
  
  - 无人机交互

### 分时系统

采用时间片轮转的方法，同时为许多终端用户服务，对每个用户能保证足够快的响应时间，并提供交互会话的功能。
时间片：将CPU的时间划分成若干个片段，称为时间片，操作系统以时间片为单位，轮流为每个终端用户服务关键问题

- 特征
  
  - 多路性：时间片轮转机制
  
  - 独立性：用户彼此独立
  
  - 及时性：用户能在短时间内获得响应
  
  - 交互性：用户可以请求多种服务

#### 实时任务

- 按照是否呈现周期性划分
  
  - 周期性实时任务
  
  - 非周期性实时任务
    
    - 开始截止时间
    
    - 完成截止时间

- 对截止时间的要求的划分
  
  - 硬实时任务
  
  - 软实时任务

### 微机操作系统

微型计算机操作系统 微型计算机操作系统简称微机操作系统，常用的有Windows、Mac OS、Linux。

## 基本特征

### &lt;mark&gt;并发性&lt;/mark&gt;

**并行性**是指两个或多个事件在同一时间发生

**并发性**是指两个或多个事件在同一事件间隔发生

- 宏观上，处理机同时处理多道程序

- 微观上，处理机在多道程序间高速切换

**进程**( process )是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的,是一个能独立运行的活动实体。
**线程**( threads )通常在一个进程中可以包含若干个线程, 一般把进程作为分配资源的基本单位,而把线程作为独立运行和独立调度的基本单位。

### &lt;mark&gt;共享性&lt;/mark&gt;

资源共享，即系统中的资源多个“并发执行”的应用程序共同使用

- 互斥共享方式：多个程序在同一个共享资源上独立而互不干扰的工作
  
  - 又叫临界资源/独占资源

- 同时访问方式：同一时段允许多个程序同时访问共享资源

并发和共享互为存在条件

- 共享性要求OS中同时运行着多道程序若只有单道程序正在运行，则不存在共享的可能

- 并发性难以避免的导致多道程序同时访问同一个资源,若多道程序无法共享部分资源(比如磁盘) ,则无法并发

### 虚拟性

使用某种技术把一个物理尸体变成多个逻辑上的对应物

- 时分复用技术( TDM , Time Division Multiplexing )
  
  - 虚拟处理机技术:利用多道程序设计技术,为每道程序建立一个进程,让多道程序并发执行,以此来分时使用一台处理机。
  
  - 虚拟设备技术:将一台物理I/O设备虚拟为多台逻辑上的I/O设备,并允许每个用户占用一台逻辑上的I/O设备。

- 空分复用技术( SDM , Space Division Multiplexing )
  
  - 虚拟存储器技术

### 异步性

- 多道程序环境下,允许多个程序并发执行;单处理机环境下,多个程序分时交替执行;

- 程序执行的不可预知性
  
  - 获得运行的时机
  
  - 因何暂停
  
  - 每道程序需要多少时间
  
  - 不同程序的性能,比如计算多少, I/O多少

- 宏观上“一气呵成”,微观上“走走停停”

- 每个程序在何时执行，多个程序间的执行顺序以及完成每道程序所需的时间都是不确
  定和不可预知的。进程是以人们不可预知的速度向前推进,此即进程的异步性。

## 主要功能

### 处理机管理

- **进程控制**:当用户作业要运行时,应为之建立一个或多个进程,并为它分配除处理机以外的所有资源,将它放入进程就绪队列。当进程运行完成时，立即撤消该进程,以便及时释放其所占有的资源。进程控制的基本功能就是创建和撤消进程以及控制进程的状态转换。

- **进程同步**:所谓进程同步是指系统对并发执行的进程进行协调。
  
  - 进程互斥方式,是使诸进程以互斥方式访问临界资源。
  
  - 进程同步方式,对于彼此相互合作去完成共同任务的诸进程,则应由系统对它们的运行次序加以协调。

- **进程通信**:对于相互合作的进程,在它们运行时,相互之间往往要交换一定的信息,这种进程间所进行的信息交换称为进程通信。

- **调度**:当一个正在执行的进程已经完成,或因某事件而无法继续执行时,系统应进行进程调度,重新分配处理机。
  
  - 作业调度是从后备队列中按照一定的算法,选择出若干个作业,为它们
    分配运行所需的资源。
  
  - 进程调度是指按一定算法,从进程就绪队列中选出一进程,把处理机分
    配给它,为该进程设置运行现场。并使之投入运行。

### 存储器管理

- 内存分配:主要任务是:
  
  - 为每道程序分配内存空间,使它们&quot;各得其所&quot;。
  
  - 提高存储器的利用率,尽量减少不可用的内存空间(碎片)。
  
  - 允许正在运行的程序申请附加的内存空间,以适应程序和数据动态增长的需要。

- 内存分配方式
  
  - 静态分配
  
  - 动态分配

- 内存保护:为保证各道程序都能在自己的内存空间运行而互不干扰,要求每道程序在执行时能随时检查对内存的所有访问是否合法。必须防止因一道程序的错误而扰乱了其它程序,尤其应防止用户程序侵犯操作系统的内存区。

- 内存保护机制:设置两个寄存器,存放正在执行程序的上下界。

- 地址映射: -个应用程序(源程序)经编译后,通常会形成若干个目标程序;这些目标程序再经过链接便形成了可装入程序。这些程序的地址都是从&quot;0&quot;开始的,程序中的其它地址都是相对于起始地址计算的;

- 在多道程序环境下,每道程序不可能都从&quot;0&quot;地址开始装入(内存)，这就致使地址空间内的逻辑地址和内存空间中的物理地址不相一-致。

- 使程序能正确运行,存储器管理必须提供地址映射功能,以将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。

- 内存扩充:并非是去扩大物理内存的容量,而是借助于虚拟存储技术,从逻辑上去扩充内存容量,使用户所感觉到的内存容量比实际内存容量大得多;或者是让更多的用户程序能并发运行。
  
  - 请求调入功能。
  
  - 置换功能。

- 缓冲管理:几乎所有的外围设备于处理机交换信息时,都要利用缓冲来缓和CPU和I/O设备间速度不匹配的矛盾,和提高CPU与设备、设备与设备间操作的并行程度,以提高CPU和I/O设备的利用率。

- 最常见的缓冲区机制有单缓冲机制、能实现双向同时传送数据的双缓冲机制,以及能供多个设备同时使用的公用缓冲池机制。

- 设备分配:系统根据用户所请求的设备类型和所采用的分配算法对设备进行分配,并将未获得所需设备的进程放进相应设备的等待队列。

- 设备处理程序又称为设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信,即由CPU向设备控制器发出I/O命令,要求它完成指定的I/0操作;反之由CPU接收从控制器发来的中断请求,并给予迅速的响应和相应的处理。

### 设备管理

- 设备管理的主要任务:
  
  - 为用户程序分配I/0设备;完成用户程序请求的I/O操作;
  
  - 提高CPU和I/O设备的利用率;方便用户使用。

### 文件管理

- 文件存储空间的管理

- 目录管理

- 文件读写管理和保护

### 操作系统与用户之间的接口

- 用户接口
  
  - 联机用户接口
    
    - 为联机用户提供的,它由一组键盘操作命令及命令解释程序所组成。用户可通过先后键入不同的命令方式来实现对作业的控制。
  
  - 脱机用户接口
    
    - 该接口是为批处理作业的用户提供的,故也称为批处理用户接口。由一组作业控制语言组成。用户用JCL把需要对作业进行的控制和干预事先写在作业说明书上,然后将作业连同作业说明书一起提供给系统。
  
  - 图形用户接口
    
    - 采用图形化的操作界面,用各种图表将系统的各项功能、文件等,直观的表现出来。用户直接用鼠标对应用程序和文件进行操作。

- 程序接口
  
  - 由一组系统调用组成,每一个系统调用都是一个能完成特定功能的子程序,每当应用程序要求OS提供某种服务时,便调用具有相应功能的系统调用。

## 运行环境

&lt;mark&gt;内核态（管态）和用户态（目态）将内核程序和用户程序隔离&lt;/mark&gt;

- 内核态
  
  - 操作系统的程序执行
  
  - 使用全部指令
  
  - 使用全部系统资源

- 用户态
  
  - 用户程序执行
  
  - 禁止使用特权指令
  
  - 只允许用户程序访问自己的存储区域

特权指令和非特权指令

- 特权指令
  
  - 设计外部设备的输入/输出指令
  
  - 存取用于内存保护的寄存器
  
  - 内存清零
  
  - 置时钟
  
  - 允许/禁用中断

&lt;mark&gt;中断指令&lt;/mark&gt;是用户程序发起的调用内核代码的唯一方式

- 中断机制
  
  - 提高多道程序环境下CPU利用率
  
  - 外中断：中断信号来源于外部设备
  
  - 内中断：中断信号来源于当前指令内

- 内中断的三种情况
  
  - 陷阱/陷入：由应用程序主动引发
  
  - 故障：由错误条件引发
  
  - 终止：由致命错误引发

- 系统调用的核心
  
  - 用户程序中包含一段含有int指令的代码
  
  - 操作系统写中断处理，获取想调用程序的编号
  
  - int指令将使CPL改成0 ，“进入内核”
  
  - 操作系统根据编号执行相应代码

-</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter2/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第二章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第二章 进程的描述与控制

## 程序的执行顺序

### 程序的顺序执行

一个具有独立功能的程序独占处理机，直到得到最终结果的过程

#### 前驱图

一个有向无环图（DAG），用于描述进程间执行的前后的关系

- 节点：表示一个程序段或进程，或一条语句

- 有向边：节点之间的偏序或前驱关系

- 初始节点：没有前驱关系的点

- 终止节点：没有后继的节点

程序顺序执行的特性：

- 顺序性：处理机的操作严格按照顺序进行

- 封闭性：程序一旦开始执行，结果不受外因影响

- 可再现性：程序结果与执行速度无关，只与初始条件有关

### 程序的并发执行

内存中同时装入多道程序，他们共享系统资源，并发执行

特性：

- 间断性:程序并发执行时,由于它们共享资源或程序之间相互合作完成-项共同任务,因而使程序之间相互制约。相互制约导致并发程序具有&quot;执行一暂停-执行”这种间断性的活动规律。

- 失去封闭性: 程序在并发执行时,多个程序共享资源,因而资源的状态将由多个程序来改变,致使程序的运行失去了封闭性。

- 不可再现性:程序在并发执行时,多次运行初始条件相同的同-一程序会得出不同的运行结果。

## 进程

- 定义：
  
  - 程序段、数据段、PCB三部分构成了进程实体,简称&quot;进程”。
  
  - 注意：
    
    - 进程是[程序J的「一次执行J
    
    - 进程是一个程序及其数据在处理机上顺序执行时所发生的「活动」
    
    - 进程是程序在一个「数据集合J」运行的过程
    
    - 进程是系统进行「资源分配和调度J的- -个「独立」单位(或者说基本单位)

- 特征
  
  - 动态性:进程的实质是程序的一次执行过程
    
    - 进程是动态产生,动态消亡的,进程在其生命周期内,在3种基本状态之间转换
  
  - 并发性:任何进程都可以同其他进程一起向前推进
  
  - 独立性:进程是一个能独立运行的基本单位,同时也是系统分配资源和调度的独立单位
  
  - 异步性:由于进程间的相互制约,使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进

- 三种状态
  
  - 就绪状态(Ready)
    
    - 进程已获得除CPU之外的所有必需的资源,一旦得到CPU控制权,立即可以运行
  
  - 运行状态(Running)
    
    - 进程已获得运行所必需的资源，它正在处理机上执行。
  
  - 阻塞状态(Blocked)
    
    - 正在执行的进程由于发生某事件而暂时无法执行时,便放弃处理机而处于暂停状态,称该进程处于阻塞状态或等待状态。

- 其他状态
  
  - 创建(New)
    
    - 为了保证进程的调度必须在创建工作完成后进行,同时为了增加管理的灵活性, OS可以根据系统性能或主存容量的限制,推迟创建状态进程的提交,产生进程的创建状态。
  
  - 终止( Terminated )
    
    - 进程到达自然结束点、出现无法克服的错误、被操作系统所终结
    
    - 等待操作系统善后处理,将其PCB清零,将PCB空间返还系统
  
  - 挂起
    
    - 有的系统有时希望能人为地把进程挂起,使之处于静止状态,以便研究其执行情况或对它进行修改。
    
    - 挂起:把进程从内存转向外存
    
    - 引入挂起操作的原因
      
      - 终端用户的请求。
      
      - 父进程请求。
      
      - 负荷调节的需要。
      
      - 操作系统的需要。
  
  - 激活
    
    - 对应挂起

- ![](../../../../assets/default.png)

### 进程管理中的数据结构

- 操作系统中，对每个资源和每个进程都设置了-个数据结构,用于表征其实体,称之为:资源信息表和进程信息表。

- OS管理的这些数据结构分为四类:内存表、设备表、文件表、进程表。

### 进程控制块 PCB

PCB的作用是使一个在多道程序环境下不能独立运行的程序(含数据) ,成为一个能独立运行的基本单位, 一个能与其他进程并发执行的进程

&lt;mark&gt;PCB是进程存在的唯一标志&lt;/mark&gt;

- 作用
  
  - 作为独立运行基本单位的标志。
  
  - 能实现间断性运行方式。
  
  - 提供进程管理所需要的信息。
  
  - 提供进程调度所需要的信息。
  
  - 实现与其它进程的同步与通信。

- 内容

- | 类型           | 内容                                                        | 作用               |
  | ------------ | --------------------------------------------------------- | ---------------- |
  | 标识信息         | 1 )外部标识为方便用户&lt;br/&gt;2 )内部标识为方便系统                             | 标识一个进程           |
  | 处理机状态(现场信息 ) | 1 ) CPU通用/指令寄存器&lt;br/&gt;2 ) CPU程序状态字PSW&lt;br/&gt;3 )用户栈指针          | 记录处理机现场信息,以备恢复之用 |
  | 调度信息         | 1 )进程状态&lt;br/&gt;2 )进程优先级&lt;br/&gt;3 )调度所需信息&lt;br/&gt;4)事件               | 用户进程的调度管理        |
  | 控制信息         | 1 )程序和数据地址&lt;br/&gt;2 )进程同步和通信机制&lt;br/&gt;3 )资源清单&lt;br/&gt;4 )指向下一个进程的指针 | 用于进程的控制管理        |

- 组织方式
  
  - 线性方式：即将系统中所有的PCB都组织在一张线性表中,将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小,但每次查找时都需要扫描整张表,因此适合进程数目不多的系统
  
  - 链接方式：把具有同一状态的PCB用其中的链接字链接成一个队列。
    
    - 就绪队列
    
    - 若干个堵塞队列
  
  - 索引方式：系统根据所有进程的状态建立几张索引表,把各表的内存首地址记录在内存的专用单元中。索引表的表目中记录了相应状态的某个PCB在PCB表中的地址。

## 进程控制

进程控制是对系统中所有进程从产生、存在到消亡的全过程实行有效的管理和控制。
进程控制一般是由操作系统的内核来实现,内核在执行操作时,往往是通过执行各种原语操作来实现的。

### 操作系统内核

- 功能
  
  - 支撑功能
    
    - 中断管理
    
    - 时钟管理
      
      - 计时
      
      - 时钟中断
    
    - 原语操作
      
      - 由若干条指令组成
      
      - 用来完成某个特定功能
      
      - 执行过程不会中断
  
  - 资源管理功能
    
    - 进程管理
    
    - 存储器管理
    
    - 设备管理

- 进程控制
  
  - 原语种类
    
    - 进程创建原语
    
    - 进程撤销原语
    
    - 阻塞原语
    
    - 唤醒原语
    
    - 挂起原语
    
    - 激活原语
  
  - 控制过程
    
    - 更新PCB中的信息(如修改进程状态标识、将运行环境保存到PCB、从
      PCB恢复运行环境)
      ➢所有的进程控制原语一定会修改进程状态标志
      ➢剥夺当前运行进程的CPU使用权必然需要保存其运行环境(玩游戏的存档)
      ➢某进程开始运行钱必然要恢复运行环境(玩游戏的读档)
    
    - 将PCB插入合适的队列
    
    - 分配/回收资源

### 进程的创建

- 层次结构
  
  - 在OS中允许一个进程创建另-个进程,通常把创建进程的进程称为父进程,而把被创建的进程称为子进程。
  
  - 在UNIX中子进程可继续创建更多的孙进程,由此便形成了- -个进程的层次
    结构。
    
    - 子进程可以继承父进程所拥有的资源，
    
    - 当子进程被撤消时,应将其从父进程那里获得的资源归还给父进程。
    
    - 在撤消父进程时,也必须同时撤消其所有的子进程。
  
  - Windows中不存在任何进程层次结构的概念

- 引起创建进程的事件
  
  - 用户登录
  
  - 作业调度
  
  - 提供服务
  
  - 应用请求

- 创建过程
  
  - 申请进程标识,即申请空白PCB
  
  - 为新进程分配内存和其它资源
  
  - 初始化进程控制块
  
  - 将创建的进程置于就绪队列

### 进程的终止

- 引起进程终止的事件
  
  - 正常:
    
    - 任务完成=&gt; halt/ logs off指令=&gt;中断
  
  - 异常:
    
    - 访问控制(存储越界、资源访问越界、指令越界)
    
    - 运行超时、等待超时
    
    - 被禁止的运算
    
    - I/O错误等
  
  - 外界干预:
    
    - OS或用户干预
    
    - 父进程请求
    
    - 父进程终止

- 终止过程
  
  - 根据被终止进程的标识符,从PCB集合中检索出该进程的PCB ,从中读出该进程的状态
  
  - 若被终止进程正处于执行状态,应立即终止该进程的执行,并置调度标志为真，用于指示该进程被终止后应重新进行调度;
  
  - 若该进程还有子孙进程,还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程;
  
  - 将被终止进程所拥有的全部资源或者归还给其父进程,或者归还给系统;
  
  - 将被终止进程( PCB )从所在队列(或链表)中移出,等待其它程序来搜集信息。

### 进程的阻塞与唤醒

- 引起的事件
  
  - 请求资源失败(如临界资源被占用，属于内部同步)
  
  - 等待某种操作完成(如磁盘l/O操作,属于内部同步)
  
  - 等待新数据的到来(如多进程协作时，属于外部同步)
  
  - 等待新任务(如Deamon服务进程，属于外部同步)

- 进程的阻塞( block原语)
  
  - 进程停止执行
  
  - 状态改为“阻塞”
  
  - 进程被插入阻塞队列

- 进程的唤醒( wakeup原语)
  
  - 状态改为“就绪”
  
  - 进程被插入就绪队列

### 进程的挂起与激活

#### 挂起

当出现了引起进程挂起的事件时，比如,用户进程请求将自己挂起,或父进程请求将自己的某个子进程挂起，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。
挂起原语的执行过程:

- 检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程,则将之改为静止阻塞。

- 把该进程的PCB插入相应的挂起队列上,将程序段、数据段移除内存。最后,若被挂起的进程正在执行,则转向调度程序重新调度。

### 激活

- 当发生激活进程的事件时,若该进程驻留在外存而内存中已有足够的空间时,则可将在外存上处于静止就绪状态的进程换入内存。

- 系统将利用激活原语active( )将指定进程激活。

- 激活过程:
  
  - 先将进程从外存调入内存,检查该进程的现行状态,若是静止就绪,便将之改为活动就绪;若为静止阻塞便将之改为活动阻塞。
  
  - 假如采用的是抢占调度策略,则每当有新进程进入就绪队列时,应检查是否要进行重新调度,即由调度程序将被激活进程与当前进程进行优先级的比较,如果被激活进程的优先级更低,就不必重新调度;否则,立即剥夺当前进程的运行,把处理机分配给刚被激活的进程。

## 进程同步

**引入进程的好处**：支持多道程序并发,提高资源利用率
**引入进程的缺点**：系统更复杂,破坏了程序运行的封闭性和不可再现性

**引入进程同步**：对多个进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源,并能相互协作,使得程序的执行具有可再现性

- 两种形式的制约关系
  
  - 间接相互制约：多个进程只能互斥执行
    
    - 互斥：对某个系统资源，多个进程不能同时使用
    
    - 临界资源：一段时间内只允许一个进程访问的资源
    
    - 问题
      
      - 死锁
  
  - 直接相互制约：多个进程之间相互合作共同完成一件事

- 临界区：进程中访问临界资源的那段代码
  
  - 访问临界区的程序设计为:
    
    - 对欲访问的临界资源进行检查,
    
    - 若此刻未被访问,设正在访问的标志——进入区
    
    - 访问临界资源——临界区
    
    - 将正在访问的标志恢复为未被访问的标志——退出区
    
    - 其余部分——剩余区

- 同步机制应遵循的规则
  
  - 空闲让进:当无进程在临界区时,任何有权使用临界区的进程可进入。
  
  - 忙则等待:不允许两个以上的进程同时进入临界区。
  
  - 有限等待:任何进入临界区的要求应在有限的时间内得到满足。
  
  - 让权等待:处于等待状态的进程应放弃占用CPU ,以使其他进程有机会得到CPU的使用权。

### 硬件同步机制

- 关中断法(开关中断指令)也称为&quot;硬件锁”, 是实现互斥最简单的方法。
  
  - 做法:在进入锁测试之前关闭中断,直到完成锁测试并上锁之后才能打开中断。这样,进程在临界区执行期间,计算机系统不响应中断,从而不会引发调度,也就不会发生进程或线程切换。由此,保证了对锁的测试和关锁操作的连续性和完整性,有效地保证了互斥。
  
  - 缺点:
    
    - 滥用关中断权力可能导致严重后果;
    
    - 关中断时间过长,会影响系统效率,限制了处理器交叉执行程序的能力;
    
    - 关中断方法也不适用于多CPU系统,因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。

- 利用Test and Set指令实现互斥
  
  - 做法：这是一种借助一条硬件指令一-‘ 测试并建立&quot;指令TS(Test- and-Set)以实
    现互斥的方法。在许多计算机中都提供了这种指令。
  
  - 缺点：
    
    - 不符合“让权等待”原则

- 利用swap指令实现线程互斥
  
  - 缺点：
    
    - 不符合”让权等待“原则

### 信号量机制

1965年荷兰Dijkstra提出的信号量( Semaphores )是-种卓有成效的进程同步工具,在长期的应用中,得到了很大的发展,从整型信号量经过记录型信号量,进而发展为&quot;信号量集”机制。

- 优点
  
  - 信号量就是OS提供的管理公有资源的有效手段。
  
  - 信号量代表可用资源实体的数量。

#### 整型信号量

- 定义:把整型信号量定义为-个用于表示资源数目的整型量S ,除初始化外仅能通过两个原子操作wait(S),signal(S)来访问

- 原子操作P :
  
  - 荷兰语&quot;proberen&quot;一-“检测” 之意。意味着请求分配一个单位资源
  
  - wait(S)

- 原子操作V :
  
  - 荷兰语“verhogen&quot;一- &quot;增量”之意，意味着释放一个单位资源
  
  - signal(S) 

#### 记录型信号量

- 在信号量机制中，除了需要一个用于代表资源数目的整型变量value外 ,还应增加一个进程链表L，用于链接上述的所有等待进程。

- 记录型信号量是由于它采用”了记录型的数据结构而得名的。

#### AND型信号量

- AND同步机制的基本思想是:将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程,待进程使用完后再一起释放。

- 只要尚有一个资源未能分配给进程,其它所有可能为之分配的资源,也不分配给他。

- 在wait操作中,增加了一个&quot;AND&quot;条件,故称为AND同步,或称为同时wait操作。

#### 信号量集

- 一次申请多个单位的临界资源

- 资源数量低于预设下限值时不予分配

- ![](../../../../assets/default.png)

#### 应用

- 利用信号量实现进程互斥
  
  - 为使多个进程互斥的访问某临界资源,须为该资源设置一互斥信号量mutex ,并设其初始值为1 ,然后将各进程访问资源的临界区CS置于wait(mutex)和signal(mutex)之间即可。

- 利用信号量实现前驱关系
  
  - 希望S1→S2 ,只需使进程P1和P2共享一个公用信号量S=0 ,将signal(S)放在语句S1后,将wait(S)放在语句S2前。

### 管程

- 信号量的缺点
  
  - 同步操作分散:信号量机制中,同步操作分散在各个进程中,使用不当就可能导致各进程死锁(如P、V操作的次序错误、重复或遗漏) ;
  
  - 易读性差:要了解对于一组共享变量及信号量的操作是否正确,必须通读整个系统

- 管程的优点
  
  - 把分散在各进程中的临界区集中起来进行管理,并把系统中的共享资源用数据结构抽象地表示出来。由于临界区是访问共享资源的代码段,建立一个“秘书”程序管理来到的访问。&quot;秘书” 每次仅让一个进程来访,这样既便于对共享资源的管理，又实现了互斥访问。

管程是由若干个公共变量和所有访问这些变量的过程所组成的一个特殊的模块或软件包

- 基本思想:
  
  - 集中管理各进程中的临界区:管程把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理。

- 特点
  
  - 管程的局部变量只能由该管程的过程存取;
  
  - 系统保证进程只能互斥地调用管程中的过程。

- 条件变量
  
  - 管程中对每个条件变量,都须予以说明, 其形式为: condition x, y。该变
    量应置于wait和signal之前,即可表示为X.wait和X.signal。

- 特征
  
  - 模块化: 一个管程是一个基本程序单位，可以单独编译;
  
  - 抽象数据类型:管程是一种特殊的数据类型,其中不仅有数据,而且有对数据进行操作的代码,是对数据和操作的封装。
  
  - 信息掩蔽:管程如何实现其功能相对于外部程序是半透明的。

- 优点
  
  - 安全性:共享变量外部不可见，只能由管程中的操作存取;
  
  - 互斥性:管程在任何一个时刻只能有一个进程进入;
  
  - 等待机制:设置有等待队列及相应的操作，对资源进行管理。

- 管程和进程的区别
  
  - 设置目的不同:管程是对共享资源进行管理,进程是资源分配和执行的基本单位。
  
  - 数据结构不同:管程定义公用数据结构,进程定义私有数据结构PCB。
  
  - 存在方式不同:进程有生命周期，管程是操作系统固有的部分,没有生命周期。
  
  - 执行方式不同:管程被进程调用,没有并发性,进程具有并发执行性。

## 进程通信

### 共享存储器系统

- 模式：
  
  - 共享数据结构
    
    - 进程公用某些数据结构,借以实现诸进程间的信息交换。
    
    - 实现:公用数据结构的设置及对进程间同步的处理,都是程序员的职责。操作系统提供共享存储器
    
    - 特点:低效。只适合传递相对少量的数据。
  
  - 共享存储区
    
    - 在存储器中划出一块共享存储区,诸进程可通过对共享存储区中数据的读或写
      来实现通信。

### 管道通信系统

- 管道:指用于连接-个读进程和一个写进程以实现他们之间通信的一个打开的共享文件,又名pipe文件。

- 管道只能采取半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,则需要设置两个管道各个进程要互斥的访问管道

- 数据以字节流的形式写入管道,当管道写满时,写进程的write()系统调用将会被阻塞,等待读进程将数据取走。当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将会被阻塞

### 消息传递系统

- 用格式化消息封装所需传输的数据,消息长度可以固定,也可以变化。

- 直接利用系统提供的一组通信命令(原语)进行通信。

- 操作系统隐藏了通信的实现细节,大大减化了通信程序编制的复杂性

- 应用广泛:微内核、多处理机系统、分布式系统、计算机网络等

- 消息传递系统的通信方式属于高级通信方式。又因其实现方式的不同而进一步分成
  
  - 直接通信方式
    
    - 发送进程利用OS提供的发送命令,直接把消息发送给目标进程。发送进程和接收进程都以显式方式提供对方的标识符。
    
    - 通信原语:
      
      - Send(Receiver, message);发送一个消息给接收进程
      
      - Receive(Sender, message);接收Sender发来的消息
  
  - 间接通信方式。
    
    - 信箱用来暂存发送进程发送给目标进程的消息,接收进程则从信箱中取出发送给自己的消息。
    
    - 消息在信箱中可安全保存,只允许核准的目标用户随时读取
    
    - 利用信箱通信方式,既可实时通信,又可非实时通信。
    
    - 通信原语:
      
      - Send (MailBox, Message) ;
      
      - Receive (MailBox, Message) ;
    
    - 信箱可由操作系统创建,也可由用户进程创建,创建者是信箱的拥有者。
    
    - 信箱分类:
      
      - 私用信箱
      
      - 公用信箱
      
      - 共享信箱

### 客户-服务器系统

## 线程

### 线程的引入

- 进程的两个基本属性:
  
  - 进程是一个可拥有资源的独立单位
  
  - 进程同时又是一个可独立调度和分派的基本单位。

- 为使程序能并发执行,系统还必须进行以下的一系列操作。
  
  - 创建进程
  
  - 撤消进程
  
  - 进程切换
  
  - 这样系统必须为之付出较大的时空开销。因此应分开进程的两个属性。即对于作为调度和分派的基本单位,不同时作为拥有资源的单位，以&quot;轻装上阵”,反之亦然。

- 进程切换过程
  
  - 切换页目录以使用新的地址空间
  
  - 切换内核栈和硬件上下文

### 线程

线程(thread)是一个可执行的实体单元。&lt;mark&gt;它代替以往的进程,成为现代操作系统中处理机调度的基本单位。&lt;/mark&gt;

- 特性
  
  - 调度的基本单位
    
    - 同一进程中的线程切换不会引起进程切换
    
    - 不同进程中的线程切换必然引起进程切换
  
  - 并发性
  
  - 拥有资源
  
  - 独立性
  
  - 系统开销
  
  - 支持多处理机系统

- 线程运行的三个状态
  
  - 执行状态,表示线程正获得处理机而运行;
  
  - 就绪状态，指线程已具备了各种执行条件, 一旦获得CPU便可执行的状态;
  
  - 阻塞状态,指线程在执行中因某事件而受阻,处于暂停执行时的状态。

- 线程控制块TCB
  
  - 线程标识符;
  
  - 组寄存器，它包括程序计数器PC、状态寄存器和通用寄存器;
  
  - 线程运行状态,用于描述线程正处于何种运行状态;
  
  - 优先级，描述线程执行的优先程度;
  
  - 线程专有存储区，用于线程切换时存放现场保护信息,和相关统计信息;
  
  - 信号屏蔽，即对某些信号加以屏蔽。
  
  - 堆栈,用来保存局部变量和返回地址。
    
    - 用户栈和核心栈

- 用户级线程
  
  - 定义
    
    - 用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能,都无须利用系统调用来实现。
    
    - 对于用户级线程的切换,通常是发生在一个应用进程的诸多线程之间,无须内核的支持。
    
    - 切换的规则远比进程调度和切换的规则简单
  
  - 实现
    
    - 用于管理和控制线程的函数(过程)的集合,其中包括用于创建和撤消线程的函数、线程同步和通信的函数以及实现线程调度的函数等
      ➢pthread_ creat , pthread_ exit , pthread_ join , pthread_ yield
    
    - 运行时系统中的所有函数都驻留在用户空间,并作为用户级线程与内核之间的接口。
  
  - 优点
    
    - 线程切换不需要转换到内核空间
    
    - 调度算法可以是进程专用的
    
    - 用户级线程的实现与OS平台无关
    
    - 用户线程不占用内核内存,本身的内核空间开销也更小一些,可以节约资源
  
  - 缺点
    
    - 系统调用的阻塞问题。当线程执行一个系统调用时,不仅该线程被阻塞,而且,进程内的所有线程会被阻塞。而在内核支持线程方式中则进程中的其它线程仍然可以运行。
    
    - 在单纯的用户级线程实现方式中,多线程应用不能利用多处理机进行多重处理的优点,内核每次分配给一个进程的仅有一个CPU ,因此,进程中仅有一个线程能执行,在该线程放弃CPU之前,其它线程只能等待。

- 内核支持线程KST
  
  - 定义
    
    - 在内核的支持下运行的，即无论是用户进程中的线程,还是系统进程中的线程,他,们的创建、撤消和切换等,也是依靠内核实现的。
    
    - 在内核空间还为每一个内核支持线程设置了一 个线程控制块 ,内核是根据该控制块而感知某线程的存在的,并对其加以控制。
  
  - 实现
    
    - 在支持线程的OS中,系统在创建进程时,便为他分配一个任务数据区,包括若干线程控制块空间。
  
  - 优点
    
    - 在多处理器系统中,内核能够同时调度同-进程的多个线程并行执行。
    
    - 一个线程被阻塞,内核可以调度该进程的其它线程运行,也可以运行其它进程中的线程。
    
    - 线程切换比较快,开销小。
    
    - 内核本身也可以采用多线程技术,提高执行速度和效率
  
  - 缺点
    
    - 在同一进程间的线程控制权转移时,用户级与核心级的切换开销很大。

- 组合方式
  
  - 内核支持多线程的建立、调度和管理,同时,也允许用户应用程序建立、调度和管理用户级线程。
  
  - 这种方式能够结合两者的优点,克服其各自的不足。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter3/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第三章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第三章 处理机调度与死锁

## 处理机调度的层次

- 进程:是一个程序对某个数据集的执行过程,是分配资源的基本单位。

- 作业:是用户需要计算机完成的某项任务,是要求计算机所做工作的集合

- 一个作业通常包括几个进程,几个进程共同完成一个任务,即作业。

- 用户提交作业以后,当作业被调度，系统会为作业创建进程, 一个进程无法完成时,系统会为这个进程创建子进程。

- 作业的概念更多地用在批处理系统中。

- &lt;mark&gt;进程的概念几乎可以用在所有的多道程序系统中&lt;/mark&gt;。

&lt;mark&gt;调度&lt;/mark&gt;是多道程序的关键

**调度算法的目标：**

- 提高资源利用率

- **公平性**。公平性是指应使诸进程都获得合理的CPU时间,不会发生进程
  饥饿现象。

- **平衡性**。由于在系统中可能具有多种类型的进程,有的属于计算型作业,
  有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态,
  调度算法应尽可能保持系统资源使用的平衡性。

- **策略强制执行**。对所制订的策略其中包括安全策略,只要需要,就必须
  予以准确地执行,即使会造成某些工作的延迟也要执行。

**批处理系统的目标**：

- 平均周转周期更短
  
  - 周转时间=作业完成时间-作业到达时间
  
  - 平均周转时间=作业周转总时间/进程个数
  
  - 带权周转时间:即作业的周转时间T与系统为它提供服务的时间T,之比,即.W = T/Ts。
    
    - 可进一步反映调度的性能,更清晰地描述各进程在其周转时间中,等待和执行时间的具体分配状况.

- 系统吞吐量高
  
  - 由于吞吐量是指在单位时间内系统所完成的作业数
  
  - 它与批处理作业的平均长度有关
  
  - 如果单纯是为了获得高的系统吞吐量,就应尽量多地选择短作业运行。

- 处理机利用率高
  
  - 如果单纯是为使处理机利用率高,应尽量多地选择计算量大的作业运行

**分时系统的目标**：

- 响应时间快
  
  - 响应时间指用户提交请求到系统首次响应为止的时间。

- 均衡性。
  
  - 系统响应时间的快慢应与用户所请求的复杂性相适应。

**实时系统的目标**：

- 截止时间的保证
  
  - 开始执行的最迟时间
  
  - 必须完成的最迟时间。

- 可预测性

## 作业与作业调度

### 作业

- 作业(Job)
  
  - 用户提交给计算机系统的任务。
  
  - 由程序、数据、作业说明书组成。

- 作业步(Job Step)
  
  - 作业执行期间所经历在加工步骤。
  
  - 典型的作业控制过程分:“编译” &quot; 链接装配“ ”运行“

- 作业控制块(Job Control Block , JCB)
  
  - 作业控制块是批处理作业存在的标志,保存有系统对于作业进行管理所需要的全部信息,位于磁盘区域中
  
  - 作业开始,系统输入程序为其建立一个作业控制块,进行初始化,大部分信息取自作业说明书。
  
  - 系统输入程序、作业调度程序、作业控制程序、系统输出程序等需要访问作业控制块。
  
  - 作业完成后,其作业控制块由系统输出程序撤消。
  
  - ![](../../../../assets/default.png)

### 作业调度

- 先来先服务算法（First Come First Serve）
  
  - FCFS是最简单的调度算法,该算法既可用于作业调度,也可用于进程调度。
  
  - 基本原则是按照作业到达系统的先后次序来选择,或者说它是优先考虑在系统中等待时间最长的作业,而不管该作业所需执行时间的长短。

- 短作业优先（Short Job First）调度算法
  
  - 对短作业或短进程优先调度的算法。可以分别用于作业调度和进程调度。
  
  - SJF算法是以作业的长短来计算优先级,作业越短,其优先级越高。
  
  - SJF调度算法:从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
  
  - 缺点
    
    - (1)必须预知作业的运行时间。
    
    - (2)对长作业非常不利,长作业的周转时间会明显地增长，更严重的是,该算法
      完全忽视作业的等待时间,可能使作业等待时间过长,出现饥饿现象。
    
    - (3)在采用SJF算法时,人一机无法实现交互。
    
    - (4)该调度算法完全未考虑作业的紧迫程度,故不能保证紧迫性作业能得到及时处理。

- 优先级调度算法（Priority-Scheduling Algorithm）
  
  - 反应作业的紧迫性

- 高响应比优先调度算法
  
  - 高响应比优先调度算法则是既考虑了作业的等待时间,又考虑作业运行时间的调度算法,因此既照顾了短作业,又不致使长作业的等待时间过长,从而改善了处理机调度的性能
  
  - 为每个作业引入一个动态优先级,即优先级是可以改变的，令它随等待时间延长而增加,这将使长作业的优先级在等待期间不断地增加,等到足够的时间后,必然有机会获得处理机。该优先级的变化规律可描述为:
    
    $$
    优先权=\frac{等待时间+要求服务时间}{要求服务时间}
    $$

- 由于等待时间与服务时间之和就是系统对该作业的响应时间,故该优先级又相当于响应比RP。据此,优先又可表示为:
  
  $$
  R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}
  $$

- 特点
  
  - (1)如果作业的等待时间相同,则要求服务的时间愈短,其优先权愈高,
    因而该算法有利于短作业。
  
  - (2)当要求服务的时间相同时,作业的优先权决定于其等待时间,等待时
    间愈长,其优先权愈高,因而它实现的是先来先服务。
  
  - (3)对于长作业,作业的优先级可以随等待时间的增加而提高，当其等待
    时间足够长时,其优先级便可升到很高，从而也可获得处理机。

## 进程调度

- 任务
  
  - 保存处理机的现场信息。
  
  - 按某种算法选取进程。
  
  - 把处理器分配给进程。

- 组成部分
  
  - 排队器
  
  - 分派器
  
  - 上下文切换器

- 调度方式
  
  - 非抢占方式：
    
    - 处理机分配给某进程后,就一直让它运行下去,决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成,或发生某事件而被阻塞时,才把处理机分配给其它进程。
    
    - 评价
      
      - 实现简单、系统开销小
      
      - 适用于大多数的批处理OS ,但在分时系统和要求比较严格的实时系统中,不宜采用这种调度方式
  
  - 抢占方式
    
    - 允许调度程序根据某种原则,去暂停某个正在执行的进程,将处理机重
      新分配给另一进程。
    
    - 在现代OS中广泛采用抢占方式,这是因为:
      
      - 对于批处理机系统,可以防止一-个长进程长时间地占用处理机,以确保处理机能为所有进程提供更为公平的服务。
      
      - 在分时系统中,只有采用抢占方式才有可能实现人一机交互
      
      - 在实时系统中,抢占方式能满足实时任务的需求。
    
    - 抢占原则
      
      - 优先权原则:优先权高的可以抢占优先权低的进程的处理机。
      
      - 短作业(进程)优先原则:短作业(进程)可以抢占长作业(进程)的处理机。
      
      - 时间片原则:各进程按时间片运行,一个时间片用完时,停止该进程执行重新进行调度。

### 调度算法

- 轮转调度算法
  
  - 在分时系统中,为保证能及时响应用户的请求,必须采用基于时间片轮转式进程调度算法。
  
  - 在早期,分时系统中采用的是简单的时间片轮转法
    
    - 系统将所有的就绪进程按FCFS策略排成一个就绪队列
    
    - 系统可设置每隔一定时间(如30 ms)便产生一次中断,去激活进程调度程序进行调度,把CPU分配给队首进程,并令其执行一个时间片。
    
    - 当它运行完毕后,又把处理机分配给就绪队列中新的队首进程,也让它执行一个时间片。
    
    - 这样,就可以保证就绪队列中的所有进程在确定的时间段内,都能获得一个时间片的处理机时间。
    
    - 在RR调度算法中,应在何时进行进程的切换,可分为两种情况:
      
      - 若一个时间片尚未用完,正在运行的进程便已经完成,就立即激活调度程序,将它从就绪队列中删除,再调度就绪队列中队首的进程运行,并启动一个新的时间片。
      
      - 在一个时间片用完时,计时器中断处理程序被激活。如果进程尚未运行完毕,调度程序将把它送往就绪队列的末尾。
    
    - 时间片大小：
      
      - 如果太小利于短作业,但是会频繁中断,进程.上下文切换,增加系统开销;
      
      - 如果太大则每个进程都能在时间片内完成,则退化为FCFS算法,无法满足交互式用户的需求。
      
      - 一个比较可取的大小是,时间片略大于一次典型的交互所需要的时间。

- 优先级调度算法
  
  - 优先级进程调度算法,是把处理机分配给就绪队列中优先级最高的进程。这时,又可进一步把该算法分成如下两种
    
    - 非抢占式优先级调度算法。
    
    - 抢占式优先级调度算法。
  
  - 优先级类型
    
    - 静态优先级是在创建进程时确定的,在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的,例如0 ~ 255中的某一整数,又把该整数称为优先数。确定进程优先级大小的依据有如下三个:
      
      - 进程类型。
      
      - 进程对资源的需求。
      
      - 用户要求。
  
  - 动态优先级
    
    - 动态优先级是指在创建进程之初,先赋予其-个优先级,然后其值随进程的推进或等待时间的增加而改变,以便获得更好的调度性能。
      
      - 若所有进程都具有相同的优先级初值,则最先进入就绪队列的进程会因其优先级变得最高,从而得到cpu ,等于FCFS。
      
      - 若所有就绪进程具有各不相同的优先级初值,那么对于优先级初值低的进程,在等待了足够的时间后,也可以获得处理机。
      
      - 也可以规定,当运行的进程随着运行时间的推移动态降低其优先级,防止一个进程长期垄断cpu。

- 多队列调度算法
  
  - 在多处理机系统中可以为每个处理机设置一个单独的就绪队列

- 多级反馈队列调度算法
  
  - 是时间片轮转算法和优先级调度算法的综合和发展,通过动态调整进程优先级和时间片大小,不必事先估计进程的执行时间。
  
  - &lt;mark&gt;FCFS+优先级+RR+抢占&lt;/mark&gt;
  
  - 多级反馈队列可兼顾多方面的系统目标,是目前公认的一种&lt;mark&gt;较好&lt;/mark&gt;的进程调度算法
  
  - 调度机制
    
    - 设置多个就绪队列并为各个队列赋予不同的优先级,第一个最高,依次降低。各个队列中进程执行时间片的大小设置为:优先权越高，时间片越短
    
    - 每个队列都采用FCFS算法。当新进程进入内存后,首先将它放入第一队列的末尾,按FCFS原则等待调度。当轮到该进程执行时,如它能在该时间片内完成,便可撤离系统。否则,即它在一个时间片结束时尚未完成,调度程序将其转入第二队列的末尾等待调度;如果它在第二队列中运行一个时间片后仍未完成,再依次将它放入第三队列, ..... 
      依此类推。当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。
    
    - 按队列优先级调度。调度程序首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列中的进程运行;换言之,仅当第1~ (i-1)所有队列均空时,才会调度第队列中的进程运行。如果处理机正在第队列中为某进程服务时又有新进程进入任-优先级较高的队列,此时须立即把正在运行的进程放回到第队列的末尾,而把处理机分配给新到的高优先级进程。
    
    - 注意
      
      - 当现行进程正在执行它的C P U周期时,如果发生了时间片中断或有进程进入更高级的就绪队列时将引起剥夺,对前一-种情况,现行进程将进入下一级队列,对后一种情况,现行进程则进入本级队列末尾。
      
      - 当一进程被唤醒时,它进入的是原先离开的那个队列，即与其当前优先级对
        应的就绪队列。
      
      - 一个进程的优先级被降低,仅发生在因时间片中断而被剥夺的时候。
    
    - ![](../../../../assets/default.png)
  
  - 多级反馈队列调度算法具有较好的性能,能较好的满足各种类用户的需要。
    
    - 终端型作业用户。大多属于较小的交互性作业,只要能使作业在第一队列的时间片内完成,便可令用户满意。
    
    - 短批处理作业用户。周转时间仍然较短,至多在第二到三队列即可完成。
    
    - 长批处理作业用户。将依次在1 ~ n级队列中轮转执行，不必担心作业长期得不到处理。

- 保证调度算法
  
  - 在系统中有n个相同类型的进程同时运行,为公平起见,须保证每个进程都获得相同的处理机时间1/n。
    
    - 跟踪计算每个进程自创建以来已经执行的处理时间。
    
    - 计算每个进程应获得的处理机时间,即自创建以来的时间除以n。
    
    - 计算进程获得处理机时间的比率,即进程实际执行的处理时间和应获得的处理机时间之比。
    
    - 比较各进程获得处理机时间的比率。如进程A的比率最低,为0.5 ,而进程B的比率为0.8 ,进程C的比率为1.2等。
    
    - 调度程序应选择比率最小的进程将处理机分配给它,并让该进程一-直运行,直到超过最接近它的进程比率为止。

- 公平共享调度算法
  
  - 分配给每个进程相同的处理机时间，显然,这对诸进程而言,是体现了一定程度的公平,但如果各个用户所拥有的进程数不同,就会发生对用户的不公平问题。
  
  - 用户1有4个进程A、B、C、D ,用户2只有一-个进程E。强制调度序列为:
    A E B E C E D E A E B E C E D E
  
  - 如果希望用户1所获得的处理机时间是用户2的2倍,则强制调度序列为:
    A B E C D E A B E C D E

## 实时调度

### 实时调度的条件

- 实时系统
  
  - 两种任务
    
    - 硬实时任务( HRT )指必须满足最后期限的限制,否则会给系统带来不可接受的破坏或者致命错误。
    
    - 软实时任务( SRT)也有一个与之关联的最后期限,并希望能满足这个期限的要求,但这并不是强制的,即使超过了最后期限,调度和完成这个任务仍然是有意义的。

- 提供必要的信息
  
  - 就绪时间。
  
  - 开始截止时间和完成截止时间。
  
  - 处理时间。
  
  - 资源要求。
  
  - 优先级。

- 系统处理能力强
  
  - 单处理机实时调度条件
    - $$
      \sum_{i+1}^{n}\frac{C_i}{P_i}\leq1
      $$
    - 其中C表示处理时间，P表示周期时间
  - 提高处理能力的途径
    - 采用单处理机系统,增强处理能力,减少每个任务处理时间;
    - 采用多处理机调度
    - $$
      \sum_{i+1}^{n}\frac{C_i}{P_i}\leq N
      $$
    - N表示处理机个数

- 采用抢占式调度机制
  
  - 在含有硬实时任务的实时系统中，广泛采用抢占机制。
  - 当一个优先权更高的任务到达时,允许将当前任务暂时挂起,令高优先权任务立即投入运行,这样可满足该硬实时任务对截止时间的要求。但此种机制较复杂。
  - 对于一些小的实时系统,如果能预知任务的开始截止时间,则对实时任务的调度可采用非抢占调度机制,以简化调度程序和对任务调度时所花费的系统开销。

- 具有快速切换机制
  
  - 为保证要求较高的硬实时任务能及时运行,在实时系统中还应具有快速切换机制,以保证任务的快速切换。需要以下两种能力:
    - 对外部中断的快速响应能力。要求系统具有快速硬件中断机构,使可在紧迫的外部事件请求中断时及时响应。
    - 快速的任务分派能力。在完成任务调度后,便应进行任务切换,为提高速度,应使系统中的运行功能单位适当的小,以减少任务切换的时间开销。

### 实时调度算法

- 分类
  
  - 根据实时任务性质,可将实时调度的算法分为:
    
    - 硬实时调度算法
    
    - 软实时调度算法
  
  - 按调度方式,则可分为: 
    
    - 非抢占调度算法
      
      - 非抢占式轮转调度算法。
      
      - 非抢占式优先调度算法。
    
    - 抢占调度算法
      
      - 基于时钟中断的抢占式优先级调度算法。
      
      - 立即抢占(Immediate Preemption)的优先级调度算法。
  
  - ![](../../../../assets/default.png)

- 最早截止时间优先（Earliest Deadline First）算法
  
  - 根据任务的截止时间来确定任务的优先级。截止时间越早,其优先级越高。
  
  - 该算法要求在系统中保持一个实时任务就绪队列,该队列按各任务截止时间的早晚排序,调度程序在选择任务时总是选择就绪队列中的第一个任务,为之分配处理机,使之投入运行。
  
  - EDF算法既可以用于抢占式调度,也可用于非抢占式调度。

- 最低松弛度优先（Least Lexity First）算法
  
  - 该算法是根据任务紧急(或松弛)的程度,来确定任务的优先级。任务的紧急程度越高,为之赋予的优先级就越高。
  
  - 例如,任务A在200ms时必须完成,本身运行时间100ms ,则必须在100ms之前调度执行, A任务的紧急(松弛)程度为100ms ,又如任务B在400ms是必须完成,需运行150ms ,其松弛程度为250ms.
  
  - 该算法主要用于抢占调度方式中。

- 优先级倒置（Priority Inversion Problem）
  
  - 形成
    
    - 当前OS广泛采用优先级调度算法和抢占方式,然而在系统中存在着影响进程运行的资源而可能产生&quot;优先级倒置”的现象,即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞

## 死锁

### 死锁概述

死锁( Deadlock ) 是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时,若无外力作用,它们都将无法再向前推进。

|     | 共同点            | 区别                                                                                                    |
| --- | -------------- | ----------------------------------------------------------------------------------------------------- |
| 死锁  | 都是进程无法向前推进的现象。 | 1.一定是循环等待对方手里的资源导致的 &lt;br/&gt;2.至少有2个或2个以上进程同时发生 &lt;br/&gt;3.进程处于阻塞态&lt;br/&gt;4.操作系统分配资源的策略不合理导致&lt;br/&gt;5.是管理者（操作系统）的问题 |
| 饥饿  |                | 1.只能由一个进程发生饥饿&lt;br/&gt;2.可能在阻塞态，也可能在就绪态&lt;br/&gt;3.操作系统分配资源的策略不合理导致&lt;br/&gt;4.是管理者（操作系统）的问题                         |
| 死循环 |                | 1.可能只有一个&lt;br/&gt;2.可以是运行态&lt;br/&gt;3.由代码逻辑错误导致的&lt;br/&gt;4.是被管理者的问题                                                 |

- 资源
  
  - 可重用性资源
    
    - 每一个可重用性资源中的单元只能分配给一个进程使用,不允许多个进程共享。进程在使用可重用性资源时,须按照这样的顺序:
      
      - 请求资源
      
      - 使用资源。
      
      - 释放资源。
    
    - 系统中每一类可重用性资源中的单元数目是相对固定的,进程在运行期间既不能创建也不能删除它。
  
  - 可消耗性资源
    
    - 可消耗性资源又称为临时性资源,它是在进程运行期间,由进程动态地创建和消耗的,它具有如下性质:
      
      - 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的,有时它可以有许多,有时可能为0 ;
      
      - 进程在运行过程中,可以不断地创造可消耗性资源的单元,将它们放入该资源类的缓冲区中,以增加该资源类的单元数目。
      
      - 进程在运行过程中,可以请求若干个可消耗性资源单元,用于进程自己
        的消耗,不再将它们返回给该资源类中。
  
  - 可抢占性资源(CPU、内存等)
    
    - 某进程在获得这类资源后,该资源可以再被其它进程或系统抢占。
  
  - 不可抢占性资源(打印机、磁带机等)
    
    - 一旦系统把某资源分配给该进程后,就不能将它强行收回,只能在进程用完后自行释放。



- 死锁原因
  
  - 竞争不可抢占性资源
  
  - 竞争可消耗资源
  
  - 进程推进顺序不当

- 产生死锁的必要条件
  
  - 互斥条件
  
  - 请求和保持条件
  
  - 不可抢占条件
  
  - 循环等待条件



### 预防死锁

预防死锁的方法是使四个必要条件中的第2、3、4条件之一不能成立来避免发生死锁。
必要条件1 ,因为它是由设备的固有条件所决定的,不仅不能改变,还应加以保证。、



- 破坏请求和保持条件
  
  - 第一种协议
    
    - 系统规定所有进程在开始运行之前,都必须-次性的申请其在整个运行过程所需的全部资源。
    
    - 优点:算法简单、易于实现且很安全。
    
    - 缺点:资源浪费严重和使进程经常会发生饥饿现象。
  
  - 第二种协议
    
    - 进程提出申请资源前必须释放已占有的一切资源。
    
    - 当一个已经保持了某些不可被抢占资源的进程,提出新的资源请求而不能得到满足时,它必须释放已经保持的所有资源,待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放,或者说是被抢占了,从而破坏了”不可抢占”条件。
    
    - 缺点：实现起来比较复杂且付出很大代价。可能会前功尽弃,反复申请和释放等情况,延长了周转时间,增加系统开销。

- 破坏循环等待条件
  
  - 采用资源顺序分配法,可以破坏循环等待条件
  
  - 采用资源顺序分配法,系统不会出现循环等待。因为在任何时刻,总有一个进程占有较高序号的资源,该进程继续请示的资源必然是空闲的。故该进程可一直向前推进。
  
  - 优点:
    
    - 有序资源分配法提高了资源利用率
  
  - 缺点:
    
    - 不方便增加新的设备,因为可能需要重新分配所有编号
    
    - 进程实际使用资源的顺序可能和编号递增顺序不一致,会导致资源浪费;
    
    - 必须按规定申请资源,用户编程麻烦,

### 避免死锁

- 系统安全状态
  
  - 该方法允许进程动态地申请资源,系统在进行资源分配之前,先计算资源分配的安全性。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程;否则不分配资源,进程必须阻塞等待。从而避免发生死锁。
  
  - 安全状态:在此状态系统能按某种顺序P1, P2... Pn来为各个进程分配其所需资源,使每个进程都可顺序地一个个地完成。这个序列{P1,P....Pn}称为安全序列。
  
  - 不安全状态:系统不存在任何一个安全序列

- 银行家算法
  
  - 银行家算法的数据结构
    
    - 可利用资源向量Available [m]
      
      - m为系统中资源种类数, Available[j] =k表示系统中第j类资源数为k个。
    
    - 最大需求矩阵Max[n][m]
      
      - n为系统中进程数, Max[i][j] =k表示进程对j类资源的最大需求数为k。
    
    - 分配矩阵Allocation[n][m]
      
      - Allocation[i][j]=k表示进程i记分得j类资源的数目为k个。
    
    - 需求矩阵Need[n][m]
      
      - Need[i][j]=k表示进程i还需要j类资源k个。
      
      - Need[i][j] =Max[i][j]-Allocation[i][j]
  
  - 内容
    
    - 设Request;[j]=k,表示进程P:需要k个R;类型的资源
    
    - 如果Request;[j] &lt;= Need[i,j],便转向步骤2 ;否则认为出错,因为它所请求的资源数已超过它所需要的最大值。
    
    - 如果Request;[j] &lt;= Available[j],便转向步骤3 ;否则,表示尚无足够资源，P需等待
    
    - 系统试探着把资源分配给进程P，并修改下面数据结构中数值
      
      - Available[j] = Available[j]- Request;[j];
      
      - Allocation[ij] = Allocation[;j]+ Request;[j];
      
      - Need[ij] =Need[ij]-Request;[j];
  
  - 安全性
    
    - (1 )设置两个向量:
      
      - 工作向量work :表示系统可提供给进程继续运行所需的各类资源数目,含有m个元素的一维数组,初始时, work =Available;
      
      - Finish:含n个元素的一维数组,表示系统是否有足够的资源分配给n个进程,使之运行完成。开始时先令Finish[i] =false (i=1..n);当有足够资源分配给进程时,再令Finish[i]=true。
    
    - ( 2 )从进程集合中找到一个能满足下述条件的进程:
      
      - Finish[i]=false;
      
      - Need[ij] &lt; =work[j];
      
      - 若找到，执行步骤( 3)，否则执行步骤( 4)。
    
    - ( 3 )当进程Pi获得资源后,可顺利执行,直至完成,并释放出分配给它的资源,故应执行:
      
      - work[j]= work[j]+ Allocation[ij] ;
      
      - Finish[i]=true;
      
      - go tostep (2);
    
    - ( 4 )如果所有进程的Finish[i] =true都满足,则表示系统处于安全状态;否则,系统处于不安全状态。

### 检查死锁

- 为了能对系统中是否已发生了死锁进行检测,在系统中必须
  
  - ①保存有关资源的请求和分配信息;
  
  - ②提供一种算法,它利用这些信息来检测系统是否已进入死锁状态。

- ![](../../../../assets/default.png)

- 死锁定理
  
  - 如果资源分配图中没有环路,则系统中没有死锁;
  
  - 如果图中存在环路则系统中可能存在死锁
    
    - 如果每个资源类中只包含一个资源实例,则环路是死锁存在的充分必要条件
    
    - 如果每个资源类中资源实例个数不全为1 , 则环路是死锁存在的必要条件

- 死锁定理2
  
  - 资源分配图化简
    
    - 找到资源分配图中一个不孤立、不阻塞的进程节点,消去请求边与分配边,使之成为孤立点。
    
    - 孤立点的资源释放后,可以分给其它进程,即将某进程的申请边变为分配边。
    
    - 重复上述过程,当资源分配图中所有进程都成为孤立点时,称该资源分配图是可以完全简化的,否则称该资源分配图是不可完全简化的。
    
    - **不孤立**:是指该进程存在有与之相连的有向边;
    
    - **不阻塞**:是指该进程除了已经分配的资源外,对它尚需要的资源,系统都能够满足,因此该进程不会被阻塞。
    
    - **孤立点**:是指该进程既无请求边,也无分配边,即没有与之相连的有向边。
  
  - &lt;mark&gt;一种资源分配状态为死锁状态的充要条件是资源分配图是不可完全简化的。&lt;/mark&gt;

### 解除死锁

- 当发现进程死锁时,便应立即把它们从死锁状态中解脱出来。常采用的方法是:
  
  - 抢占资源:从其他进程剥夺足够数量的资源给死锁进程以解除死锁状态。
  
  - 终止进程:最简单的是让全部进程都死掉;温和一点的是按照某种顺序逐个撤销进程，直至有足够的资源可用,使死锁状态消除为止。
    
    - 终止所有死锁进程
      
      - 这是一种最简单的方法,即是终止所有的死锁进程,死锁自然也就解除了,但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间,已接近结束，一旦被终止真可谓“功亏一篑”,以后还得从头再来。
    
    - 逐个终止进程
      
      - 按照某种顺序,逐个地终止进程,直至有足够的资源,以打破循环等待,把系统从死锁状态解脱出来为止。
      
      - 每终止一个进程,都需要用死锁检测算法确定系统死锁是否已经被解除,若末解除还需再终止另一个进程。
      
      - 在采取逐个终止进程策略时,还涉及到应采用什么策略选择一个要终止的进程</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter4/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第四章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第四章 存储器管理

存储器是计算机系统的重要组成部分之一。 对存储器加以有效管理,不仅直接影响存储器的利用率,而且对系统性能有重大影响。存储器管理的主要对象是内存,对外存的管理在文件管理中。

## 存储器的层次结构

- 存储器的多层结构
  
  - 理想的存储器:
    
    - 速度快
    
    - 容量大
    
    - 价格低
  
  - 现代计算机系统的存储部件实际上采用了层次结构,组成了一-个速度由快到慢,容量由小到大,价格由高到低的存储装置层次。

- 可执行存储器
  
  - 寄存器和主存储器为可执行存储器。
  
  - 进程访问可执行存储器:使用load或者store指令便可访问
  
  - 进程访问辅存：通过I/O设备实现,在访问中将涉及到中断、设备驱动程序以及物理设备的运行。

- 层次结构
  
  - 寄存器
    
    - 寄存器访问速度最快,完全能与CPU协调工作,但价格昂贵,因此容量不可能做得很大。寄存器的长度一般以字为单位。
  
  - 高速缓存
    
    - 是现代计算机结构中的一个重要部件,其容量大于或远大于寄存器,速度快于主存储器。
    
    - 根据局部性原理,将主存储器中一些经常访问的信息存放在高速缓存中,减少访问主存储器的次数,提高程序执行速度。
  
  - 主存储器
    
    - 简称内存或主存,用于保存进程运行时的程序和数据,也成为可执行存储器。
    
    - CPU的控制部件只能从主存储器中取得指令和数据,数据能够从主存储器读取并将他们装入到寄存器中,或者从寄存器存入到主存储器中。
  
  - 外存
    
    - 由于I/O速度远低于对主存的访问速度,因此加了磁盘缓存,利用它将使用频繁的部分磁盘数据和信息,暂时存放在磁盘缓存中,用以减少磁盘访问次数。
    
    - 它利用主存空间来暂存从磁盘中读出的信息。

## 程序的连接与装入

在多道程序环境下,要使程序运行,必须为之。先建立进程。创建进程的第一件事是将程序和数据装入内存。

将用户源程序变为可在内存中执行的程序的步骤:

- 编译:由编译程序将用户源代码编译成若干个目标模块

- 链接:由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块

- 装入:由装入程序将装入模块装入内存

### 程序的装入

- 绝对装入方式
  
  - 在编译时,如果知道程序驻留在内存的什么位置,那么编译程序将产生绝对地址的目标代码。
  
  - 装入模块装入内存后,程序中的逻辑地址与实际内存地址完全相同,不须对程序和数据的地址进行修改。
    
    - 程序中所使用的绝对地址,可在编译或汇编时给出,也可由程序员赋予。
    
    - 只适合于单道程序环境

- 可重定位装入方式（Relocation Loading Mode）
  
  - 在多道程序环境下,可重定位装入方式,根据内存的当前情况,将装入模块装入到内存的适当位置。
    
    - 注意:在采用可重定位装入方式将装入模块装入内存后,会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同。
  
  - 在装入时对目标程序中指令和数据的修改过程称为重定位。地址变换在装入时一次完成,以后不再改变,称为静态重定位。

- 动态运行时的装入程序
  
  - 在把装入模块装入内存后,并不立即把装入模块中的相对地址转换为绝对地址,而是把这种地址转换推迟到程序真正要执行时(访问内存之前)才进行。
  
  - 装入内存后的所有地址都仍是相对地址。
  
  - 为使地址转换不影响指令的执行速度,应设置一个重定位寄存器。
  
  - 重定位寄存器:存放装入模块的起始位置

### 程序的链接

- 静态链接方式
  
  - 在程序运行前,将目标模块及所需的库函数链接成一个完整的装配模块 ,以后不再拆开。
  
  - 将目标模块装配成装入模块时需解决的两个问题:
    
    - 对相对地址进行修改
    
    - 变换外部调用符号
  
  - 库有两种:静态库和动态库。windows. 上对应的是.lib .dll、 linux. 上对应的是.a .so
    
    - 静态库
      
      - :在链接阶段,会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
      
      - 静态库对函数库的链接是放在编译时期完成的程序在运行时与函数库再无瓜葛,移植方便。
      
      - 浪费空间和资源,因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件
    
    - 动态库
      
      - 动态库在程序编译时并不会被连接到目标;代码中,而是在程序运行时才被载入。
      
      - 不同的应用程序如果调用相同的库,那么在内存里只需要有一份该共享库的实例,规避了空间浪费问题。

- 装入时动态链接
  
  - 用户源程序经编译后所得的目标模块,是在装入内存时,边装入边链接的,即在装入一个目标模块时,若发生一个外部模块调用事件,将引起装入程序去找出相应的外部目标模块,并将它装入内存,还要修改目标模块中的相对地址
  
  - 优点:
    
    - 便于修改和更新
    
    - 便于实现对目标模块的共享。

- 运行时动态链接
  
  - 运行时动态链接是将对某些模块的链接推迟到执行时才执行,即在执行过程中,当发现一个被调用模块尚未装入内存时,立即由OS去找到该模块并将之装入内存,把它链接到调用者模块上。
  
  - 凡执行过程中未被用到的目标模块,不会调入内存和链接,这样不仅加快程序的装入过程。而月节省大量的内存空间.

## 连续分配存储方式

连续分配方式:为一个用户程序分配一个连续的存储空间。

### 单一连续分配

- 最简单,只适用于单用户、单任务系统,内存只有一道用户程序

- 内存分为两部分:
  
  - 系统区
    
    - 内存的低址部分,仅供OS使用
    
    - 不一定需要内存保护
  
  - 用户区
    
    - 系统区以外的全部内存空间,供用户程序使用,存储器利用率低

### 固定分区分配

将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业,便可以有多道作业并发执行。
当有一空闲分区时,便可以再从外存的后备作业队列中，选择一个适当大小的作业装入该分区，当该作业结束时，可再从后备作业队列中找出另一作业调入该分区。

- 划分分区
  
  - 分区大小相等
    
    - 适用于控制多个相同对象的场合
    
    - 缺乏灵活性,小程序浪费空间,大程序无法装入
  
  - 分区大小不等
    
    - 解决了灵活性问题,将内存分为多个大小不等的分区:小分区(较多) ,中等分区(适量) ,大分区(少量)

- 内存分配
  
  - 分区说明表
    
    - 用于管理和分配内存的数据结构。
    
    - 每个表项对应一个分区,记载着这个分区的序号、空间大小、起始地址和使用状况。
  
  - 分配过程
    
    - 当有一用户程序要装入时，由内存分配程序检索该表,从中找出一-个能满足要求的、尚未分配的分区,将之分配给该程序,然后将该表项中的状态置为“已分配”; 
    
    - 若未找到大小足够的分区,则拒绝为该用户程序分配内存。

### 动态分区分配

动态分区法在作业执行前并不建立分区,分区的建立是在作业的处理过程中进行的,且其大小可随作业或进程对内存的要求而改变。
这就改变了固定分区法中那种即使是小作业也要占据大分区的浪费现象,从而提高了内存的利用率。
采用动态分区法,在系统初启时,除了操作系统中常驻内存部分之外,只有一-个空闲分区。随后,分配程序将该区依次划分给调度选中的作业或进程。

- 在实现过程中涉及如下问题:
  
  - 分区分配中的数据结构
    
    - 空闲分区表
      
      - 在系统中设置-一张空闲区表,每个表目记录-个空闲区,主要参数包括分区号、长度和起始地址。
    
    - 空闲分区链
      
      - 在每个分区的起始部分,设置一些用于控制分区分配的信息,以及用于链接各分区所用的前向指针;在分区尾部则设置一后向指针,将所有的空闲分区链接成一个双向链。
  
  - 分区分配算法
    
    - 把一个新作业装入内存时,须按照一 定的动态分区分配算法,从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究。
    
    - 基于顺序搜索的动态分区分配算法
      
      - 首次适应算法（First Fit）
        
        - 要求按地址递增的次序组织空闲区表(链)。
        
        - 申请和分配:从低地址找起,直至找到-个能可满足要求的空闲分区,根据作业大小划出一-块给申请者,剩余空间仍留在空闲链中,成为一个小的空闲分区。
        
        - 优点:
          
          - 优先使用内存中低址部分的小空闲区，从而保留了高址部分的大空闲区,有利于大作业。
        
        - 缺点:
          
          - 低址部分不断被划分,形成许多难以利用的小空闲分区(碎片) ,造成间浪费
          
          - 碎片聚集在低址区域,每次又从低址开始查找,增加时间开销
      
      - 循环首次适应算法（Next Fit）
        
        - 是FF算法的演变和改进，每次分配不再从空闲分区链(表)的开始找起,而是从上次找到的空闲分区的下一个找起,找到一个能满足要求的空闲区。
        
        - 需增设一个起始查寻指针,指示下一次查找从那个空闲分区开始。
        
        - 优点:使空闲分区分布均匀,减少查找开销
        
        - 缺点:缺乏大空闲分区,不利于大作业
      
      - 最佳适应算法（Best Fit）
        
        - &#39;最佳”的含义:把能满足要求的最小空闲分区分配给作业,避免“大材小
          用”
        
        - 空闲分区链组织方式:按容量从小到大
        
        - 优点:尽量使用小空闲区,保留大空闲区
        
        - 孤立地看,对每个程序,分区大小是最合适的,浪费最小
        
        - 宏观上看，每次分配切割下来的剩余部分最小,因此会形成许多难以利用的碎片
      
      - 最坏适应算法(Worst Fit)
        
        - 总是挑选最大的空闲分区分割给作业使用
        
        - 空闲分区链组织方式:按容量从大到小
        
        - 优点:
          
          - 防止产生碎片,空间浪费最少有利于中、小作业
          
          - 查找效率很高(只需查找第一块)
        
        - 缺点
          
          - 缺乏大的空闲分区
    
    - 基于索引搜索的动态分区分配算法
      
      - 快速适应算法
        
        - 也称分类搜索法
        
        - 将空闲分区按大小分类,每类具有相同容量，放入一个空闲分区链表
        
        - 增设一张管理索引表,每个表项对应一个分类,并记录相应链表的表头指针
        
        - 即:按分区容量大小，分类索引、搜索
        
        - 优点:
          
          - 查找效率高,仅需要根据进程的长度,寻找到能容纳它的最小空闲区链表,并取下第一块进行分配即可。
        
        - 缺点:
          
          - 在分区归还主存时算法复杂,系统开销较大
          
          - 浪费空间,空闲分区划分越细,浪费则越严重。
      
      - 伙伴系统
        
        - 无论已分配分区或空闲分区,分区大小必须是2的k次幂，k为整数, I≤k≤m
        
        - 2&lt;sup&gt;m&lt;/sup&gt;表示最大分区大小,通常是整个可分配内存的大小
        
        - 每次切分必须对半分(分开的两半称之为一对伙伴)
        
        - 每次合并必须与其伙伴合并
        
        - 分配过程：
          
          - 首先计算一个i值 ,使2&lt;sup&gt;i-1&lt;/sup&gt;&lt;n&lt;=2&lt;sup&gt;i&lt;/sup&gt;
          
          - 在分区大小为2&lt;sup&gt;i&lt;/sup&gt;的空闲分区链表中查找，找到则分配，否则转3
          
          - 查找分区大小为2i+1的空闲分区链表,若存在空闲分区,则将其划分为两个大小相同(2&lt;sup&gt;i&lt;/sup&gt;)的分区(一对伙伴) , 一个用于分配，一个加入到分区大小为2的空闲分区链表。若仍然找不到, 转4
          
          - 继续查找大小为2&lt;sup&gt;i+2&lt;/sup&gt;的空闲分区链表,此时需要进行两次划分
          
          - 以此类推
        
        - 回收
          
          - 回收时,与其伙伴分区合并一次回收可能进行多次合并
        
        - 性能
          
          - 时间开销:查找、分割、合并空闲分区
      
      - 哈希算法
        
        - 哈希算法就是利用哈希快速查找优点,以及空闲分区在可利用空间表中的分布规律,建立哈希函数,构造一张以空闲分区大小为关键字的哈希表,该表的每一个表项记录了一个对应的空闲分区链表表头指针。
        
        - 当进行空闲分区分配时,根据所需要的分区大小,通过哈希函数计算,即得到在哈希表中的位置,从中得到相应的空闲分区链表,实现最佳分配策略。
  
  - 分区分配及回收操作
    
    - **分配**：利用某种分配算法,从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size ,表中每个空闲分区的大小表示为m.size ,若m.size- u.sizessize(规定的不再切割的分区大小, 将整个分区分配给请求者,否则从分区中按请求的大小划出一块内存空间分配出去,余下部分留在空闲链中,将分配区首址返回给调用者。
    
    - **回收**：当某一个用户作业完成释放所占分区时,系统应进行回收。在可变式分区
      中,应该检查回收区与内存中前后空闲区是否相邻
      
      - 若相邻,则应进行合并,形成一个较大的空闲区,并对相应的链表指针进行修改
      
      - 若不相邻,应将空闲区插入到空闲区链表的适当位置。

### 动态重定位分区分配

动态分区分配方式,要求把一个系统程序或用户程序装入一个连续的内存空间中。
随着各进程不断申请和释放内存,导致在内存中出现大量分散的小空闲区。
内存中这种容量太小、无法利用的小分区称做&lt;mark&gt;(外部)“碎片&quot;&lt;/mark&gt;或“零头”

**碎片**：

- 内部碎片:指已分配给作业的存储空间中未被利用的部分。如固定分区中存在的碎片。

- 外部碎片:指系统中无法利用的小空闲分区。如动态分区中存在的碎片。

**动态重定位分区分配**

- 将内存中所有作业移到内存一端(作业在内存中的位置发生了变化,这就必须对其地址加以修改或变换,即重定位) , 使本来分散的多个小空闲分区连成一个大的空闲区

- 这种通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为拼接或紧凑。

- 拼接时机:
  
  - 分区回收时;当找不到足够大的空闲分区,且总空闲分区容量可以满足作业要求时。
  
  - 定时。

- 实现
  
  - 作业被装入内存后所有地址仍然是相对地址,将相对地址转换为物理地址的工作,被推迟到程序指令真正执行时。
  
  - 需要硬件地址变换机构的支持
  
  - 重定位寄存器,保存作业在内存中的起始地址
  
  - “紧凑”之后,程序移动了位置,只需更改重定位寄存器的内容为新的起始地址

![](../../../../assets/default.png)

## 对换

- 问题
  
  - 内存中被阻塞的进程占用大量空间,外存，上却有许多作业因为内存不足而等待。

- 对换
  
  - 把内存中暂时不能运行的进程或暂时不用的程序和数据调出到外存上,以便腾出足够的内存空间

- 类型
  
  - 进程
    
    - “整体对换”, &quot;进程对换”,常用于中级调度、分时系统
  
  - “页”或&quot;段”
    
    - &quot;页面对换”或&quot;分段对换”,统称“部分对换”,用于支持虚拟存储系统

- 空间管理
  
  - 一般从磁盘上划出一块空间作为对换区使用
  
  - 在系统中设置相应的数据结构以记录外存的使用情况
  
  - 对换空间的分配与回收,与动态分区方式时的内存分配与回收雷同。

- 进程的换入与换出
  
  - 进程的换出
    
    - 选择换出进程的优先次序
      
      - 阻塞&gt;睡眠&gt;优先级&amp;驻留时间&gt;就绪进程
    
    - 换出过程
      
      - 申请对换空间(外存)
      
      - 启动磁盘并传送数据
      
      - 回收内存空间
      
      - 修改数据结构
  
  - 进程的换入
    
    - 选择
      
      - “就绪”已换出&gt;换出最久
    
    - 换入过程
      
      - 申请内存
      
      - 申请成功,直接调入
      
      - 申请失败,先换出,再换入
  
  - 对换伴随着较大的系统开销
    
    - CPU时间
    
    - I/O开销
  
  - 不必要的对换可能导致系统性能下降
  
  - 常用方案：正常时并不启用对换,内存紧张时,启用对换,把部分进程调出,缓解紧张状况后,暂停对换程序

## 分页存储

- 连续分配方式的缺点:
  
  - 会形成许多“碎片”
  
  - “紧凑”产生较大开销

- 离散分配方式
  
  - 允许将一个进程分散地装入多个不相邻的分区,从而无需“紧凑”。
  
  - 可按离散分配的基本单位，分为两种方式:
    
    - 分页存储管理方式
    
    - 分段存储管理方式
    
    - 段页式存储管理方式

**页面**

- 把进程的逻辑地址空间划分成若干大小相等的区域,每个区域称作**页面**或**页**。每个页都有一个编号,叫做页号。页号一般从0开始编号,如0 , 1, 2, ...等。

- 把内存空间划分成若3 F和页大小相同的物理块，这些物理块叫**页框**(frame)或(物理)块。同样,每个物理块也有一个编号，块号从0开始依次顺序排列。

- 以**页**为单位进行内存分配,并按进程的页数多少来分配。逻辑上相邻的页,物理上不- 定相邻。

- **“页内碎片”**：最后一页装不满而形成的碎片,不可利用。

**页面大小**

- 页太大，页表短，管理开销小,内碎片大,内存利用率低

- 页太小:内碎片小,内存利用率高，但页面数目多,使页表过长,占大量内存，管理开销大

- 页面大小由硬件地址结构决定,机器确定,页面大小就确定了

- 一般来说，页面大小为2的若干次幂,根据计算机结构的不同,其大小从1 KB到8KB不等。

**地址结构**：

- 分页地址中的地址结构如下:

- ![](../../../../assets/default.png)

- 地址长度32位:

- 0~11位为位移量(页内地址)，即每页的大小为4KB

- 12-31位为页号,地址空间最多允许有1 M页

- 对于某特定的机器,其地址结构是一定的。

- 如果给定的逻辑地址是A ,页面的大小为L ,则:
  
  - &lt;mark&gt;页号P = INT[A/L]&lt;/mark&gt;
  
  - &lt;mark&gt;页内地址d = [A] MOD L&lt;/mark&gt;

**页表**

- 进程的每一页离散地存储在内存的任一存储块中,为方便查找,系统为每一进程建立一张页面映像表,简称页表。

- 页表实现了从页号到物理块号的地址映射。

**地址变化机构**

- 由于页内地址和(块内)物理地址是一-对应的 ,地址变换机构的任务实际上是将逻辑地址中的页号转换为内存中的物理块号。
  
  - 基本的地址变换机构
    
    - 页表寄存器PTR
      
      - 每个进程对应一个页表，页表驻留在内存中,页表始址和长度存放在PCB中，进程被调度时,这两个数据被装入页表寄存器
    
    - 地址变换处理
      
      - 得到页号:自动将逻辑地址分为页号和页内地址
      
      - 用页号查页表,得到块号
      
      - 将块号与页内地址拼接,即得物理地址
    
    - 越界保护
      
      - 查页表前,将页号与PTR中的页表长度比较,超出(&gt; =)则越界
  
  - 具有快表的地址变换机构
    
    - 对于基本的地址变换机构(无快表) ,每存取一个数据,需要访问两次内存
      
      - 访问页表=&gt;数据所在的块号,形成物理地址
      
      - 访问数据所在的物理地址=&gt;数据
    
    - 增设一个联想寄存器(快表TLB )
      
      - 具有并行查询能力的高速缓冲寄存器
      
      - 存放当前访问的那些页表项
      
      - 每次地址变换时,先在快表中查找页号
      
      - 快表中找不到,再访问内存中的页表,并将页表项存入快表,若快表已满,应换出最老的页表项
    
    - 命中率:第3步时,在快表中查找成功的概率。

**局部性原理**

- 时间局部性:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)

- 空间局部性:一旦程序访问了某个存储单元,在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)

**访问内存的有效时间：**

- 进程发出指定逻辑地址的访问请求,到在内存中找到对应的实际物理地址单元并取出数据,所需要花费的总时间,为内存的有效访问时间(EAT)。

- 假设访问一次内存的时间为t ,在基本分页存储管理方式中,有效访问时间为
  
  - EAT=t+t=2t

- 在引入快表的分页存储管理方式中,有效访问时间的计算公式即为:
  
  - EAT =axλ+ (t+λ)(1-a)+t=2t+λ-txa
  
  - λ表示查找快表所需要的时间, a表示命中率, t表示访问一次内存所需要的时间。

**两级和多级页表**

- 现代计算机系统都支持非常大的逻辑地址空间(232~264) ,页表就非常大，需占用较大的地址空间。

- 解决方法:
  
  - 采用离散方式存储
  
  - 只将当前所需页表项调入内存

- 二级页表
  
  - 将页表分页,并离散地将各个页面分别存放在不同的物理块中,同时为离散分配的页表再建立一张页表,称为外层页表,其每个页表项记录了页表页面的物理块号。

- ![](../../../../assets/default.png)
  
  - 上述方法用离散分配空间解决了大页表无需大片存储空间的问题,但并未减少页表所占的内存空间。
  
  - 解决方法:
    
    - 把当前需要的一批页表项调入内存,以后再根据需要陆续调入。在采用两级页表结构的情况下,对正在运行的进程,必须将其外层页表调入内存,而对页表则只需调入一页或几页。
    
    - 这就需要在外层页表项中增设一个状态位S ,用于表示该页表是否内存调入内存。

- 多级页表
  
  - 二级页表的扩展,对外层页表再分页

**反置页表**

- 反置页表是为每一个物理块设置一个页表项并将按物理块号排序,其中的内容则是页号及其隶属进程的标志符。

- 所有进程共同使用一张页表

- ![](../../../../assets/default.png)

## 分段存储

- 引入
  
  - 分页从根本.上克服了外部碎片(地址空间、物理空间都分割)。内存利用率提高。
  
  - 缺点
    
    - 无论信息内容如何,按页长分割,分割后装入内存,有可能使逻辑完整的信息分到不同的页面, 执行速度降低
  
  - 所以考虑以逻辑单位分配内存。
  
  - 分页主要是为了提高系统资源利用率
  
  - 分段主要是为了满足用户(程序员)的需求
    
    - 方便编程.
    
    - 信息共享
    
    - 信息保护
    
    - 动态增长或者动态链接

- 分段
  
  - 进程的地址空间:按照程序自身的逻辑关系划分为若干个段,每个段都有一个段名(在低级语言中,程序员使用段名来编程),通常用段号代替段名,每段从0开始编址,段内地址是连续的。
  
  - 段长由逻辑信息组的长度决定,逻辑地址由段号(段名)和段内地址所组成。

- 段表
  
  - 分段式存储管理:以段为单位分配内存,每一个段在内存中占据连续空间,各段之间可以不连续存放。
  
  - 为使程序正常运行,须在系统中为每个进程建立一张段映射表,简称&quot;段表”。每个段在表中占有一个表项。
  
  - 段表结构:段号;段在内存中的起始地址(基址) ;段长。
  
  - 段表可以存放在寄存器中,但更多的是存放在内存中。
  
  - 段表用于实现从逻辑段到物理内存区的映射。

- 分页与分段
  
  - 相似点
    
    - 采用离散分配方式,通过地址映射机构实现地址变换
  
  - 不同点
    
    - 页是信息的物理单位,分页是为了满足系统的需要;段是信息的逻辑单位，含有意义相对完整的信息,是为了满足用户的需要。
    
    - 页的大小固定且由系统确定,由系统把逻辑地址分为页号和页内地址,由机器硬件实现;段的长度不固定,取决于用户程序,编译程序对源程序编译时根据信息的性质划分。
    
    - 分页的作业地址空间是一维的;分段的作业地址空间是二维的。

- 信息共享
  
  - 分段系统的一个突出优点是易于实现段的共享和保护,允许若干个进程共享一个或多个分段，且对段的保护十分简单易行。
  
  - 分页系统中虽然也能实现程序和数据的共享,但远不如分段系统方便。
  
  - 分页系统的信息共享
    
    - 共享页面时只需要在物理内存中保存一个编辑器的拷贝。
    
    - 每个用户的页表映射到编辑器的同一物理拷贝,而数据页映射到不同的块。
  
  - 分段系统的信息共享
    
    - 在分段系统中,实现共享十分容易,只需在每个进程的段表中为共享程序设置一个段表项。

### 段页式存储

- 作业地址空间进行段式管理。( 面向用户 )

- 每段内再分成若干大小固定的页,每段都从零开始为自己的各页依次编写连续的页号。

- 对内存空间的管理仍然和分页存储管理一样,将其分成若干个和页面大小相同的物理块。(面向机器 )

- 作业的逻辑地址包括3个部分:段号、页号和页内位移。

- 为实现地址变换,段页式系统设立了段表和页表。

![](../../../../assets/default.png)</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter5/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第五章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第五章 虚拟存储器

虚拟存储器:是指具有请求调入功能和置换功能,能从逻辑.上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定,其运行速度接近于内存速度，而每位的成本却接近于外存。

## 概述

- 常规处理器管理方式的特征
  
  - 一次性
    
    - 作业必须一次性全部装入内存后才能开始运行。
    
    - 这会造成两个问题:
      
      - 作业很大时,不能全部装入内存,导致大作业无法运行
      
      - 当大量作业要求运行时,由于内存无法容纳所有作业,因此只有少量作业能运行,导致多道程序并发度下降。
  
  - 驻留性: 
    
    - 一旦作业被装入内存,就会一直驻留在内存中,直至作业运行结束。
    
    - 事实上,在一个时间段内,只需要访问作业的一小部分数据即可正常运行,这就导致了内存中会驻留大量的、暂时用不到的数据,浪费了宝贵的内存资源。
  
  - 局部性
    
    - 基于局部性原理,在程序装入时,可以将程序中很快会用到的部分装入内存,暂时用不到的部分留在外存,就可以让程序开始执行。
    
    - 在程序执行过程中,当所访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,然后继续执行程序。
    
    - 若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下在用户看来似乎有一个比实际内存大得多的内存,这就是虚拟内存

虚拟内存的最大容量是计算机的地址结构, CPU寻址范围决定的。
&lt;mark&gt;虚拟内存的实际容量是内存与外存之和, CPU寻址范围,两者的最小值&lt;/mark&gt;

- 虚拟存储器的特征
  
  - 多次性
    
    - 一个作业被分成多次调入内存运行。多次性是虚拟存储器最重要的特征,与常规存储器管理的一次性相对应。
  
  - 对换性
    
    - 系统允许作业在运行过程中进行换进、换出操作。换进和换出能有效地提高内存利用率。
  
  - 虚拟性
    
    - 虚拟性是指从逻辑上扩充内存容量,并非实际存在。用户感觉到的很大的虚拟存储容量实际上是一种“假象”

&lt;mark&gt;虚拟存储器的实现都是建立在离散分配的存储管理方式的基础上。&lt;/mark&gt;

## 请求分页系统

- 在分页系统的基础上,增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。置换时以页面为单位。

- 为实现请求调页和置换功能,系统必须提供必要的支持:
  
  - 硬件支持:
    
    - 请求分页的页表机制
      
      - 在请求分页系统中所需要的主要数据结构是页表。其基本作用仍然是将用户地址空间中的逻辑地址变换为内存空间中的物理地址。
      
      - 由于只将应用程序的一部分调入内存,还有一部分仍在盘上,故需在页表中再增加若干项,供程序(数据)在换进、换出时参考。
      
      - ![](../../../../assets/default.png)
    
    - 缺页中断机构
      
      - 在请求分页系统中,每当要访问的页面不在内存时,便产生一缺页中断,请求OS将所缺之页调入内存。
      
      - 缺页中断作为中断,同样需要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。
      
      - 但缺页中断是一种特殊的中断,与一般中断有明显区别:
        
        - 缺页中断在指令执行期间产生和处理中断信号,而一般中断在一条指令执行完后检查和处理中断信号。
        
        - 缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行。
        
        - 一条指令在执行期间,可能产生多次缺页中断。
    
    - 地址变换机构
      
      - 请求分页系统中的地址变换机构,是在分页系统地址变换机构的基础上,再为实现虚拟存储器而增加了某些功能而形成的,如产生和处理缺页中断,以及从内存中换出一页的功能等。
  
  - 软件支持:
    
    - 实现请求调页的软件
    
    - 实现页面置换的软件

- 请求分页中的内存分配
  
  - 最小物理块数的确定
    
    - 最小物理块数,指能保证进程正常运行所需的最小物理块数。当系统为进程分配的物理块数少于此值时,进程将无法运行。
    
    - 进程应获得的最小物理块数与计算机的硬件结构有关,取决于指令的格式、功能和寻址方式。
  
  - 物理块的分配策略
    
    - 在请求分页系统中,可采取两种内存分配策略:
      
      - 固定分配策略:为每个进程分配一定数目的物理块,在整个运行期间不再改变
      
      - 可变分配策略:先为每个进程分配一定数量的物理块,在整个运行期间可适当增多或减少。
    
    - 在进行置换时,也可采取两种策略
      
      - 全局置换:发生缺页时,只选进程自己的物理块置换
      
      - 局部置换:可以将操作系统保留的空闲物理快分配给进程,也可以将别的进程持有的物理块置换到外存,再分配给缺页进程。
    
    - 组合出的三种策略：
      
      - 固定分配局部置换(Fixed Allocation , Local Replacement)
        
        - 为每个进程分配一定数目的物理块,在整个运行期间不再改变。
        
        - 采用该策略时,如果进程在运行中发现缺页,只能从该进程在内存中的n个页面中选出一页换出,然后再调入一页。
        
        - 困难:应为每个进程分配多少个物理块难以确定。
      
      - 可变分配全局置换(Variable Allocation , Global Replacement)
        
        - 在采用这种策略时,先为系统中的每个进程分配一定数目的物理块,而OS自身也保持一个空闲的物理块队列。
        
        - 如果某进程发生缺页时,由系统从空闲的物理块队列中,取出一个物理块分配给该进程,并将欲调入的页装入其中。
        
        - 当空闲物理块队列中的物理块用完后, OS才能从系统中的任一进程中选择一页调出。
      
      - 可变分配局部置换(Variable Allocation , Local Replacement)
        
        - 为每个进程分配一定数目的物理块,如果某进程发生缺页时,只允许从该进程在内存的页面中选出一页换出,不会影响其他进程执行。
        
        - 如果进程在运行中频繁发生缺页中断,则系统再为进程分配若干物理块
        
        - 如果进程在运行中缺页率特别低,则适当减少分配给该进程的物理块。
  
  - 物理块的分配算法
    
    - 在采用固定分配策略时,如何将系统中可供分配的物理块分配给各个进程，可采用以下几种算法:
      
      - 平均分配算法:将系统中所有可供分配的物理块,平均分配给各个进程。
      
      - 按比例分配算法:根据进程的大小按比例分配物理块。
        
        - 设系统中共有n个进程,每个进程的页面数为Si ,则系统中各进程页面数的总和为:
          
          $$
          S=\sum_{i+1}^{n}S^i
          $$
        
        - 又假定系统中可用的物理块总数为m ,则每个进程所能分到的物理块数为bi ,将有
          
          $$
          b_i=\frac{S_i}{S}*m  
          $$
        
        - bi应该取整,必须大于最小物理块数。
    
    - 考虑优先权的分配算法:在实际应用中,为了照顾重要的、急迫的作业尽快完成,为它分配较多的内存空间
      
      - 方法:
        - 把内存中可供分配的物理块分为两部分:
          - 一部分按比例分配给各进程;
          - 一部分则根据各进程的优先权,适当地增加其相应份额,分配给各进程。

- 页面调入策略
  
  - 何时调入页面
    
    - 预调页策略
      - 采用以预测为基础的预调页策略,将那些预计在不久之后便会被访问的页面,预先调入内存。
      - 主要用于进程的首次调入时 ,由程序员指出应该先调入哪些页。
    - 请求调页策略
      - 当程序在运行中需要访问某部分程序和数据时,若发现其所在的页面不在内存,便立即提出请求,由OS将其所需要的页面调入内存。
      - 优点：由请求调页策略所确定调入的页, 一定会被访问;请求调页策略比较容易实现。
      - 缺点:每次仅调入一页,需花费较大的系统开销,增加了磁盘I/O的启动频率。
  
  - 从何处调入页面
    
    - 系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面,以提高调页速度。
    - 系统缺少足够的对换区空间,则将不会被修改的文件直接从文件区调入,将可能会被修改调到对换区。
  
  - 如何进行调入
    
    - 每当程序所要访问的页面未在内存时,便向CPU发出一缺页中断,中断处理程序首先保护CPU环境,分析中断原因后,转入缺页中断处理程序。
    - 程序通过查找页表,得到该页在外存上的物理块后,如果此时内存能容纳新页则启动磁盘I/O将所缺之页调入内存,然后修改页表。
    - 如果内存已满,则需按照某种置换算法从内存中选出一页准备换出;如果该页未被修改过,可不必写回磁盘;但如果此页已被修改,则必须将它写回磁盘,然后把所缺的页调入内存,并修改页表中的相应表项,置其存在位为“1&quot; , 并将此页表项写入快表。
    - 在缺页调入内存后,利用修改后的页表,形成所要访问的物理地址,再去访问内存数据。整个页面调入过程对用户是透明的
  
  - 缺页率
    
    - 假设一个进程的逻辑空间为n页,系统为其分配的内存物理块数为m(m≤n)。
    
    - 如果在进程的运行过程中,访问页面成功(即所访问页面在内存中)的次数为S ,访问页面失败(即所访问页面不在内存中,需要从外存调入)的次数为F ,则该进程总的页面访问次数为A= S+ F
    
    - 那么该进程在其运行过程中的缺页率即为
      
      $$
      缺页率=\frac{缺页次数}{访问总次数}
      $$
    
    - 影响缺页率的因素:
      
      - 页面大小
      - 进程所分配页框的数目
      - 页面置换算法
      - 程序固有属性

- 请求分段系统
  
  - 在分段系统的基础.上,增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统。置换时以段为单位。
  
  - 为实现请求调段和置换功能,系统必须提供必要的支持:
    
    - 硬件支持:
      
      - 请求分段的段表机制
      
      - 缺段中断机构
      
      - 地址变换机构
    
    - 软件支持:
      
      - 实现请求调段的软件
      
      - 实现段的置换的软件

## 页面置换算法

在程序执行过程中,当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存,然后继续执行程序。
若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存用页面置换算法决定应该换出哪个页面

页面的换入、换出需要磁盘I/O ,会有较大的开销,因此好的页面置换算法应该追求更少的缺页率

- 最佳置换算法
  
  - 其所选择的被淘汰页面，将是以后永不再用的,或许是在最长(未来)时间内不再被访问的页面。
  
  - 优点:保证获得最低的缺页率
  
  - 缺点:无法预知一-个进程在内存的若干个页面,哪个在未来最长时间内不再被访问。
  
  - 算法无法实现，但可评价其他算法。

- 先入先出页面（FIFO）置换算法
  
  - 算法总是淘汰最先进入内存的页面,即选择在内存中驻留时间最久的页面予以淘汰。
  
  - 算法实现简单,只需把一个进程已调入内存的页面,按先后次序链接成一个队列,并设置一个指针(替换指针) ,使它总是指向最老的页面。
  
  - 算法与进程的实际运行规律不相适应,因为进程中的某些页面经常被访问,但先进先出置换算法不能保证这些页面不被淘汰。
  
  - **Belady现象**
    
    - 采用FIFO算法时,如果对一个进程未分配它所要求的全部页面,有时就会出现分配的页面数增多但缺页率反而提高的异常现象。
    
    - Belady现象的原因是FIFO算法的置换特征与进程访问内存的动态特征是矛盾的,即被置换的页面并不是进程不会访问的,因而FIFO并不是- -个好的置换算法。

- 最近最久未使用（LeastRecently Used）算法
  
  - 算法根据页面调入内存后的使用情况进行决策。由于无法预测各页面将来的使用情况,只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。
  
  - 该算法赋予每个页面一个访问字段,用来记录一个页面自上次被访问以来所经历的时间t ,当需淘汰一个页面时,选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。
  
  - 需有以下两类硬件之一的支持:
    
    - 寄存器
      
      - 为每个在内存中的页面配置一个移位寄存器,用来记录某进程在内存中各页的使用情况。移位寄存器表示为
      
      - $$
        R= R_{n-1}R_{n-2}R_{n-3}\cdots R_2R_1R_0
        $$
      
      - 当进程访问某物理块时,要将相应寄存器的R.1位置成1。此时,定时信号将每隔一定时间将寄存器右移一位。如果把n位寄存器的数看作一个整数,那么具有最小数值的寄存器所对应的页面,就是最近最久未使用的页面。
    
    - 栈
      
      - 利用一个特殊的栈来保存当前使用的各个页面的页面号
      
      - 每当进程访问某页面时,**便将该页面的页面号从栈中移出,将它压入栈顶**。
      
      - 栈顶始终是最新被访问页面的编号,而栈底则是最近最久未使用页面的页面号。

- 最少使用置换（Least Frequently Used)算法
  
  - 在采用LFU算法时,应为在内存中的每个页面设置一个移位寄存器,用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。

- 简单的Clock置换算法
  
  - 当采用简单Clock算法时,只需为每页设置一位访问位,再将内存中的所有页面都通过链接指针链接成一个循环队列。
  
  - 当某页被访问时,其访问位被置1。
  
  - 置换算法在选择一页淘汰时,只需检查页的访问位。如果是0 ,就选择该页换出;若为1 ,则重新将它置0 ,暂不换出,而给该页第二次驻留内存的机会
  
  - 再按照FIFO算法检查下一个页面。
  
  - 当检查到队列中的最后一个页面时,若其访问位仍为1 ,则再返回到队首去检查第一个页面。
  
  - 因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描

- 改进型CLock算法
  
  - 在将一个页面换出时,如果该页已被修改过,便须将该页重新写回到磁盘上;但如果该页未被修改过,则不必将它拷回磁盘。
  
  - 在改进型Clock算法中,除须考虑页面的使用情况外,还须再增加一个因素,即置换代价,这样,选择页面换出时,既要是未使用过的页面,又要是未被修改过的页面。
  
  - 把同时满足这两个条件的页面作为首选淘汰的页面。
  
  - 由访问位A和修改位M可以组合成下面四种类型的页面:
    
    - 1类(A=0 , M=0) :表示该页最近既未被访问,又未被修改,是最佳淘汰页。
    
    - 2类(A=0 , M=1) :表示该页最近未被访问,但已被修改,并不是很好的淘汰页。
    
    - 3类(A=1 , M=0) :表示该页最近已被访问,但未被修改,该页有可能再被访问。
    
    - 4类(A=1 , M=1) :表示该页最近已被访问且被修改,该页可能再被访问。
  
  - (1)从指针所指示的当前位置开始,扫描循环队列,寻找A=0且M=0的第一类页面,将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。
  
  - (2)如果第一步失败,则开始第二轮扫描,寻找A=0且M= 1的第二类页面,将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间,将所有扫描过的页面的访问位都置0。
  
  - (3)如果第二步也失败,则将指针返回到开始的位置,然后回到第一步重新开始,一定能找到被淘汰的页。
  
  - 该算法与简单Clock算法比较，可减少磁盘的I/O操作次数。但为了找到一个可置换的页，可能须经过几轮扫描。换言之,实现该算法的开销有所增加。

- ![](../../../../assets/default.png)

- 页面缓冲算法（Page Buffering Algorithm）
  
  - 影响效率的因素
    
    - 页面置换算法。
    
    - 写回磁盘的频率。
      
      - 建立了一个已修改换出页面的链表,则对每一个要被换出的页面(已修改) ,系统可暂不把它们写回磁盘,而是将它们挂在已修改换出页面的链表.上，仅当被换出页面数目达到一定值时，例如64个页面,再将它们一起写回磁盘上
    
    - 读入内存的频率。
      
      - 如果有进程在这批数据还未写回磁盘时需要再次访问这些页面时,就不从外存上调入,而直接从已修改换出页面链表中获取,这样也可以减少将页面从磁盘读入内存的频率,减少页面换进的开销。
  
  - 特点
    
    - 显著地降低了页面换进、换出的频率,使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销;
    
    - 正是由于换入换出的开销大幅度减小,才能使其采用一种较简单的置换策略,如先进先出(FIFO)算法,它不需要特殊硬件的支持,实现起来非常简单。
  
  - 空闲页面链表
    
    - 该链表是一个空闲物理块链表。是系统掌握的空闲物理块,当进程需要读入一个页面时,便可利用空闲物理块来装入该页。
    
    - 当有一个未被修改的页面要换出时,实际上并不将它换回到外存,而是把它们所在的物理块挂在空闲链表的末尾。这些挂在空闲链表中的物理块是有数据的,如果以后某个进程需要访问这些页面时,可以直接从空闲链表中取下,免除了从磁盘读入数据的操作,减少了页面换进的开销。
  
  - 修改页面链表
    
    - 该链表是由已修改的页面所形成的链表。设置该链表的目的是减少修改页面换出的次数。当进程需要将一个已经修改的页面换出时,系统并不立即将它换出到磁盘上,而是将它所在的物理块挂在修改页面链表的末尾。
    
    - 当已修改页面的链表上的页面个数达到一定程度时,会-起将这些页面写回到磁盘。如果这些被换出的页面在写回磁盘之前,有进程需要访问其中的页面,那么可以直接从已修改页面链表.上获取该页面。所以可见,减少了磁盘I/O操作,并且减少了内存写入频率。

### 访问内存的有效时间

- 查找快表时间( λ )

- 访问实际物理地址时间( t )

- 缺页中断处理时间( ε )

- 命中率(a)

- 缺页率(f )

- 在内存,在快表
  
  - EAT =快表时间+内存时间=λ+t

- 在内存,不在快表
  
  - EAT =快表时间+内存时间+修改快表时间+内存时间=λ+t+λ+t

- 不在内存
  
  - EAT =快表时间+内存时间+缺页中断时间+修改快表时间+内存时间=λ+t+ε+λ+t

- 考虑命中率与缺页率
  
  - EAT =aX(+t)+(1-a)X [fX(+t++s+i+t)+(1-f)x(2+t+i+t)]=λ+ aXt+(1-a) X [t+f X (ε+ λ+t)+(1-f) X (1+ t)]

- 不考虑命中率,仅考虑缺页率,
  
  - EAT=f X (t+ε+t)+ (1-f) X(t+t)=t+f X (ε+ t)+(1-f) X t

## 抖动与工作集

### 抖动

由于请求分页式虚拟存储器系统的性能优越,在正常运行情况下,它能有效地减少内存碎片,提高处理机的利用率和吞吐量,故是目前最常用的一种系统。

但如果在系统中运行的进程太多,进程在运行中会频繁地发生缺页情况,这又会对系统的性能产生很大的影响,故还须对请求分页系统的性能做简单的分析。

![](../../../../assets/default.png)

**刚被淘汰的页面又马.上被调回内存,调回内存不久后又被淘汰出去,如此频繁进行,这种现象称为抖动(或称颠簸)**。它使得系统中页面调度非常频繁，以致CPU大部分时间都花费在内存和外存之间的调入调出上。

发生&quot;抖动”的根本原因是,同时在系统中运行的进程太多,由此分配给每一个进程的物理块太少,不能满足进程正常运行的基本要求。抖动是在进程运行中出现的严重问题,必须采取相应的措施解决它。

### 工作集

![](../../../../assets/default.png)

如果将缺页率控制在上界与下界(比如0.1%~1%) 之间,那么缺页率达到0.5%时的驻留集尺寸W将是比较适宜的。

我们无法事先预知程序在不同时刻将访问哪些页面,故仍只有像置换算法那样,用程序的过去某段时间内的行为作为程序在将来某段时间内行为的近似。

**所谓工作集,是指在某段时间间隔△里,进程实际所要访问页面的集合。**

把进程在某段时间间隔O里,在时间t的工作集记为w(t,A) ,变量△称为工作集“窗口尺寸”
对于给定的页面走向,如果△= 10次存储访问,在t1时刻的工作集是W(t1,10)=(1,2,5,6,7) ,在t2时刻,工作集是W(t2,10)=(3,4)

## 抖动的预防

- 采取局部置换策略
  
  - 即使该进程发生了&quot;抖动”, 也不会对其它进程产生影响,于是可把该进程”抖动”所造成的影响限制在较小的范围内
  
  - 但在某进程发生&quot;抖动”后,它还会长期处在磁盘I/O的等待队列中,使队列的长度增加,这会延长其它进程缺页中断的处理时间。

- 把工作集算法融入到处理机调度中
  
  - 当调度程序发现处理机利用率低下时,它将试图从外存调入一个新作业进入内存,在从外存调入作业之前,必须检查每个进程在内存的驻留页面是否足够多。
  
  - 如果都足够多,此时便可以从外存调入新的作业,不会因新作业的调入而导致缺页率的增加;
  
  - 反之,如果有些进程的内存页面不足,则应首先为那些缺页率居高的作业增加新的物理块,此时将不再调入新的作业。

- 利用&quot;L=S&quot;准则调节缺页率
  
  - L是缺页之间的平均时间, S是平均缺页服务时间,即用于置换一个页面所需的时间。
  
  - 如果是L远比S大,说明很少发生缺页,磁盘的能力尚未得到充分的利用;
  
  - 反之,如果是L比S小,则说明频繁发生缺页,缺页的速度已超过磁盘的处理能力。
  
  - 只有当L与S接近时,磁盘和处理机都可达到它们的最大利用率。
  
  - 理论和实践都已证明,利用&quot;L=S&quot;准则,对于调节缺页率是十分有效的。

- 选择暂停的进程

- 当多道程序度偏高时,已影响到处理机的利用率,为了防止发生“抖动”,系统必须减少多道程序的数目,以便腾出内存空间分配给那些缺页率偏高的进程。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter8/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第八章</h3> <p class="card-description" data-astro-cid-dohjnao5># 磁盘存储器的管理

## 外存的组织方式

- 磁盘的物理地址(盘块号)是(柱面号,盘面号,扇区号)

- 磁盘存储器中用t表示每个柱面上的磁道数(盘面数),

- 用s表示每个磁道.上的扇区数,

- 根据块号可以确定该块在磁盘上的位置
  
  - 每个柱面.上有: sxt个磁盘块
  
  - 计算第p块在磁盘上的位置,可以令d=sxt,则有:
  
  - i柱面(磁道)号=[p/d]
  
  - j盘面号=[(p mod d)/s]
  
  - k扇区号=(pmodd)mods

- 文件的物理结构直接与外存的组织方式有关。对于不同的外存组织方式，将形成不同的文件物理结构。目前常用的外存组织方式有:
  
  - 顺序组织方式:早期文件系统使用，现今仅在磁盘文件对换区的使用上还能看到
    其影子。
    
    - 连续分配方式要求每个文件在磁盘上占有一-组连续的块。
    
    - (逻辑块号,块内地址)  →(物理块号,块内地址)。只需转换块号就行,块内地址保持不变
    
    - 优点:
      
      - 顺序访问容易,支持定长记录文件随机存取;
      
      - 顺序访问速度快。
    
    - 缺点:
      
      - 要求为一个文件分配连续的存储空间，产生外部碎片。
      
      - 必须事先知道文件的长度。
      
      - 不能灵活地删除和插入记录。
      
      - 文件的动态增长困难。
  
  - 链接组织方式:分为隐式链接和显式链接两类。FAT12、 FAT16、FAT32文件系统使用的就是显式链接方式
    
    - 采用链接分配方式时，可通过在每个盘块.上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表， 把这样形成的文件称为链接文件。
    
    - 链接组织方式的主要优点:
      
      - 消除了磁盘的外部碎片，提高了外存的利用率。
      
      - 对插入、删除和修改记录都非常容易。
      
      - 能适应文件的动态增长，无需事先知道文件的大小。
    
    - 链接方式又可分为两种形式:
      
      - 隐式链接
        
        - 隐式链接分配方式的主要问题:
          
          - 它只适合于顺序访问，对随机访问是及其低效的
          
          - 可靠性差
        
        - 为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇(cluster)。在进行盘块分配时，是以簇为单位进行的。同样,链接文件也是以簇为单位的。
      
      - 显式链接
        
        - 把用于链接文件各物理块的指针显式地存放在一-张表中。 即文件分配表(FATFile Allocation Table)
        
        - 注意:一个磁盘仅设置一张FAT
        
        - 开机时,将FAT读入内存，并常驻内存
        
        - 逻辑块号转换成物理块号的过程不需要读磁盘操作
        
        - 文件分配表可同时管理磁盘的空闲盘块
    
    - FAT技术
      
      - FAT12:每个FAT表项为12位,
        
        - 每个FAT表最多允许4096 (212) 个表项，如果每个盘块大小为512 (29)B,则每个磁盘分区容量最大为2MB。
        
        - 以簇为分配的基本单位，如果一簇包含8个扇区， 则每个磁盘分区容量为1 6MB,但是簇内碎片也会增加。
      
      - FAT16:每个FAT表项为1 6位
        
        - 最大表项数增值65536 (216) 个，每个簇中有最多有64个扇区，最大分区空间为216x64x 512=2048MB
      
      - FAT32
        
        - 最大支持磁盘分区为2TB
    
    - 链接分配方式虽然解决了连续分配方式所存在的问题，但又出现了另外两个问题:
      
      - 不能支持高效的直接存取。要对一个文件进行直接存取，需首先在FAT中顺序的查找许多盘块号。
      
      - FAT需占用较大的内存空间。当磁盘容量较大时，FAT可能要占用数MB以上的内存空间。这是令人难以忍受的。
  
  - 索引组织方式: ext2、ext3、 ext4等UNIX文件系统采用该方式。
    
    - 单级索引
      
      - 索引分配允许文件离散地分配在各个磁盘块中,系统会为每个文件建立一张索引表
      
      - 索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表)。
      
      - 索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。
      
      - 优点:
        
        - 能顺序存取,又能直接存取
        
        - 满足了文件动态增长、插入删除的要求
        
        - 没有外碎片，外存空间利用率较高
      
      - 缺点
        
        - 索引表本身需要存储空间
        
        - 文件比较小时，索引表利用率低
    
    - 多级索引
      
      - 将一个大文件的所有索引表(二级索引)的地址放在另一个索引表(一级索引)中(原理类似于多级页表)。如果文件非常大，还可用三级、四级。
      
      - 访问目标数据块,需要多次磁盘I/O
      
      - 对与中小文件，访问磁盘次数过多
    
    - 增量式索引
      
      - 多种索引分配方式的结合。例如，一个文件的索引结点中,既包含直接地址(直接指向数据块),又包含一次间接地址(指向单层索引表)、还包含多次间接地址(指向两层索引表)
      
      - 在UNIX System V的索引结点中设有13个地址项，即i.addr(0) ~i.addr(12)

## 文件存储空间管理

- 磁盘管理要解决的重要问题之一是如何为新创建的文件分配存储空间。 其解决方法与内存的分配情况有许多相似之处
  
  - 连续分配方式
    
    - 空闲表法
      
      - 与内存的动态分配方式雷同，它为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲表， 每个空闲区对应于一个空闲表项,再将所有空闲区按其起始盘块号递增的次序排列
  
  - 离散分配方式
    
    - 空闲盘块链
      
      - 这是将磁盘上的所有空闲空间以盘块为单位拉成一条链，其中的每一个盘块都有指向后继盘块的指针。
    
    - 空闲盘区链
      
      - 这是将磁盘上的所有空闲盘区拉成一条链。 在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小(盘块数)的信息。
  
  - 位示图法（连续离散都适用）
    
    - 利用二进制的一位来表示磁盘中一个盘块的使用情况。当其值为0时表示对
      应的盘块空闲，为1时表示已分配(Linux)。 有的系统则相反。
    
    - 磁盘上的所有盘块都有一个二进制位与之对应，这样由所有盘块所对应的位构成一个集合，称为位示图。
    
    - 通常可用`m*n`个位数来构成位示图，并使`m*n`等磁盘的总块数。

- 存储空间的基本分配单位都是磁盘块而非字节。

- 为了实现存储空间的分配，首先必须记住空闲存储空间的使用情况。
  
  - 数据结构
  
  - 分配和回收功能
    
    - 根据位示图进行盘块分配时，可分三步进行:
      
      - 顺序扫描位示图，从中找出一个或一组其值为 &quot;0”的二进制位( &quot;0&quot;表示空闲时)
      
      - 将所找到的一个或-组二进制位转换成与之相应的盘块号。假定找到的其值为&quot;0&quot;的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算:`b=n(i-1) +j`式中，n代表每行的位数
      
      - 修改位示图，令`map[i, j] = 1`
    
    - 盘块的回收分两步:
      
      - 将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为:
        `i= (b-1)DIV n+ 1`
        `j=(b-1)MODn+1`
      
      - 修改位示图。令`map[i,j] = 0`</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter6/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第六章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第六章 输入输出设备

## I/O系统

- I/O系统管理的主要对象是I/O设备和相应的设备控制器。

- 其最主要的任务是
  
  - 完成用户提出的I/O请求
  
  - 提高I/O速率
  
  - 提高设备的利用率
  
  - 为更高层的进程方便地使用这些设备提供手段

- 基本功能
  
  - 隐藏物理设备的细节
  
  - 与设备的无关性
  
  - 提高处理机和I/O设备的利用率
  
  - 对I/O设备进行控制
    
    - 采用轮询的可编程1/O方式
    
    - 采用中断的可编程I/O方式
    
    - 直接存储器访问方式
    
    - I/O通道方式

- 确保对设备的正确共享
  
  - 独占设备，进程应互斥地访问这类设备，即系统一旦把这类设备分配给 了某进程后，便由该进程独占，直至用完释放。典型的独占设备有打印机、磁带机等。
  
  - 共享设备，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正确性。

- 错误处理

![](../../../../assets/default.png)

### I/O软件

- 中断处理程序
  
  - 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。

- 设备驱动程序
  
  - 驱动程序一般会以一个独立进程的方式存在。
  
  - 主要负责对硬件设备的具体控制，将上层发出的一系列命令(如read/write) 转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等
  
  - 不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。

- 设备独立性软件
  
  - 与设备的硬件特性无关的功能几乎都在这层实现。
  
  - 他的主要功能有:
    
    - 向上层提供统一的调用接口，如read/write系统调用
    
    - 设备的分配与回收
    
    - 差错处理
    
    - 数据缓冲区管理
    
    - 建立逻辑设备名到物理设备名的映射关系:根据设备类型选择调用相应的驱动程序

- 用户层软件
  
  - 实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。

### 系统接口

- 块设备接口
  
  - 块设备:用于存储信息。对于信息的存取总是以数据块为单位。典型例子是磁盘。该类设备基本特征是传输速率较高，另一特征是可寻址。工作方式常采用DMA方式。
  
  - 隐藏了磁盘的二维结构。
  
  - 将抽象命令映射为低层操作。

- 流设备接口
  
  - 字符设备:用于数据的输入和输出。基本单位是字符。如交互式终端、打印机等。
  
  - 其基本特征是传输速率较低，另一特征是不可寻址。
  
  - 工作方式常采用中断方式。
  
  - get和put操作。
  
  - in-control指令。

- 网络通信接口
  
  - 通过某种方式把计算机连接到网络上。同时操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络.上的其它计算机进行通信或上网浏览。

## I/O设备

- 部分
  
  - I/O设备的机械部件主要用来执行具体I /O操作。如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。
  
  - I/ O设备的电子部件通常是一块插入主板扩充槽的印刷电路板

- 分类
  
  - 按使用特性分类
    
    - 存储设备，也称外存或后备存储器、辅助存储器。
    
    - 输入/输出设备
      
      - 输入设备,如键盘、鼠标、扫描仪、视频摄像、各类传感器等。
      
      - 输出设备,如打印机、绘图仪、显示器、音箱等。
      
      - 交互式设备，集成上述两类设备,利用输入设备接收用户命令信息，并通过输出设备同步显示用户命令以及命令执行的结果。
  
  - 按传输速率分类
    
    - 低速设备，每秒钟几个字节至数百个字节
      
      - 键盘、鼠标器、语音的输入和输出设备
    
    - 中速设备，每秒钟数千个字节至数万个字节。
      
      - 行式打印机、激光打印机
    
    - 高速设备，数十万个字节至数千字节。
      
      - 磁盘机、光盘机

### 设备控制器

- I/O设备与CPU之间通过设备控制器通信

- 三种信号线
  
  - 数据信号线
  
  - 控制信号线
  
  - 状态信号线

- ![](../../../../assets/default.png)

- 设备控制器的基本功能
  
  - 接收和识别命令
  
  - 数据交换
  
  - 标识和报告设备的状态
  
  - 地址识别
  
  - 数据缓冲区
  
  - 差错控制

- 组成部分
  
  - 设备控制器与处理机的接口
  
  - 设备控制器与设备的接口
  
  - I/O逻辑

### 内存映像I/O

## 设备驱动程序

- 设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序

- 其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令,再;把它转换为具体要求后，发送给设备控制器，启动设备去执行;

- 反之，它也将由设备控制器发来的信号传送给上层软件。

- 由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。

- 设备驱动程序的功能
  
  - 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。
  
  - 检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。
  
  - 发出I/O命令，如果设备空闲，便立即启动I/O设备,完成指定的I/O操作;如果设备忙碌，则将请求者的请求块挂在设备队列上等待。
  
  - 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。

- 处理过程
  
  - 将抽象要求转换为具体要求
  
  - 检查I/O请求的合法性
  
  - 读出和检查设备的状态
  
  - 传送必要的参数
  
  - 启动I/O设备

- 控制方式
  
  - 宗旨：尽量减少主机对I/O控制的干预，把主机从繁杂的IO控制事务中解脱出来
  
  - 忙——等待方式
    
    - CPU向控制器发出I/O指令,启动输入设备。
    
    - 状态寄存器忙/闲标志busy置1。
    
    - 循环测试busy, busy= 1输入未完成。
    
    - busy=0输入完成，将数据从控制器的数据寄存器读到内存
    
    - 由于CPU高速,I/O设备低速致使CPU极大浪费。
  
  - 使用中断的可编程I/O方式
    
    - CPU向控制器发出I/O指令，CPU返回继续原来的工作。
    
    - 设备控制器控制I/O设备。CPU与I/O并行工作。
    
    - 数据输入寄存器，控制器向CPU发出中断。
    
    - CPU检查数据正确性，数据写入内存。
    
    - 优点
      
      - CPU与I/O并行工作， 提高了资源利用率和吞吐量。
    
    - 缺点
      
      - CPU每次处理的数据量少(通常不超过几个字节)，只适于传输率较低的设备
  
  - 直接存储器访问(Direct Memory Access)
    
    - 特点
      
      - 数据传输的基本单位是数据块。
      
      - 数据从设备直接送入内存，或者相反。
      
      - 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。
    
    - DMA控制器
      
      - 三部分
        
        - 主机与DMA控制器的接口
        
        - DMA控制器与块设备的接口
        
        - I/O控制逻辑
      
      - 四类寄存器
        
        - 数据寄存器DR
        
        - 命令/状态寄存器CR
        
        - 内存地址寄存器MAR
        
        - 数据计数器DC
    
    - DMA工作过程
      
      - CPU发出指令，存入CR
      
      - 内存起始目标地址送入MAR。
      
      - 读取字节数送DC。
      
      - 源地址送DMA的I/O控制逻辑。
      
      - 启动DMA控制器，CPU处理其他任务。
      
      - DMA控制读入一个字(节)到DR。
      
      - 将该字(节)送入MAR指向的内存单元。
      
      - MAR加1，DC减1。
      
      - DC&lt;&gt; 0继续传输，DC=0发出中断。
    
    - 中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理。
    
    - DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数。
    
    - 中断方式的数据传送是由CPU控制完成的，而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。
  
  - I/O通道控制方式
    
    - 目的：CPU的I/O任务由通道来承担。
    - 一种特殊的处理机，属于硬件技术。它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。
    - 指令类型单一、 即由于通道硬件比较简单，其所能执行的指令，主要为与I/O有关的指令
    - 通道没有自己的内存，与CPU共享内存
    - CPU一次读(或写)多个数据块。
    - 多个数据块送入不同内存区域。
    - CPU、通道和I/O设备三者的并行操作。
    - 工作过程:
      - CPU向通道发送一条I/O指令。
      - 给出通道程序首址和要访问的I/O设备。
      - 通过执行通道程序完成I/O任务。
    - 通道程序由一系列通道指令(通道命令)构成。
    - 每条通道指令包含的信息:
      - 操作码
      - 内存地址
      - 计数
      - 通道程序结束位P (P= 1表示程序结束)
      - 记录结束标志R (R=0表示与下一条指令处理的数据属于同一记录;R= 1表示某记录的最后一条指令)
    - 字节多路通道(Byte Multiplexor Channel)
      - 字节多路通道以字节为单位传输信息
      - 含有许多非分配型子通道
      - 子通道按时间片轮转方式共享通道
      - 只要扫描每个子通道的速度足够快，而连接到子同上的设备的速率较小的时，不丢数据
      - 主要连接以字节为单位的低速I/O设备,如:打印机、终端

## 与设备无关的I/O软件

设备独立性又叫设备无关性，应用程序中所使用的设备,不局限于使用某个具体的物理设备
应用程序中使用逻辑设备名称来请求使用某类设备;系统将其转换为物理设备名称。

- 好处
  
  - 设备分配时的灵活性
  
  - 易于实现I/O重定向

- 设备独立性的实现
  
  - 系统有专门从逻辑设备到物理设备的转换机制，类似于存储器管理中所介绍的逻辑地址和物理地址的概念

- 功能
  
  - 执行所有设备的公有操作。
    
    - 设备驱动程序的统一接口， 对设备进行保护，禁止用户直接访问设备
      
      - 缓冲管理
      
      - 差错控制
      
      - 对独立设备的分配与回收
      
      - 独立于设备的逻辑数据块
      
      - 将逻辑设备名映射为物理设备名，找到相应物理设备的驱动程序

### 设备分配

一个通道可控制多个设备控制器每个设备控制器可控制多个设备。

- 设备分配中的数据结构
  
  - 设备控制表DCT
    
    - 每个物理设备有一张，反映设备特性、设备和I/O控制器的连接情况，在设备和系统连接时创建，动态修改
  
  - ![](../../../../assets/default.png)

- 设备分配时考虑的因素
  
  - 设备的固有属性
    
    - 独享设备
    
    - 共享设备
    
    - 虚拟设备
  
  - 设备分配算法
    
    - 先来先服务
    
    - 优先级高者优先
  
  - 设备分配中的安全性
    
    - 安全分配方式
    
    - 不安全分配方式

- 独占设备的分配程序
  
  - 分配设备
  
  - 分配控制器
  
  - 分配通道
  
  - 增加设备的独立性
    
    - 使用逻辑设备名

- 逻辑设备表(LUT)
  
  - 逻辑设备表(LUT)建立了逻辑设备名与物理设备名之间的映射关系。
  
  - 某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求 操作系统根据用户进程指定的设备类型(逻辑设备名)查找系统设备表,找到一个空闲设备分配给进程,并在LUT中增加相应表项。
  
  - 如果之后用户进程再次通过相同的逻辑设备名请求使用设备,则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了,并且也能知道该设备的驱动程序入口地址

## 用户层I/O软件

- 系统调用
  
  - 系统调用，应用程序可以通过它间接调用OS中的I/0过程，对I/O设备进行操作。

- 库函数

### 假脱机系统(spooling)

- 假脱机技术
  
  - 在多道程序技术下，专门利用一道程序来模拟脱机输入操作,把低速I/O设备上的数据传送到高速磁盘上
  
  - 再用另一道程序来模拟脱机输出操作，把数据从磁盘传送到输出设备上。
  
  - 此时I/O设备与CPU并行工作。

- 组成
  
  - 输入井和输出井。是磁盘上开辟的两个大存储空间。
  
  - 输入缓冲区和输出缓冲区。在内存中开辟两个缓冲区，输入缓冲区暂存由输入设送来的数据，后送输入井
  
  - 输出缓冲区暂存从输出井送来的数据，后送输出设备。
  
  - 输入进程和输出进程。利用两个进程模拟脱机I/O时的外围处理机。

- 假脱机打印机
  
  - 打印机是经常用到的输出设备，属于独占设备。、
  
  - 利用假脱机技术可将它改造为一台可供多个用户共享的打印设备
  
  - 假脱机打印系统主要有以下3三部分
    
    - 磁盘缓冲区。
    
    - 打印缓冲区。
    
    - 假脱机管理进程和假脱机打印进程

- 特点
  
  - 提高了I/O的速度
  
  - 将独占设备改造为共享设备
  
  - 实现了虚拟设备功能

## 缓冲区管理

- 缓冲的引入
  
  - 缓和CPU与I/O设备间速度不匹配的矛盾。
  
  - 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。
  
  - 解决数据粒度不匹配的问题
  
  - 提高CPU和1/O设备之间的并行性。

- 单缓冲区(Single Buffer)
  
  - 进程发出一个I/O请求时，操作系统便在主存中为之分配一缓冲区。
  
  - ![](../../../../assets/default.png)

- 双缓冲区
  
  - 在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时OS可
    以从第二缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。
  
  - 为了实现两台机器间的双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另外一个用作接收缓冲区。

- 环形缓冲区
  
  - CPU和外设的处理速度可能相差较大。
  
  - 在主存中分配一组大小相等的缓冲区， 并用指针将这些缓冲区-个循环链表。
  
  - 多个缓冲区:空缓冲区R;满缓冲区G;工作缓冲区C。
  
  - 多个指针:下一个可用缓冲区G的指针Nextg;下一个输入缓冲区R的指针Nexti;当前计算进程正在使用的缓冲区C的指针Current。

## 磁盘

- 结构
  
  - 磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面(Surface)
  
  - 每个盘面上有若干个磁道(Track),磁道之间留有必要的间隙(Gap)。为使处理简单起见，在每条磁道上可存储相同数目的二进制位。
  
  - 磁盘密度即每英寸所存储的位数
  
  - 每条此道从逻辑上划分位若干扇区

- 磁盘格式化
  
  - 磁盘低级格式化(温切斯特盘)
    
    - 将空白的磁盘划分出柱面和磁道，再将磁道划分为若干个扇区，
    
    - 每个扇区又划分出标识部分ID,间隔区GAP和数据区DATA等。

- 磁盘分区
  
  - 每个分区是一个独立的逻辑磁盘分区情况记录在磁盘的主引导扇区中的分区表(MBR)中

- 高级格式化
  
  - 设置引导块，空闲和已分配空间表，构件文件系统，在磁盘上初始化文件系统数据结构，根目录等

- 类型
  
  - 硬盘、软盘
  - 单片盘、多片盘
  - 固定磁头盘、移动磁头盘

- 磁盘访问时间
  
  - 寻道时间T&lt;sub&gt;s&lt;/sub&gt; :在读/写数据前,将磁头移动到指定磁道所花的时间。
    
    - 启动磁头臂是需要时间的。假设耗时为s ;
    
    - 移动磁头也是需要时间的。假设磁头匀速移动,每跨越一个磁道耗时为m ,总共需要跨越n条磁道。则:
    
    - $$
      T_s=s+m*n
      $$
  
  - 延迟时间Tt :
    
    - 通过旋转磁盘,使磁头定位到目标扇区所需要的时间。设磁盘转速为r (单位:转/秒,或转/分),则平均所需的延迟时间
    
    - $$
      T_t=\frac{1}{2}*\frac{1}{r}=\frac{1}{2r}
      $$
  
  - 传输时间Tt 
    
    - 从磁盘读出或向磁盘写入数据所经历的时间,假设磁盘转速为r，此次读/写的字节数为b,每个磁道上的字节数为N
    
    - $$
      T_t=\frac{b}{rN}
      $$
  
  - 总的平均存取时间
    
    - $$
      T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
      $$

### 磁盘调度算法

- 先来先服务
  
  - 根据进程请求访问磁盘的先后顺序进行调度。
  
  - 优点
    
    - 公平，简单。
    
    - I/O负载较轻且每次读写多个连续扇区时，性能较好。
    
    - 适用于l/O进程较少的场合。

- 最短寻道优先算法
  
  - SSTF算法会优先处理的磁道是与当前磁头最近的磁道。
  
  - 可以保证每次的寻道时间最短,但是并不能保证总的寻道时间最短。(贪心算法)
  
  - 可能会有进程处于“饥饿”状态。

- 扫描算法
  
  - 只有磁头移动到最外侧磁道的时候才能往内移动,移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想。由于磁头移动的方式很像电梯,因此也叫电梯算法。
  
  - 性能较好，平均寻道时间较短
  
  - 防止“饥饿”现象。
  
  - 被广泛应用。
  
  - SCAN算法对于各个位置磁道的响应频率不平均

- 循环扫描算法
  
  - 磁头单向移动，磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。
  
  - 比起SCAN来,对于各个位置磁道的响应频率很平均。
  
  - 比起SCAN算法来,平均寻道时间更长。

- NStepSCAN算法
  
  - 在高密度磁盘.上容易出现“磁臂粘着”情况。
  
  - 将磁盘请求队列分成若干个长度为N的子队列。
  
  - 队列之间使用FCFS算法。
  
  - 队列内部使用SCAN算法。
  
  - 新的I/O请求，放入其他队列，避免粘着现象。
  
  - 当N值很大时，性能接近于SCAN算法。
  
  - 当N=1时，蜕化为FCFS算法。

- FSCAN算法
  
  - 是N步SCAN算法的简化。
  
  - 磁盘请求队列分成两个子队列。
  
  - 一个是由当前所有请求磁盘I/O的进程形成的队列，按SCAN算法进行处理。
  
  - 新出现的所有请求磁盘I/O的进程，放入另- -个等待处理的请求队列。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/chapter7/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 第七章</h3> <p class="card-description" data-astro-cid-dohjnao5># 第七章 文件管理

## 文件和文件系统

现代OS中是通过文件系统来组织和管理计算机中存储的数据
文件则是指具有文件名的若干相关元素的集合
基于文件系统的概念，**可以把数据组成分为数据项、记录和文件三级**

- 文件名
  
  - 文件名
  
  - 扩展名

- 文件类型
  
  - 按用途分类:系统文件、用户文件和库文件
  
  - 按文件中数据的形式分类:源文件、目标文件和可执行文件
  
  - 按存取控制属性分类:只执行文件、只读文件和读写文件
  
  - 组织形式和处理方式分类:普通文件、目录文件、和特殊文件

- 文件系统模型
  
  - 对象及其属性。文件管理系统的对象有:文件、目录和磁盘存储空间。
  
  - 对对象操纵和管理的软件集合。是文件管理的核心部分。实现了文件系统的大部分功能——对文件存储空间的管理、对文件目录的管理、将文件的地址转换机制、对文件读写管理以及对文件的共享和保护。
  
  - 文件系统的接口。命令接口(用户与文件系统)和程序接口(用户程序和文件系统)。

- 文件操作
  
  - 用户通过文件系统所提供的系统调用实施对文件的操作。最基本的文件操作有:创建文件、删除文件、读文件、写文件和设置文件的读/写位置。
  
  - 但对于一个实际的OS,为了方便用户使用文件而提供了更多地对文件的操作，如打开和关闭一一个文件及改变文件名等操作。

## 文件的逻辑结构

- 类型
  
  - 按文件是否有结构分类
    
    - 有结构文件:是指由-一个以上的记录构成的文件，又把它称为记录式文件;
    
    - 无结构文件，这是指由字符流构成的文件，故又称为是流式文件。
  
  - 根据文件的组织方式，可把有结构文件分为三类:
    
    - 顺序文件。由一系列记录按某种顺序排列所形成的文件。通常是定长记录
      
      - 逻辑记录的排序
        
        - 串结构：各记录之间的顺序与关键字无关。通常由时间来决定(从头开
          始逐个查找)
        
        - 顺序结构:文件中的所有记录按关键字排列。可以按关键字的长短或英文字母书写排序。顺序结构的检索效率更高(可利用折半查找、插值查找法等)
      
      - 优点:
        
        - 顺序文件的最佳应用场合是在对文件中的记录进行批量存取时(即每次要读或写一大批记录)。
        
        - 对于顺序存储设备(如磁带),也只有顺序文件才能被存储并能有效地工作。
      
      - 缺点:
        
        - 查找和增删记录比较困难
      
      - 顺序寻址
        
        - 隐性寻址
          
          - 确定下一个记录的逻辑地址
        
        - 显性寻址
          
          - 可对定长记录实现直接或随机访问
          
          - 通过文件中记录的位置
            
            - 定长记录文件，可实现随机存储
            
            - 变长记录文件，无法实现随机存储
          
          - 通过关键字
    
    - 索引文件。当记录可变长时，通常为之建立一张索引表，并为每个记录设置一个表项以加快对记录检索的速度。
      
      - 按关键字建立索引
        
        - 索引表本身是定长记录的顺序文件。因此可以快速找到第i个记录对应的索引项。
        
        - 可将关键字作为索引号内容若按关键字顺序排列,则还可以支持按照关键字折半查找。
        
        - 每当要增加/删除一个记录时,需要对索引表进行修改。
      
      - 具有多个索引表的索引文件
        
        - 可以用不同的数据项建立多个索引表
    
    - 索引顺序文件。上述两种方式的结合。为文件建立一张索引表，为每一组记录中的第一个记录设置一个表项。
      
      - 将变长记录顺序文件中的所有记录分为若干个组，如50个记录为一个组。然后为顺序文件建立一张索引表，并为每组中的第一个记录在索引表中建立一个索引项，其中含有该记录的关键字和指向该记录的指针。
      
      - 若一个顺序文件有10000个记录,则根据关键字检索文件,只能从头开始顺序
        查找(这里指的并不是定长记录),平均须查找5000(N/2)个记录。
      
      - 若采用索引顺序文件结构,可把10000个记录分为100组,每组100个记录。则需要先顺序查找索引表找到分组(共1 00个分组,因此索引表长度为100,平均需要查50次),找到分组后,再在分组中顺序查找记录(每个分组100个记录,因此平均需要查50次)。可见,采用索引顺序文件结构后,平均查找次数减少为50+50= 100次(根号N)
    
    - 二级索引顺序文件
      
      - 为了进一步提高检索效率,可以为顺序文件建立多级索引表。例如，对于一个含10&lt;sup&gt;6&lt;/sup&gt;个记录的文件,可先为该文件建立- -张低级索引表,每 100个记录为一组,故低级索引表中共有10000个表项(即10000个定长记录),再把这10000个定长记录分组,每组100个,为其建立顶级索引表,故顶级索引表中共有100个表项。
  
  - 直接文件
    
    - 可根据给定的关键字直接获得指定记录的物理地址。换而言之,
    
    - 关键字本身就决定了记录的物理地址。
  
  - 哈希(Hash)文件
    
    - 这是目前应用最为广泛的一种直接文件。
    
    - 它利用Hash函数(或称散列函数)可将关键字转换为相应记录的地址。

## 文件目录

通常在现代计算机系统中，都要存储大量的文件。为了能对这些文件实施有
效的管理,必须对它们加以妥善组织

- 实现&quot;按名存取”

- 提高对目录的检索速度

- 文件共享

- 允许文件重名



- 文件控制块
  
  - 为了能对一个文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为&quot;文件控制块(FCB)
  
  - FCB通常含有三类信息:
    
    - 基本信息类。包括:文件名，文件物理位置，文件逻辑结构，文件的物理结构
    
    - 存取控制信息类。包括:文件主的存取权限，核准用户的存取权限和一般用户的存取权限
    
    - 使用信息类。包括:文件的建立日期和时间、文件上次修改的日期和时间及当前使用信息。

- 文件目录
  
  - 把所有的FCB组织在一-起，就构成了文件目录，即文件控制块的有序集合

- 目录文件
  
  - 为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，这个文件就叫目录文件

- 索引节点
  
  - 文件目录通常是存放在磁盘上的，当文件很多时，文件目录要占用大量的盘块。在检索目录文件的时候，需要将目录调入内存后比较文件名，但是只用到文件名，而不需要其它那些对文件的描述信息。所以便把文件名与文件信息分开，使文件描述信息单独形成-个索引结点。
  
  - 磁盘索引结点
    
    - 存放在磁盘上的索引结点。每个文件有唯一-的一 个磁盘索引结点，主要包括以下内容:
      
      - 文件主标识符
      
      - 文件类型
      
      - 文件存取权限
      
      - 文件物理地址
      
      - 文件长度
      
      - 文件链接计数
      
      - 文件存取时间
  
  - 内存索引结点、
    
    - 放在内存中的索引结点。当文件被打开后，将磁盘索引结点拷贝到内存索引
      结点中以便使用。
    
    - 比磁盘索引结点增加了以下内容:
      
      - 索引结点编号
      
      - 状态
      
      - 访问计数;
      
      - 文件所属文件系统的逻辑设备号
      
      - 链接指针。
  
  - 读取文件的流程
    
    - 根据文件名找到其所在目录中的目录项，获取该目录的对应文件的inode
    
    - 根据文件inode号，找到inode在磁盘的位置
    
    - 根据inode中的对应关系，找到对应文件的盘块block;
    
    - 读取文件

- 文件目录
  
  - 目录结构的组织，关系到文件系统的存取速度，也关系到文件的共享性和安全性。因此，组织好文件的目录是设计好文件系统的重要环节。
  
  - 单级目录
    
    - 最简单的目录结构。整个文件系统中只建立一张目录表， 每个文件一个目
      录项,目录项含有文件相关信息。状态位表明每个目录项是否空闲。
    
    - 优点
      
      - 简单且能实现目录管理的基本功能
      
      - 实现了&quot;按名存取&quot;
    
    - 缺点
      
      - 查找速度慢
      
      - 不允许重名。多用户环境下重名难以避免
      
      - 不便于实现文件共享
  
  - 两级目录
    
    - 为了克服单级目录所存在的缺点，可以为每个用户建立一个单独的用户文件目录UFD。由该用户所有文件的文件控制块组成。
    
    - 在系统中再建立一个主文件目录MFD。在主文件目录中每个用户目录文件都占有一个目录项，其中包括用户名和指向该用户文件的指针。
    
    - 基本克服了单级目录的缺点，并具有以下优点:
      
      - 提高了检索目录的速度。
      
      - 在不同的目录中可以有相同的文件名。
      
      - 不同用户还可以使用不同的文件名来访问系统中的同一个共享文件。
    
    - 用户不能对自己的文件进行分类
  
  - 多级目录
    
    - 现代操作系统通常采用三级或三级以上的目录结构，以提高目录的检索速度和文件系统的性能。多级目录结构又称为树型目录结构,主目录称为根目录，数据文件为树叶，其它目录为结点。
    
    - 路径名
      
      - 用户(或用户进程)要访问某个文件时要用文件路径名标识文件,文件路径名是个字符串。各级目录之间用&quot;/&quot;隔开。从根目录出发的路径称为绝对路径
    
    - 当前目录
      
      - 很多时候,用户会连续访问同一目录内的多个文件。显然，每次都从根目录开始查找是很低效的因此可以设置一个&quot;当前目录&quot;。 当用户想要访问某个文件时,可以使用从当前目录出发的相对路径
    
    - 目录操作
      
      - 创建目录
      
      - 删除目录
        
        - 不删除非空目录
        
        - 可删除非空目录
      
      - 改变目录
      
      - 移动目录
      
      - 链接(Link)操作
      
      - 查找

- 目录查询技术
  
  - 当用户要访问一个已存文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件控制块或对应索引结点;
  
  - 然后根据FCB或索引结点中所记录的文件物理地址，换算出文件在磁盘上的物理位置;
  
  - 最后通过磁盘驱动程序,将所需文件读入内存
  
  - 线性检索法
  
  - Hash方法
    
    - 建立了一张Hash索引文件目录，利用Hash方法进行查询，即系统利用用户提供的文件名并将它变换为文件目录的索引值，再利用该索引值到目录中去查找，显著地提高检索速度。
  
  - 文件打开过程
    
    - 用户访问某文件时，调用open(),系统的工作过程:
      
      - 查找目录，找到指定的文件目录;
      
      - 核对访问权限;
      
      - 将文件目录项复制到“打开文件表(open-file table) &quot;中
        
        - “打开文件表”是open()系统调用关联的主要数据结构，用于记录系统中所有已打开的文件的信息。当用户再次需要访问文件时，不需要重复查找目录，而是通过返回的文件指针，直接找到“打开文件表”对应表项，进而得到文件在外存的地址。这样大大的减少了检索目录所带来的开销，提高了系统工作效率。
      
      - 返回用户该文件在“打开文件表”中的指针fd。
  
  - 文件关闭过程
    
    - 当一个文件暂不使用时，就应撤消该文件在“已打开表”中的相应表目，以释放所占内存空间，这就是文件的关闭。及时关闭不用的文件，一方面节约了内存的开支， 另一方面把FCB的内容及时写回外存， 以免被意外情况破坏。
    
    - 当用户调用close系统调用时，系统的工作过程:
      
      - 核对用户的使用权限，一般只有文件的建立者和打开者才有权关闭文件; 
      
      - 根据fd查找“用户打开文件表”，释放该文件占用的表目;
      
      - 检查读入内存的文件目录和文件索引节点是否已被修改，若已被修改，则需将该文件的文件目录项和文件索引节点重新写回外存，以保存做过的修改。

## 文件共享

操作系统为用户提供文件共享功能,可以让多个用户共享地使用同一个文件

注意:多个用户共享同一个文件,意味着系统中只有&quot;一份&quot;文件数据。并且只要某个用户修改了该文件的数据,其他用户也可以看到文件数据的变化。

如果是多个用户都&quot;复制&quot;了同一个文件,那么系统中会有&quot;好几份&quot;文件数据。

其中一个用户修改了自己的那份文件数据,对其他用户的文件数据并没有影响。



- 基于有向无环图的文件共享
  
  - 有多个属于不同用户的多个目录，同时指向同-个文件,这样虽会破坏树的特性，但这些用户可用对称的方式实现文件共享，而不必再通过其属主目录来访问。
  
  - 在文件目录中只设置文件名及指向相应索引结点的指针
  
  - 索引结点中设置一个链接计数变量count ,用于表示链接到本索引结点上的用户目录项数。

- 利用符号链接实现文件共享
  
  - 利用符号链接实现文件共享的基本思想，是允许一个文件或子目录有多个父目录，但其中仅有一个作为主(属主)父目录，其它的几个父目录都是通过符号链接方式与之相链接的(简称链接父目录)。
  
  - 为使链接父目录D5能共享文件F8,可以由系统创建一个LINK类型的新文件， 也取名为F8,并将F8写入链接父目录D5中，以实现D5与文件F8的链接。在新文件F中只包含被链接文件F8的路径名。这样的链接方法被称为符号链接。新文件F中的路径名则只被看做是符号链。
  
  - 优点
    
    - 在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的
      指针;而共享该文件的其他用户则只有该文件的路径名，不会出现指针悬
      空的情况。
  
  - 问题
    
    - 当其他用户去读共享文件时，系统是根据给定的文件路径名逐个分量(名)地去查找目录，直至找到该文件的索引结点。因此，在每次访问共享文件时，都可能要多次地读盘。这使每次访问文件的开销甚大，且增加了启动磁盘的频率。
    
    - 要为每个共享用户建立一条符号链，而由于链本身实际上是一个文件，尽管该文件非常简单，却仍要为它配置一个索引结点，这也要耗费一定的磁盘空间。
  
  - 
    

## 文件保护

- 访问权
  
  - 我们把一个进程能对某对象执行操作的权力，称为访问权(Access right)。

- 保护域
  
  - &quot;域”是进程对一组对象访问权的集合，进程只能在指定域内执行操作
  
  - “域”规定了进程所能访问的对象和能执行的操作

- 进程和域间的静态联系
  
  - 在进程和域之间可以一对应，即一个进程只联系着一个域。这意味着,在进程的整个生命期中，其可用资源是固定的，我们把这种域称为&#39;静态域”

- 进程和域间的动态联系方式
  
  - 在进程和域之间，也可以是一对多的关系，即一个进程可以联系着多个域
  
  - 可将进程的运行分为若干个阶段，其每个阶段联系着一个域，这样便可根据运行的实际需要来规定在进程运行的每个阶段中所能访问的对象。

- 基本的访问矩阵
  
  - 访问矩阵中的行代表域，列代表对象，矩阵中的每一项是由一组访问权组成的。

- 访问控制表(Access Control List)
  
  - 对访问矩阵按列(对象)划分，为每一列建立一张访问控制表ACL
  
  -  在该表中，已把矩阵中属于该列的所有空项删除，此时的访问控制表是由一有序对(域，权集)所组成的。
  
  - 使用访问控制表可以显著地减少所占用的存储空间，并能提高查找速度。
  
  - 在每个文件的FCB (或索引结点)中增加一个访问控制列表(Access-Control List, ACL)该表中记录了各个用户可以对该文件执行哪些操作。
  
  - 精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。
  
  - 如果把访问矩阵按行(即域)划分，便可由每一行构成一张访问权限表。换言之，这是由一个域对每一个对象可以执行的一组操作所构成的表。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/operate_system/choice/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>操作系统复习 重点提纲</h3> <p class="card-description" data-astro-cid-dohjnao5># 操作系统关键部分摘要
## 引论
### 操作系统的作用
- 作为用户与计算机硬件系统之间的接口
- 作为计算机系统资源的管理者
- 实现了对计算机资源的抽象
### 操作系统的种类
- 单道批处理系统：
  - 批处理是指计算机系统对一批作业自动进行处理的一种技术。 
  - 为实现对作业的连续处理,需要先把一批作业以脱机方式输入到磁带上,并在系统中配上监督程序(Monitor) ,在它的控制下,使这批作业能一个接一地连续处理
- 多道批处理系统 
  - 在多道批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”; 然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。
- 分时系统 
  - 采用时间片轮转的方法，同时为许多终端用户服务，对每个用户能保证足够快的响应时间，并提供交互会话的功能。
  - 时间片：将CPU的时间划分成若干个片段，称为时间片，操作系统以时间片为单位，轮流为每个终端用户服务关键问题
- 微机操作系统 
  - 微型计算机操作系统 微型计算机操作系统简称微机操作系统，常用的有Windows、Mac OS、Linux。
### 现代操作系统的特性
&lt;mark&gt;并发性&lt;/mark&gt;、&lt;mark&gt;共享性&lt;/mark&gt;、虚拟性、异步性
### 操作系统程序接口
由一组系统调用组成,每一个系统调用都是一个能完成特定功能的子程序,每当应用程序要求OS提供某种服务时,便调用具有相应功能的系统调用。
### 操作系统内核态与用户态
&lt;mark&gt;内核态（管态）和用户态（目态）将内核程序和用户程序隔离&lt;/mark&gt;
- &lt;font color=red&gt;特权指令&lt;/font&gt;

  - 涉及外部设备的输入/输出指令

  - 存取用于内存保护的寄存器

  - 内存清零

  - 置时钟

  - 允许/禁用中断


&lt;mark&gt;中断指令&lt;/mark&gt;是用户程序发起的调用内核代码的唯一方式

- 中断机制

  - 提高多道程序环境下CPU利用率

  - 外中断：中断信号来源于外部设备

  - 内中断：中断信号来源于当前指令内

- 内中断的三种情况

  - 陷阱/陷入：由应用程序主动引发

  - 故障：由错误条件引发

  - 终止：由致命错误引发

- 系统调用的核心

  - 用户程序中包含一段含有int指令的代码

  - 操作系统写中断处理，获取想调用程序的编号

  - int指令将使CPL改成0 ，“进入内核”

  - 操作系统根据编号执行相应代码
## 进程控制
### 进程的概念
程序段、数据段、**PCB**三部分构成了进程实体,简称&quot;进程”。
### 进程的三种状态
- 就绪状态(Ready)
  - 进程已获得除CPU之外的所有必需的资源,一旦得到CPU控制权,立即可以运行
- 运行状态(Running)
  - 进程已获得运行所必需的资源，它正在处理机上执行。
- 阻塞状态(Blocked)
  - 正在执行的进程由于发生某事件而暂时无法执行时,便放弃处理机而处于暂停状态,称该进程处于阻塞状态或等待状态。

### PCB的定义
PCB是内存中的一种数据结构，PCB的作用是使一个在多道程序环境下不能独立运行的程序(含数据) ,成为一个能独立运行的基本单位, 一个能与其他进程并发执行的进程

&lt;mark&gt;PCB是进程存在的唯一标志&lt;/mark&gt;

### PCB的内容
| 类型           | 内容                                                        | 作用               |
|--------------|-----------------------------------------------------------|------------------|
| 标识信息         | 1 )外部标识为方便用户&lt;br/&gt;2 )内部标识为方便系统                             | 标识一个进程           |
| 处理机状态(现场信息 ) | 1 ) CPU通用/指令寄存器&lt;br/&gt;2 ) CPU程序状态字PSW&lt;br/&gt;3 )用户栈指针          | 记录处理机现场信息,以备恢复之用 |
| 调度信息         | 1 )进程状态&lt;br/&gt;2 )进程优先级&lt;br/&gt;3 )调度所需信息&lt;br/&gt;4)事件               | 用户进程的调度管理        |
| 控制信息         | 1 )程序和数据地址&lt;br/&gt;2 )进程同步和通信机制&lt;br/&gt;3 )资源清单&lt;br/&gt;4 )指向下一个进程的指针 | 用于进程的控制管理        |

### 进程的创建
- 引起创建进程的事件

  - 用户登录

  - 作业调度

  - 提供服务

  - 应用请求

- 创建过程

  - 申请进程标识,即申请空白PCB

  - 为新进程分配内存和其它资源

  - 初始化进程控制块

  - 将创建的进程置于就绪队列

### 进程控制的原语
- 进程创建原语

- 进程撤销原语

- 阻塞原语

- 唤醒原语

- 挂起原语

- 激活原语

### 临界区的定义
临界区：进程中访问临界资源的那段代码

### &lt;font color=red&gt;信号量&lt;/font&gt;
- 定义:把整型信号量定义为一个用于表示资源数目的整型量S ,除初始化外仅能通过两个原子操作wait(S)，signal(S)（低级原语）来访问

- 原子操作P :

  - 分配一个单位资源

  - wait(S)

- 原子操作V :

  - 释放一个单位资源

当信号量sign 大于0时，表示该资源该有sign个。当sign小于0时，表示有sign个进程正在等待
### 管程

管程是由若干个公共变量和所有访问这些变量的过程所组成的一个特殊的模块或软件包

### 其他进程同步机制（有各种各样的问题）
- 关中断法(开关中断指令)也称为&quot;硬件锁”,在进入锁测试之前关闭中断,直到完成锁测试并上锁之后才能打开中断。
- 利用Test and Set指令实现互斥：这是一种借助一条硬件指令一“测试并建立”指令TS(Test- and-Set)以实
  现互斥的方法。在许多计算机中都提供了这种指令。
- 利用swap指令实现线程互斥

### 管道的定义
- 管道:指用于连接一个读进程和一个写进程以实现他们之间通信的一个打开的共享文件,又名pipe文件。

- 管道只能采取半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,则需要设置两个管道各个进程要互斥的访问管道

- 数据以字节流的形式写入管道,当管道写满时,写进程的write()系统调用将会被阻塞,等待读进程将数据取走。当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将会被阻塞
  
### 线程

线程(thread)是一个可执行的实体单元。&lt;mark&gt;它代替以往的进程,成为现代操作系统中处理机调度的基本单位。

**调度的基本单位**

- 同一进程中的线程切换不会引起进程切换

- 不同进程中的线程切换必然引起进程切换

**用户级线程**

- 用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能,都无须利用系统调用来实现。

- 对于用户级线程的切换,通常是发生在一个应用进程的诸多线程之间,无须内核的支持。

- 切换的规则远比进程调度和切换的规则简单

**内核支持线程KST**

- 在内核的支持下运行的，即无论是用户进程中的线程,还是系统进程中的线程,他,们的创建、撤消和切换等,也是依靠内核实现的。

- **在内核空间还为每一个内核支持线程设置了一个线程控制块** ,内核是根据该控制块而感知某线程的存在的,并对其加以控制。

线程控制块TCB

- 线程标识符;

- 组寄存器，它包括程序计数器PC、状态寄存器和通用寄存器;

- 线程运行状态,用于描述线程正处于何种运行状态;

- 优先级，描述线程执行的优先程度;

- 线程专有存储区，用于线程切换时存放现场保护信息,和相关统计信息;

- 信号屏蔽，即对某些信号加以屏蔽。

- 堆栈,用来保存局部变量和返回地址。

  - 用户栈和核心栈

## 调度机制与死锁
### 作业调度——先来先服务算法（First Come First Serve）
基本原则是按照作业到达系统的先后次序来选择,或者说它是优先考虑在系统中等待时间最长的作业,而不管该作业所需执行时间的长短。
### 作业调度——&lt;font color=red&gt;短作业优先（Short Job First）调度算法&lt;/font&gt;
SJF算法是以作业的长短来计算优先级,作业越短,其优先级越高。

### 作业调度——高响应比优先调度算法
- 为每个作业引入一个动态优先级,即优先级是可以改变的，令它随等待时间延长而增加,这将使长作业的优先级在等待期间不断地增加,等到足够的时间后,必然有机会获得处理机。该优先级的变化规律可描述为:

    $$
    R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}
    $$

### 响应比

(等待时间+执行时间)/执行时间

### [进程调度算法](https://charlesix59.github.io/2023/02/07/subject/operate_system/chapter3/#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
考得不大具体，了解即可

### 死锁的概念

死锁( Deadlock ) 是指多个进程在运行过程中因争夺资源而造成的一种僵局

**死锁原因**

- 竞争不可抢占性资源

- 竞争可消耗资源

- 进程推进顺序不当

**产生死锁的必要条件**

- 互斥条件

- 请求和保持条件

- 不可抢占条件

- 循环等待条件

#### [死锁的预防、避免、检查与解除](https://charlesix59.github.io/2023/02/07/subject/operate_system/chapter3/#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81)
这一块内容很多还挺重要的，慢慢看吧

## 存储器管理
### 目的
存储器管理的目的：提高内存利用率、方便用户
### 程序的装入
**重定位**： 
在装入时对目标程序中指令和数据的修改过程称为重定位。

**绝对装入方式**：
在编译时,如果知道程序驻留在内存的什么位置,那么编译程序将产生绝对地址的目标代码。

**可重定位装入方式（Relocation Loading Mode）**：
在多道程序环境下,可重定位装入方式,根据内存的当前情况,将装入模块装入到内存的适当位置。

**动态重定位**：

- 在把装入模块装入内存后,并不立即把装入模块中的相对地址转换为绝对地址,而是把这种地址转换推迟到程序真正要执行时(访问内存之前)才进行。

### 连续分配存储方式
- 单一连续分配：系统区加用户区，连续的分配
- 固定分区分配：将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业,便可以有多道作业并发执行。
- 动态分区分配：动态分区法在作业执行前并不建立分区,分区的建立是在作业的处理过程中进行的,且其大小可随作业或进程对内存的要求而改变。&lt;mark&gt;分区分配算法有&lt;/mark&gt;：
  - 首次适应算法：要求按地址递增的次序组织空闲区表(链)。
  - 循环首次适应算法（Next Fit）：每次分配不再从空闲分区链(表)的开始找起,而是从上次找到的空闲分区的下一个找起,找到一个能满足要求的空闲区。
  - &lt;font color=red&gt;最佳适应算法（Best Fit)&lt;/font&gt;：把能满足要求的最小空闲分区分配给作业,避免“大材小用”
  - 最坏适应算法(Worst Fit)：总是挑选最大的空闲分区分割给作业使用
  - 快速适应算法：将空闲分区按大小分类,每类具有相同容量，放入一个空闲分区链表
  - 伙伴系统：无论已分配分区或空闲分区,分区大小必须是2的k次幂，k为整数, I≤k≤m
  - 哈希算法:哈希算法就是利用哈希快速查找优点,以及空闲分区在可利用空间表中的分布规律,建立哈希函数,构造一张以空闲分区大小为关键字的哈希表,该表的每一个表项记录了一个对应的空闲分区链表表头指针。


### 分页存储
**页面**

- 把进程的逻辑地址空间划分成若干大小相等的区域,每个区域称作**页面**或**页**。每个页都有一个编号,叫做页号。页号一般从0开始编号,如0 , 1, 2, ...等。

- 把内存空间划分成若干和页大小相同的物理块，这些物理块叫**页框**(frame)或(物理)块。同样,每个物理块也有一个编号，块号从0开始依次顺序排列。

- 以**页**为单位进行内存分配,并按进程的页数多少来分配。逻辑上相邻的页,物理上不一定相邻。

## 虚拟存储器

虚拟存储器:是指具有请求调入功能和置换功能,能从逻辑.上对内存容量加以扩充的一种存储器系统。

&lt;mark&gt;虚拟内存的实际容量 = min（内存与外存之和, CPU寻址范围）&lt;/mark&gt;

&lt;mark&gt;虚拟存储器的实现都是建立在离散分配的存储管理方式的基础上。&lt;/mark&gt;

### 请求分页系统

在分页系统的基础上,增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。置换时以页面为单位。

硬件支持:
- 请求分页的页表机制
- 缺页中断机构
- 地址变换机构

### 物理块分配策略

在请求分页系统中,可采取两种内存分配策略:

- 固定分配策略:为每个进程分配一定数目的物理块,在整个运行期间不再改变

- 可变分配策略:先为每个进程分配一定数量的物理块,在整个运行期间可适当增多或减少。

在进行置换时,也可采取两种策略

- 全局置换:可以将操作系统保留的空闲物理快分配给进程,也可以将别的进程持有的物理块置换到外存,再分配给缺页进程。

- 局部置换:发生缺页时,只选进程自己的物理块置换

组合出的三种策略：（不能采用固定分配全局置换）

- 固定分配局部置换(Fixed Allocation , Local Replacement)

  - 为每个进程分配一定数目的物理块,在整个运行期间不再改变。

  - 采用该策略时,如果进程在运行中发现缺页,只能从该进程在内存中的n个页面中选出一页换出,然后再调入一页。

  - 困难:应为每个进程分配多少个物理块难以确定。

- 可变分配全局置换(Variable Allocation , Global Replacement)

  - 在采用这种策略时,先为系统中的每个进程分配一定数目的物理块,而OS自身也保持一个空闲的物理块队列。

  - 如果某进程发生缺页时,由系统从空闲的物理块队列中,取出一个物理块分配给该进程,并将欲调入的页装入其中。

  - 当空闲物理块队列中的物理块用完后, OS才能从系统中的任一进程中选择一页调出。

- 可变分配局部置换(Variable Allocation , Local Replacement)

  - 为每个进程分配一定数目的物理块,如果某进程发生缺页时,只允许从该进程在内存的页面中选出一页换出,不会影响其他进程执行。

  - 如果进程在运行中频繁发生缺页中断,则系统再为进程分配若干物理块

  - 如果进程在运行中缺页率特别低,则适当减少分配给该进程的物理块


**交换(swap)分区**：
Swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

### 页面置换算法
- 最佳置换算法
  - 算法无法实现，但可评价其他算法。
- 先入先出页面（FIFO）置换算法
  - 算法总是淘汰最先进入内存的页面,即选择在内存中驻留时间最久的页面予以淘汰。
  - **Belady现象**
    - 采用FIFO算法时,如果对一个进程未分配它所要求的全部页面,有时就会出现分配的页面数增多但缺页率反而提高的异常现象。
- &lt;font color=red&gt;最近最久未使用（LeastRecently Used）算法&lt;/font&gt;
  - 算法根据页面调入内存后的使用情况进行决策。由于无法预测各页面将来的使用情况,只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。
  - 该算法赋予每个页面一个访问字段,用来记录一个页面自上次被访问以来所经历的时间t ,当需淘汰一个页面时,选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。
  - 需有以下两类硬件之一的支持:
    - 寄存器
    - 栈
- 最少使用置换（Least Frequently Used)算法
  - 在采用LFU算法时,应为在内存中的每个页面设置一个移位寄存器,用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。
- 简单的Clock置换算法

  - 当采用简单Clock算法时,只需为每页设置一位访问位,再将内存中的所有页面都通过链接指针链接成一个循环队列。

  - 当某页被访问时,其访问位被置1。

  - 置换算法在选择一页淘汰时,只需检查页的访问位。如果是0 ,就选择该页换出;若为1 ,则重新将它置0 ,暂不换出,而给该页第二次驻留内存的机会

  - 再按照FIFO算法检查下一个页面。

  - 当检查到队列中的最后一个页面时,若其访问位仍为1 ,则再返回到队首去检查第一个页面。

  - 因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描

- &lt;font color=red&gt;改进型CLock算法&lt;/font&gt;

  - 在将一个页面换出时,如果该页已被修改过,便须将该页重新写回到磁盘上;但如果该页未被修改过,则不必将它拷回磁盘。

  - 在改进型Clock算法中,除须考虑页面的使用情况外,还须再增加一个因素,即置换代价,这样,选择页面换出时,既要是未使用过的页面,又要是未被修改过的页面。

  - 把同时满足这两个条件的页面作为首选淘汰的页面。

  - 由访问位A和修改位M可以组合成下面四种类型的页面:

    - 1类(A=0 , M=0) :表示该页最近既未被访问,又未被修改,是最佳淘汰页。

    - 2类(A=0 , M=1) :表示该页最近未被访问,但已被修改,并不是很好的淘汰页。

    - 3类(A=1 , M=0) :表示该页最近已被访问,但未被修改,该页有可能再被访问。

    - 4类(A=1 , M=1) :表示该页最近已被访问且被修改,该页可能再被访问。

  - (1)从指针所指示的当前位置开始,扫描循环队列,寻找A=0且M=0的第一类页面,将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。

  - (2)如果第一步失败,则开始第二轮扫描,寻找A=0且M= 1的第二类页面,将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间,将所有扫描过的页面的访问位都置0。

  - (3)如果第二步也失败,则将指针返回到开始的位置,然后回到第一步重新开始,一定能找到被淘汰的页。

  - 该算法与简单Clock算法比较，可减少磁盘的I/O操作次数。但为了找到一个可置换的页，可能须经过几轮扫描。换言之,实现该算法的开销有所增加。

### 预防抖动

&lt;mark&gt;刚被淘汰的页面又马上被调回内存,调回内存不久后又被淘汰出去,如此频繁进行,这种现象称为抖动(或称颠簸)&lt;/mark&gt;

**所谓工作集,是指在某段时间间隔△里,进程实际所要访问页面的集合。**

&lt;font color=red&gt;预防抖动的策略&lt;/font&gt;

- 采取局部置换策略

- 把工作集算法融入到处理机调度中

- 利用&quot;L=S&quot;准则调节缺页率

- 选择暂停的进程

- 当多道程序度偏高时,已影响到处理机的利用率,为了防止发生“抖动”,系统必须减少多道程序的数目,以便腾出内存空间分配给那些缺页率偏高的进程。

## 输入输出设备
### I/O 系统 （四个层级从低到高）
- 中断处理程序
  - 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。
- 设备驱动程序
  - 驱动程序一般会以一个独立进程的方式存在。
  - 主要负责对硬件设备的具体控制，将上层发出的一系列命令(如read/write) 转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等
- 设备独立性软件
  - 他的主要功能有:

    - 向上层提供统一的调用接口，如read/write系统调用

    - 设备的分配与回收

    - 差错处理

    - 数据缓冲区管理

    - 建立逻辑设备名到物理设备名的映射关系:根据设备类型选择调用相应的驱动程序

- 用户层软件

  - 实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。

### 设备驱动设备的控制方式
控制方式

- 宗旨：尽量减少主机对I/O控制的干预，把主机从繁杂的IO控制事务中解脱出来

- 忙——等待方式

  - CPU向控制器发出I/O指令,启动输入设备。

  - 状态寄存器忙/闲标志busy置1。

  - 循环测试busy, busy= 1输入未完成。

  - busy=0输入完成，将数据从控制器的数据寄存器读到内存

  - 由于CPU高速,I/O设备低速致使CPU极大浪费。

- 使用中断的可编程I/O方式

  - CPU向控制器发出I/O指令，CPU返回继续原来的工作。

  - 设备控制器控制I/O设备。CPU与I/O并行工作。

  - 数据输入寄存器，控制器向CPU发出中断。

  - CPU检查数据正确性，数据写入内存。

- &lt;font color=red&gt;直接存储器访问(Direct Memory Access)&lt;/font&gt;

  - 特点

    - 数据传输的基本单位是数据块。

    - 数据从设备直接送入内存，或者相反。

    - 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。

  - DMA控制器

    - 三部分

      - 主机与DMA控制器的接口

      - DMA控制器与块设备的接口

      - I/O控制逻辑

    - 四类寄存器

      - 数据寄存器DR

      - 命令/状态寄存器CR

      - 内存地址寄存器MAR

      - 数据计数器DC

  - DMA工作过程

    - CPU发出指令，存入CR

    - 内存起始目标地址送入MAR。

    - 读取字节数送DC。

    - 源地址送DMA的I/O控制逻辑。

    - 启动DMA控制器，CPU处理其他任务。

    - DMA控制读入一个字(节)到DR。

    - 将该字(节)送入MAR指向的内存单元。

    - MAR加1，DC减1。

    - DC&lt;&gt; 0继续传输，DC=0发出中断。

  - 中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理。

  - DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数。

  - 中断方式的数据传送是由CPU控制完成的，而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。

- I/O通道控制方式

  - 目的：CPU的I/O任务由通道来承担。
  - 一种特殊的处理机，属于硬件技术。它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。
  - 指令类型单一、 即由于通道硬件比较简单，其所能执行的指令，主要为与I/O有关的指令
  - 通道没有自己的内存，与CPU共享内存
  - CPU一次读(或写)多个数据块。
  - 多个数据块送入不同内存区域。
  - CPU、通道和I/O设备三者的并行操作。
  - 工作过程:
    - CPU向通道发送一条I/O指令。
    - 给出通道程序首址和要访问的I/O设备。
    - 通过执行通道程序完成I/O任务。
  - 通道程序由一系列通道指令(通道命令)构成。
  - 每条通道指令包含的信息:
    - 操作码
    - 内存地址
    - 计数
    - 通道程序结束位P (P= 1表示程序结束)
    - 记录结束标志R (R=0表示与下一条指令处理的数据属于同一记录;R= 1表示某记录的最后一条指令)
  - 字节多路通道(Byte Multiplexor Channel)
    - 字节多路通道以字节为单位传输信息
    - 含有许多非分配型子通道
    - 子通道按时间片轮转方式共享通道
    - 只要扫描每个子通道的速度足够快，而连接到子同上的设备的速率较小的时，不丢数据
    - 主要连接以字节为单位的低速I/O设备,如:打印机、终端

### 设备独立性

&lt;font color=red&gt;用户编程时使用的硬件名称与实际使用的设备名称不同&lt;/font&gt;

### 假脱机系统(spooling)

在多道程序技术下，专门利用一道程序来模拟脱机输入操作，&lt;font color=red&gt;把低速I/O设备上的数据传送到高速磁盘上&lt;/font&gt;，
再用另一道程序来模拟脱机输出操作，把数据从磁盘传送到输出设备上。

- 此时I/O设备与CPU并行工作。

### 缓冲区管理

单缓冲区(Single Buffer)

- 进程发出一个I/O请求时，操作系统便在主存中为之分配一缓冲区。

双缓冲区

- 在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时OS可以从第二缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。

- 为了实现两台机器间的双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另外一个用作接收缓冲区。


## 文件管理
文件逻辑结构是为了方便用户而设计的
### 文件的逻辑结构
顺序文件：由一系列记录按某种顺序排列所形成的文件。通常是定长记录
索引文件：当记录可变长时，通常为之建立一张索引表，并为每个记录设置一个表项以加快对记录检索的速度。
索引顺序文件：上述两种方式的结合。为文件建立一张索引表，为每一组记录中的第一个记录设置一个表项。
二级索引顺序文件：为了进一步提高检索效率,可以为顺序文件建立多级索引表。
### 文件控制块
- 为了能对一个文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为&quot;文件控制块(FCB)

- FCB通常含有三类信息:

  - 基本信息类。包括:文件名，文件物理位置，文件逻辑结构，文件的物理结构

  - 存取控制信息类。包括:文件主的存取权限，核准用户的存取权限和一般用户的存取权限

  - 使用信息类。包括:文件的建立日期和时间、文件上次修改的日期和时间及当前使用信息。
### 文件目录
文件目录通常是存放在磁盘上的，当文件很多时，文件目录要占用大量的盘块。在检索目录文件的时候，需要将目录调入内存后比较文件名，但是只用到文件名，而不需要其它那些对文件的描述信息。所以便把文件名与文件信息分开，使文件描述信息单独形成一个索引结点。
### 软连接与硬链接
硬链接
- 软链接相当于Windows的快捷方式 
- 软链接里面存放的是源文件的路径，指向源文件 
- 删除源文件，软链接文件依然存在，但是无法通过软链接访问源文件，已经失效，并且白字红底闪烁 
- 软链接和源文件是不通的文件，iNode号不同，文件类型也不同 
- 所有连接文件的权限都是777，而实际权限是由链接指向的源文件权限决定的

软连接
- 具有相同iNode节点号的多个文件，互为硬链接文件 
- 删除硬链接文件或者源文件任意之一，文件实体并未被删除，只有删除了所有硬链接文件和源文件，文件实体才被删除 
- 硬链接文件只是文件的另一个入口 
- 链接文件和源文件属性相同
- 不能跨分区，不能对目录使用

## 硬盘存储器管理
### 外存组织方式（文件的物理结构）
- 顺序组织方式
  - 每个文件在磁盘上占有一组连续的块
- 链接组织方式
  - 可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表
  - 显式链接：把用于链接文件各物理块的指针显式地存放在一张表中。 即文件分配表(FATFile Allocation Table)
- 索引组织方式
  - 索引分配允许文件离散地分配在各个磁盘块中,系统会为每个文件建立一张索引表
  - 索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表)。
  - 索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。


### 文件存储空间管理

存储空间的管理实际上是对外存未占用空间的管理

- 连续分配方式
  - 空闲表法：为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲表， 每个空闲区对应于一个空闲表项,再将所有空闲区按其起始盘块号递增的次序排列
- 离散分配方式
  - 空闲盘块链：磁盘上的所有空闲空间以盘块为单位拉成一条链，其中的每一个盘块都有指向后继盘块的指针。
  - 空闲盘区链：将磁盘上的所有空闲盘区拉成一条链。 在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小(盘块数)的信息。
- &lt;font color=red&gt;位示图法（连续离散都适用）&lt;/font&gt;
  - 利用二进制的一位来表示磁盘中一个盘块的使用情况。当其值为0时表示对
    应的盘块空闲，为1时表示已分配(Linux)。 有的系统则相反。
  - 磁盘上的所有盘块都有一个二进制位与之对应，这样由所有盘块所对应的位构成一个集合，称为位示图。
  - 通常可用`m*n`个位数来构成位示图，并使`m*n`等磁盘的总块数。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/semaphore/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之信号量</h3> <p class="card-description" data-astro-cid-dohjnao5># 信号量

信号量(Semaphore)，有时被称为信号灯，是在[多线程](https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink)环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被[并发](https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806?fromModule=lemma_inlink)调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。

## 信号量值的含义

- n&gt;0：当前有可用资源，可用资源数量为n

- n=0：资源都被占用，可用资源数量为0

- n&lt;0：资源都被占用，并且还有n个进程正在排队


## PV操作

PV操作是一种实现进程互斥与同步的有效方法。

PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。

**注意：**

1. P(S)和V(S)都是在同一个信号量S上操作

2. 约定P(S)和V(S)必须是两个不可被中断的过程

3. PV操作对于每一个进程来说，都只能进行一次，而且必须成对使用


**P操作的主要动作是：**

①S减1；

②若S减1后仍大于或等于0，则进程继续执行；

③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。

**V操作的主要动作是：**

①S加1；

②若相加后结果大于0，则进程继续执行；

③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。

~~如果再考到其他的点我再加吧~~</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/mm/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之内存管理</h3> <p class="card-description" data-astro-cid-dohjnao5>## 内存管理

## 存储管理的概念

存储管理主要是指对内存储器的管理，负责对内存的分配和回收、内存的保护和内存的扩充。存储管理的目的是尽量提高内存的使用效率。

## 单一连续区管理

在单道程序系统中，内存区域的用户空间全部为一个作业或进程占用。单一连续分配方法主要用于早期单道批处理系统。单一连续分配方法主要采用静态分配方法，为降低成本和减少复杂度，通常不对内存进行保护，因而会引起冲突使系统瘫痪。

## 分区存储管理

分区存储管理包括固定分区、可变分区，其基本思想是把内存划分成若干个连续区域，每个分区装入一个作业运行。要求作业一次性装入内存，且分区内部地址必须连续。

### 固定分区存储管理

固定分区分配方法是把内存空间固定地划分为若干个大小不等的区域，划分的原则由系统决
定。系统使用分区表描述分区情况。分区一旦划分结束，在整个执行过程中每个分区的长度和内存的总分区个数保持不变。

### 可变分区存储管理

可变分区分配方法是把内存空间按用户要求动态地划分成若干个分区。随着进程的执行，剩余的自由区域会变得更小，这时需要合并自由区和存储拼接技术。合并自由区是将相邻自由存储区合并为单一自由区的方法；存储拼接技术也称碎片收集，包括移动存储器的所有被占用区域到主存的某一端。可变分区克服了固定分区分配方法中的小作业占据大分区后产生碎片的浪费问题。

### 存储分配算法

常使用的4种存储分配算法介绍如下。
**首次适应算法：** 把内存中的可用分区单独组成可用分区表或可用分区自由链，按起始地址递增的次序排列。每次按递增次序向后找，&lt;mark&gt;一旦找到大于或等于所要求内存长度的分区&lt;/mark&gt;，则结束探索，从找到的分区中找出所要求的内存长度分配给用户，并把剩余的部分进行合并。
**循环适应算法：** 上述首次适应法经常利用的是低地址空间，后面经常是较大的空白区，为使内存所有线性地址空间尽可能轮流使用到，&lt;mark&gt;每重新分配一次，都在当前之后寻找。&lt;/mark&gt;
**最佳适应算法：** 最佳适应算法是&lt;mark&gt;将输入作业放入主存中与它所需大小最接近的空白区中&lt;/mark&gt;，使剩下的未用空间最小，该法要求空白区大小按从小到大次序组成空白区可用表或自由链。在进行分配时总是从最小的一个开始查询，因而找到的一个能满足要求的空白区便是最佳的一个。
**最差适应算法：** 分配时把一个作业程序放入主存中最不适合它的空白区，即&lt;mark&gt;最大的空白区（空闲区）内&lt;/mark&gt;。

### 交换与覆盖技术

覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。覆盖技术主要用在早期的操作系统中，而交换技术则在现代操作系统中得到了进一步发展。
覆盖技术是一种解决小内存运行大作业的方法。-个作业中若干程序段和数据段可以不同时使
用，这样它们就可以共享内存的某个区域，再根据需要分别调入该区域，这个区域就称为覆盖区。将程序执行时并不要求同时装入主存的覆盖组成一组，并称其为覆盖段，这个覆盖段分配到同一个覆盖区。交换技术可以将暂不需要的作业移到外存，让出内存空间以调入其他作业，交换到外存的作业也可以被再次调入。交换技术与覆盖技术相比不要求给出程序段之间的覆盖结构。交换主要是在作业之间进行的，而覆盖则主要是在同一个作业内进行的。

## 页式存储管理

分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，以页面为单位进行分配。在页式存储管理中，系统中虚地址是一个有序对（页号，位移）。系统为每一个进程建立一个页表，其内容包括进程的逻辑页号与物理页号的对应关系、状态等。

## 段式存储管理

段式存储管理与页式存储管理相似。分段的基本思想是把用户作业按逻辑意义上有完整意义的段来划分，以段为单位作为内、外存交换的空间尺度。一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成的。在分段系统中，容许程序（作业）占据内存中许多分离的分区。每个分区存储一个程序分段。这样，每个作业需要几对界限地址寄存器，判定访问地址是否越界也困难了。在分段存储系统中常常利用存储保护键实现存储保护。分段系统中虚地址是一个有序对（段号，位移）。系统为每个作业建立一个段表，其内容包括段号、段长、内存起始地址和状态等。状态指出这个段是否已调入内存，即内存起始地址指出这个段，状态指出这个段的访问权限。

## 段页式存储管理

段页式管理是段式和页式两种管理方法结合的产物，综合了段式组织与页式组织的特点，根据程序模块分段，段内再分页，内存被划分成定长的页。段页式系统中虚地址形式是（段号、页号、位移）。系统为每个进程建立一个段，为每个段建立一个页表。段页式管理采用段式分配、页式使用的方法，便于动态连接和存储的动态分配。这种存储管理能提高内存空间的利用率。段页式虚拟存储管理结合了段式和页式的优点，但增加了设置表格（段表、页表）和查表等开销，段页式虚拟存储器一般只在大型计算机系统中使用。

## 页面调度

如果选择的页面被频繁地装入和调出，这种现象称为&quot;抖动&quot;,应减少和避免抖动现象。常用的页面调度算法有以下几种。
**最优（OPT）算法**。&lt;mark&gt;选择不再使用或最远的将来才被使用的页&lt;/mark&gt;，难以实现，常用于淘汰算法的
比较。
**随机（RAND）算法**。&lt;mark&gt;随机地选择被淘汰的页&lt;/mark&gt;，开销小，但是可以选中立即就要访问的页。
先进先出（First in First out,FIFO）算法，又称轮转法（RR）。选择在内存驻留时间最长的
页，似乎合理，但可能淘汰掉频繁使用的页。另外，使用FIFO算法时，在未给予进程分配足够的页面数时，有时会出现给予进程的页面数增多，缺页次数反而增加的异常现象。FIFO算法简单，可采用队列实现。
**最近最少使用（Least Recently Used缩写为LRU）算法**。&lt;mark&gt;选择离当前时间最近的一段时间内使用得最少的页&lt;/mark&gt;。这个算法的主要出发点是，如果某个页被访问了，则它可能马上就要被访问；反之，如果某个页长时间未被访问，则它在最近一段时间也不会被访问。
另外，还有最不经常使用的页面先淘汰（LFU,least frequent used）、最近没有使用的页面先淘汰（NUR）、最优淘汰算法（OPT,optimal replacement algorithm）等。</p> </div> </div> </a>  </div> </div>  </main> <footer data-astro-cid-sz7xmlte>
&copy; 2026 @charlesix59. All rights reserved.
<div class="social-links" data-astro-cid-sz7xmlte> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg> </a> </div> </footer>  </body></html>