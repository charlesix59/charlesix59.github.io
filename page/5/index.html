<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/png" href="/src/assets/icon.png"><link rel="stylesheet" href="/styles/global.css"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="茶理的博客" href="https://charlesix59.github.io/rss.xml"><meta name="generator" content="Astro v5.16.6"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://charlesix59.github.io/page/5/"><!-- Primary Meta Tags --><title>茶理的博客 - 第 5 页</title><meta name="title" content="茶理的博客 - 第 5 页"><meta name="description" content="Welcome to my website! - 第 5 页，共 7 页"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://charlesix59.github.io/page/5/"><meta property="og:title" content="茶理的博客 - 第 5 页"><meta property="og:description" content="Welcome to my website! - 第 5 页，共 7 页"><meta property="og:image" content="https://charlesix59.github.io/_astro/default.DOL7xRHI.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://charlesix59.github.io/page/5/"><meta property="twitter:title" content="茶理的博客 - 第 5 页"><meta property="twitter:description" content="Welcome to my website! - 第 5 页，共 7 页"><meta property="twitter:image" content="https://charlesix59.github.io/_astro/default.DOL7xRHI.png"><link rel="stylesheet" href="/_astro/about.CafuXOta.css">
<style>.card-link[data-astro-cid-dohjnao5]{text-decoration:none;color:inherit}.card[data-astro-cid-dohjnao5]{display:flex;gap:1.5rem;padding:1.5rem;border-radius:0;transition:all .3s ease;background:#fff;box-shadow:0 2px 8px #0000001a}.card[data-astro-cid-dohjnao5]:hover{box-shadow:0 4px 16px #00000026;transform:translateY(-2px)}.card-image[data-astro-cid-dohjnao5]{flex-shrink:0;width:10rem;height:10rem;border-radius:0;overflow:hidden;background:#f0f0f0}.card-image[data-astro-cid-dohjnao5] img[data-astro-cid-dohjnao5]{width:100%;height:100%;object-fit:cover}.card-content[data-astro-cid-dohjnao5]{flex:1;display:flex;flex-direction:column;justify-content:center;min-width:0}.card-title[data-astro-cid-dohjnao5]{margin:0 0 .5rem;font-size:1.1rem;font-weight:600;color:rgb(var(--black));line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.card-description[data-astro-cid-dohjnao5]{margin:0;font-size:.95rem;color:rgb(var(--gray));line-height:1.5;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis}@media(max-width:640px){.card[data-astro-cid-dohjnao5]{padding:1rem;gap:1rem}.card-image[data-astro-cid-dohjnao5]{width:8rem;height:8rem}.card-title[data-astro-cid-dohjnao5]{font-size:1rem}.card-description[data-astro-cid-dohjnao5]{font-size:.9rem;-webkit-line-clamp:1}}.card-list[data-astro-cid-p3vyftr4]{display:flex;flex-direction:column;gap:2px;margin-top:2rem}.card-item[data-astro-cid-p3vyftr4]{background:transparent}@media(max-width:640px){.card-list[data-astro-cid-p3vyftr4]{gap:2px;margin-top:1.5rem}}.pagination[data-astro-cid-d776pwuy]{display:flex;justify-content:center;align-items:center;gap:.6rem;margin:2rem 0;flex-wrap:wrap;font-size:.95rem}.pagination-link[data-astro-cid-d776pwuy]{padding:.35rem .8rem;background-color:#e8e8e8;color:#333;text-decoration:none;border-radius:6px;font-weight:500;transition:all .3s ease;border:1px solid #d0d0d0;font-size:.9rem}.pagination-link[data-astro-cid-d776pwuy]:hover{background-color:#d8d8d8;transform:translateY(-2px);box-shadow:0 2px 8px #0000001a}.pagination-numbers[data-astro-cid-d776pwuy]{display:flex;gap:.3rem;align-items:center}.pagination-number[data-astro-cid-d776pwuy]{padding:.3rem .6rem;border:1px solid #d0d0d0;color:#333;background-color:#fff;text-decoration:none;border-radius:4px;font-weight:500;transition:all .3s ease;min-width:2rem;text-align:center;font-size:.9rem}.pagination-number[data-astro-cid-d776pwuy]:hover:not(.active){background-color:#f5f5f5;border-color:#999}.pagination-number[data-astro-cid-d776pwuy].active{background-color:#333;color:#fff;border-color:#333}.pagination-ellipsis[data-astro-cid-d776pwuy]{color:rgb(var(--gray));font-weight:500;padding:.3rem .2rem;font-size:.9rem}@media(max-width:640px){.pagination[data-astro-cid-d776pwuy]{gap:.5rem;margin:2rem 0}.pagination-link[data-astro-cid-d776pwuy]{padding:.4rem .7rem;font-size:.9rem}.pagination-number[data-astro-cid-d776pwuy]{padding:.3rem .6rem;font-size:.9rem}.pagination-numbers[data-astro-cid-d776pwuy]{gap:.3rem}}
</style></head> <body> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>茶理的博客</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 首页 </a>  <a href="/tags" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 标签 </a>  <a href="/about" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 关于我 </a>  </div> <div class="social-links" data-astro-cid-3ef6ksr2> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg> </a> </div> </nav> </header>  <main> <div style="margin-bottom: 2rem; text-align: center;"> <h1 style="margin: 0; font-size: 2rem; color: rgb(var(--black));">
博客列表 - 第 5 页
</h1> <p style="color: rgb(var(--gray)); margin: 0.5rem 0 0 0;">
共 92 篇文章
</p> </div> <div class="card-list" data-astro-cid-p3vyftr4> <div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/software_project/chapter9/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软件工程复习 第九章</h3> <p class="card-description" data-astro-cid-dohjnao5></p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/semaphore/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之信号量</h3> <p class="card-description" data-astro-cid-dohjnao5># 信号量

信号量(Semaphore)，有时被称为信号灯，是在[多线程](https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink)环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被[并发](https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806?fromModule=lemma_inlink)调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。

## 信号量值的含义

- n&gt;0：当前有可用资源，可用资源数量为n

- n=0：资源都被占用，可用资源数量为0

- n&lt;0：资源都被占用，并且还有n个进程正在排队


## PV操作

PV操作是一种实现进程互斥与同步的有效方法。

PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。

**注意：**

1. P(S)和V(S)都是在同一个信号量S上操作

2. 约定P(S)和V(S)必须是两个不可被中断的过程

3. PV操作对于每一个进程来说，都只能进行一次，而且必须成对使用


**P操作的主要动作是：**

①S减1；

②若S减1后仍大于或等于0，则进程继续执行；

③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。

**V操作的主要动作是：**

①S加1；

②若相加后结果大于0，则进程继续执行；

③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。

~~如果再考到其他的点我再加吧~~</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/alp/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>应用层常用协议</h3> <p class="card-description" data-astro-cid-dohjnao5># 软考复习之应用层常用协议

| 名称                                  | 全拼     | 实现      | 端口                | 备注                      |
|-------------------------------------|--------|---------|-------------------|-------------------------|
| Domain Name System                  | DNS    | TCP+UDP | 53                | 提供域名解析服务                |
| File Transfer Protocol              | FTP    | TCP     | 21(控制) &lt;br&gt;20（数据） | 文件传输                    |
| 远程终端协议                              | Telnet | TCP     | 23                | 远程终端                    |
| Hyper Text Transfer Protocol        | HTTP   | TCP     | 80                |                         |
| Hyper Text Transfer Protocol Secure | HTTPS  | TCP     | 443               |                         |
| Post Office Protocol - Version 3    | POP3   | TCP     | 110               | 从服务器查看邮件                |
| Simple Mail Transfer Protocol       | SMTP   | TCP     | 25                | 发送邮件                    |
| Simple Network Management Protocol  | SNMP   | UDP     | 161、162           | 用于在 IP 网络管理网络节点         |
| Trivial File Transfer Protocol      | TFTP   | UDP     | 69                | 用来在客户机与服务器之间进行简单文件传输的协议 |</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/cp/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之编译原理</h3> <p class="card-description" data-astro-cid-dohjnao5># 软考复习之编译原理

## 语言处理程序

*语言处理程序是将高级语言或汇编语言编写的程序**翻译**成某种机器语言*

### 汇编语言

*汇编语言是为特定计算机设计的面向机器的符号化的设计语言*

汇编语言源程序是指用汇编语言编写的程序

#### 语句

##### 指令语句

*指令语句又叫机器指令语句*

将其汇编后能产生相应的机器代码

基本指令有`ADD`.`SUB`,`AND`等

##### 伪指令语句

*伪指令语句指示汇编程序在汇编源程序时完成的工作*

汇编后不产生相应的机器码

##### 宏指令语句

*宏指令语句就是宏的引用*

宏的定义必须按照相应的规定进行，每个宏都有相应的宏名

#### 汇编程序

*汇编程序的功能是将用汇编语言写的源程序翻译成机器指令程序*

汇编程序一般需要两次扫描源程序才能完成翻译过程

**第一次扫描**

- 创建记录汇编时遇到的符号的值的符号表ST

- 一个固定的表MOT1记录每条机器指令的记忆码和指令长度

- 设立一个位置计数器或单元地址计数器LC来计算各汇编语句标点的地址，其初值一般是0

第二次扫描

- 使用符号指令表MOT2

- 设立一个伪指令表POT2

第二次扫描中，可执行的汇编语句应被翻译成对应的二进制代码机器指令

### 编译程序

*编译程序的功能是把某高级语言书写的源程序翻译成与之等价的目标程序*

#### 词法分析

*对源程序从前到后、从左到右的逐个字符扫描，从中识别出一个个“单词”符号*

词法规则用3型号文法或正规表达式描述，它产生的集合是语言基本字符集字母表上的字符串的一个子集叫做正规集

##### 正规表达式与正规集

![](../../../../assets/default.png)

![](../../../../assets/default.png)

##### 有限状态机

**确定有限状态机（DFA）**

![](../../../../assets/default.png)

**不确定的有限状态机（NFA）**

![](../../../../assets/default.png)

##### NFA到DFA的转换

[NFA到DFA的转化_暗夜绿的博客](https://blog.csdn.net/weixin_48627356/article/details/121321357)

~~感觉不考~~

##### DFA的最小化

[【编译原理】最小化 DFA_零碎@流年絮语的博客](https://blog.csdn.net/qq_44824148/article/details/115477583)

~~感觉也必考~~

##### 正规式与有限自动机之间的转换

~~感觉还是不考~~

##### 词法分析器构造

1. 用正规表达式描述语言中的单词构成规则

2. 为每个正规式构造一个NFA，它识别正规式所表示的正规集

3. 将构造出的NFA转换成等价的DFA

4. 对DFA进行最小化处理

5. 从DFA构造词法分析器

#### 语法分析

*根据语言的语法规则将单词符号序列分解成各类语法单元，如果没有语法错误，语法分析后就能正确的构造出语法树，否则指出语法错误。*

语法分析的任务是根据语言的规则分析单词串中是否构成短语和句子

- ##### 文法和语言分析

*描述语言语法结构的规则成为&lt;b&gt;文法&lt;/b&gt;*

[【编译原理】文法的分类_Tuuua_的博客](https://blog.csdn.net/qq_42933533/article/details/109681369)

[语法分析_Shanhj的博客](https://blog.csdn.net/Shanhj/article/details/124771451)

#### 语义分析

*分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息。*

只有语法检查与语义检查都正确的源程序才能被翻译成正确的目标代码

#### 中间代码生成

*中间代码生成阶段的工作是根据语义分析的输出生成中间代码*

- 中间代码是一种简单且含义明确的记号系统

- 可以有多种形式

- 特征是与具体机器无关

- 最常用的是三地址码，实现方式是四元式

**常用的中间代码形式：**

- **后缀式**：[逆波兰式_百度百科 (baidu.com)](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437?fromtitle=%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;fromid=6160580&amp;fr=aladdin)

- 树形表示

- 三元表示

- 四元表示

**常用语法结构翻译**

布尔表达式和控制语句：[【编译原理系列】布尔表达式及控制语句翻译_槑！的博客](https://blog.csdn.net/weixin_43934607/article/details/113068312)

算数表达式和赋值语句：[【编译原理系列】算术表达式与数组元素翻译_槑！的博客](https://blog.csdn.net/weixin_43934607/article/details/113077357?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BF%BB%E8%AF%91&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-113077357.142^v51^new_blog_pos_by_title,201^v3^add_ask&amp;spm=1018.2226.3001.4187)

**动态存储分配和过程调用的翻译**

~~没见考过~~

#### 代码优化

*代码优化生成高效的目标代码*

可以在中间代码生成阶段进行也可以在目标代码生成阶段进行

一般建立在对程序的控制流和数据流分析的基础上

#### 目标代码生成

*把中间代码变换成特定机器上的绝对指令代码、可重定向的指令代码或汇编指令代码*

和机器密切相关

是编译器工作的最后一个阶段

**代码生成所需要考虑的主要问题**

- 中间代码形式

- 目标代码形式

- 寄存器的分配

- 计算时序的选择

#### 符号表管理

*记录源程序中各个符号的必要信息，以辅助语义的正确性检查和代码生成*

#### 出错处理

*&lt;b&gt;动态错误&lt;/b&gt;又成为语义错误，发生在程序运行时*

*&lt;b&gt;静态错误&lt;/b&gt;时指编译状态发现的程序错误*

编译时发现错误后，应该采用适当的策略修复他们，使得分析过程能够继续下去，以便能够在一次编译过程中尽可能多的找出程序中的错误

### 解释程序

*解释程序与编译程序在词法、语法、语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行源程序或源程序的中间表达式*

#### 基本结构

##### 分析部分

- 词法分析

- 语法分析

- 语义分析

##### 解释部分

### 编译与解释的比较

- 效率：编译方式可能取得更高的效率

- 灵活性：解释方式更灵活

- 可移植性：解释方法更好</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/dp/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之设计模式</h3> <p class="card-description" data-astro-cid-dohjnao5># 设计模式

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

## 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## 分类

共有23种设计模式分为3大类

- 创建型模式

    - 工厂模式（Factory Pattern）

    - 抽象工厂模式（Abstract Factory Pattern）

    - 单例模式（Singleton Pattern）

    - 建造者模式（Builder Pattern）

    - 原型模式（Prototype Pattern）

- 结构型模式

    - 适配器模式（Adapter Pattern）

    - 桥接模式（Bridge Pattern）

    - 过滤器模式（Filter、Criteria Pattern）

    - 组合模式（Composite Pattern）

    - 装饰器模式（Decorator Pattern）

    - 外观模式（Facade Pattern）

    - 享元模式（Flyweight Pattern）

    - 代理模式（Proxy Pattern）

- 行为型模式

    - 责任链模式（Chain of Responsibility Pattern）

    - 命令模式（Command Pattern）

    - 解释器模式（Interpreter Pattern）

    - 迭代器模式（Iterator Pattern）

    - 中介者模式（Mediator Pattern）

    - 备忘录模式（Memento Pattern）

    - 观察者模式（Observer Pattern）

    - 状态模式（State Pattern）

    - 空对象模式（Null Object Pattern）

    - 策略模式（Strategy Pattern）

    - 模板模式（Template Pattern）

    - 访问者模式（Visitor Pattern）

![](cp/img1.jpg)

## 详细信息

[设计模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/disk/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之机械硬盘</h3> <p class="card-description" data-astro-cid-dohjnao5># 机械硬盘管理

## 硬盘结构

硬盘内部是由许许多多的圆形盘片、机械手臂、 磁头与主轴马达所组成的

实际的数据都是写在具有磁性物质的盘片上头，而读写主要是通过在机械手臂上的磁头（head）来达成。 实际运行时， 主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上头进行读写的动作。 另外，由于单一盘片的容量有限，因此**有的硬盘内部会有两个以上的盘片**

![](disk/Disktructure.jpg)

磁盘上的数据都存放于磁道上。&lt;mark&gt;磁道就是磁盘上的一组同心圆&lt;/mark&gt;，**其宽度与磁头的宽度相同**。为了避免减小干扰，**磁道与磁道之间要保持一定的间隔**（inter-track gap），&lt;mark&gt;沿磁盘半径方向，单位长度内磁道的数目称之为道密度&lt;/mark&gt;（道/英寸，TPI），最外层为0道。

&lt;mark&gt;沿磁道方向，单位长度内存储二进制信息的个数叫位密度&lt;/mark&gt;。为了简化电路设计，**每个磁道存储的位数都是相同的，所以其位密度也随着从外向内而增加**。磁盘的数据传输是以块为单位的，所以&lt;mark&gt;磁盘上的数据也以块的形式进行存放。这些块就称为扇区&lt;/mark&gt;（sector），**每个磁道通常包括10~100个扇区。同样为了避免干扰，扇区之间也相互留有空隙**（inter–sector gap）。柱面是若干个磁盘组成的磁盘组，&lt;mark&gt;所有盘面上相同位置的磁道组称为一个柱面&lt;/mark&gt;（每个柱面有n个磁道）；若每个磁盘有m个磁道，则该磁盘组共有m个柱面。

通常数据的读写会由外圈开始往内写

## 磁盘容量

**磁盘的非格式化容量为&lt;mark&gt;Cn=w×3.14×d×m×n&lt;/mark&gt;,其中w为位密度，d为最内圈直径，m为记录面数，n为每面磁道数。**
磁盘格式化后能够存储有用信息的总量。**&lt;mark&gt;存储容量=n×t×s×b&lt;/mark&gt;,其中：n为保存数据的总盘面
数；t为每面磁道数；s为每道的扇区数；b为每个扇区存储的字节数。**

## 磁盘读取时间

磁盘的存取时间包括寻道时间和等待时间。&lt;mark&gt;寻道时间（查找时间，Seek Time）为磁头移动到目标磁道所需的时间&lt;/mark&gt;（movabe–head disk），对于固定磁头磁盘而言，无须移动磁头，只需选择目标磁道对应的磁头即可。&lt;mark&gt;等待时间为等待读写的扇区旋转到磁头下方所用的时间&lt;/mark&gt;。一般选用磁道旋转一周所用时间的一半作为平均等待时间。寻道时间由磁盘机的性能决定

&lt;mark&gt;磁盘的数据传输速率是指磁头找到地址后，单位时间写入或读出的字节数&lt;/mark&gt;。&lt;mark&gt;R=TB/T&lt;/mark&gt;,其中：TB为一个磁道上记录的字节数，T为磁盘每转一圈所需的时间，R为数据传输速率。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/sm/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之软件维护</h3> <p class="card-description" data-astro-cid-dohjnao5># 软件维护

软件维护（Software maintenance）是指在软件产品发布后，因修正错误、提升性能或其他属性而进行的软件修改。

## 类型

### 改正性维护

改正性维护是指在&lt;mark&gt;使用过程中&lt;/mark&gt;发现了隐蔽的&lt;mark&gt;错误&lt;/mark&gt;后，为了诊断和改正这些隐蔽错误而修改软件的活动。

### 适应性维护

适应性维护是指为了&lt;mark&gt;适应变化了的环境&lt;/mark&gt;而修改软件的活动。

### 完善性维护

完善性维护是指为了&lt;mark&gt;扩充或完善&lt;/mark&gt;原有软件的&lt;mark&gt;功能或性能&lt;/mark&gt;而修改软件的活动。

### 预防性维护

预防性维护是指为了&lt;mark&gt;提高软件的可维护性和可靠性&lt;/mark&gt;、为未来的进一步改进打下基础而修改软件的活动。

## 软件的可维护性

**1）可理解性**
可理解性是指维护人员理解软件的结构、接口、功能和内部过程的难易程度。
**2）可测试性**
可测试性是指测试和诊断软件错误的难易程度。
**3）可修改性**
可修改性是指修改软件的难易程度。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/mm/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之内存管理</h3> <p class="card-description" data-astro-cid-dohjnao5>## 内存管理

## 存储管理的概念

存储管理主要是指对内存储器的管理，负责对内存的分配和回收、内存的保护和内存的扩充。存储管理的目的是尽量提高内存的使用效率。

## 单一连续区管理

在单道程序系统中，内存区域的用户空间全部为一个作业或进程占用。单一连续分配方法主要用于早期单道批处理系统。单一连续分配方法主要采用静态分配方法，为降低成本和减少复杂度，通常不对内存进行保护，因而会引起冲突使系统瘫痪。

## 分区存储管理

分区存储管理包括固定分区、可变分区，其基本思想是把内存划分成若干个连续区域，每个分区装入一个作业运行。要求作业一次性装入内存，且分区内部地址必须连续。

### 固定分区存储管理

固定分区分配方法是把内存空间固定地划分为若干个大小不等的区域，划分的原则由系统决
定。系统使用分区表描述分区情况。分区一旦划分结束，在整个执行过程中每个分区的长度和内存的总分区个数保持不变。

### 可变分区存储管理

可变分区分配方法是把内存空间按用户要求动态地划分成若干个分区。随着进程的执行，剩余的自由区域会变得更小，这时需要合并自由区和存储拼接技术。合并自由区是将相邻自由存储区合并为单一自由区的方法；存储拼接技术也称碎片收集，包括移动存储器的所有被占用区域到主存的某一端。可变分区克服了固定分区分配方法中的小作业占据大分区后产生碎片的浪费问题。

### 存储分配算法

常使用的4种存储分配算法介绍如下。
**首次适应算法：** 把内存中的可用分区单独组成可用分区表或可用分区自由链，按起始地址递增的次序排列。每次按递增次序向后找，&lt;mark&gt;一旦找到大于或等于所要求内存长度的分区&lt;/mark&gt;，则结束探索，从找到的分区中找出所要求的内存长度分配给用户，并把剩余的部分进行合并。
**循环适应算法：** 上述首次适应法经常利用的是低地址空间，后面经常是较大的空白区，为使内存所有线性地址空间尽可能轮流使用到，&lt;mark&gt;每重新分配一次，都在当前之后寻找。&lt;/mark&gt;
**最佳适应算法：** 最佳适应算法是&lt;mark&gt;将输入作业放入主存中与它所需大小最接近的空白区中&lt;/mark&gt;，使剩下的未用空间最小，该法要求空白区大小按从小到大次序组成空白区可用表或自由链。在进行分配时总是从最小的一个开始查询，因而找到的一个能满足要求的空白区便是最佳的一个。
**最差适应算法：** 分配时把一个作业程序放入主存中最不适合它的空白区，即&lt;mark&gt;最大的空白区（空闲区）内&lt;/mark&gt;。

### 交换与覆盖技术

覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。覆盖技术主要用在早期的操作系统中，而交换技术则在现代操作系统中得到了进一步发展。
覆盖技术是一种解决小内存运行大作业的方法。-个作业中若干程序段和数据段可以不同时使
用，这样它们就可以共享内存的某个区域，再根据需要分别调入该区域，这个区域就称为覆盖区。将程序执行时并不要求同时装入主存的覆盖组成一组，并称其为覆盖段，这个覆盖段分配到同一个覆盖区。交换技术可以将暂不需要的作业移到外存，让出内存空间以调入其他作业，交换到外存的作业也可以被再次调入。交换技术与覆盖技术相比不要求给出程序段之间的覆盖结构。交换主要是在作业之间进行的，而覆盖则主要是在同一个作业内进行的。

## 页式存储管理

分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，以页面为单位进行分配。在页式存储管理中，系统中虚地址是一个有序对（页号，位移）。系统为每一个进程建立一个页表，其内容包括进程的逻辑页号与物理页号的对应关系、状态等。

## 段式存储管理

段式存储管理与页式存储管理相似。分段的基本思想是把用户作业按逻辑意义上有完整意义的段来划分，以段为单位作为内、外存交换的空间尺度。一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成的。在分段系统中，容许程序（作业）占据内存中许多分离的分区。每个分区存储一个程序分段。这样，每个作业需要几对界限地址寄存器，判定访问地址是否越界也困难了。在分段存储系统中常常利用存储保护键实现存储保护。分段系统中虚地址是一个有序对（段号，位移）。系统为每个作业建立一个段表，其内容包括段号、段长、内存起始地址和状态等。状态指出这个段是否已调入内存，即内存起始地址指出这个段，状态指出这个段的访问权限。

## 段页式存储管理

段页式管理是段式和页式两种管理方法结合的产物，综合了段式组织与页式组织的特点，根据程序模块分段，段内再分页，内存被划分成定长的页。段页式系统中虚地址形式是（段号、页号、位移）。系统为每个进程建立一个段，为每个段建立一个页表。段页式管理采用段式分配、页式使用的方法，便于动态连接和存储的动态分配。这种存储管理能提高内存空间的利用率。段页式虚拟存储管理结合了段式和页式的优点，但增加了设置表格（段表、页表）和查表等开销，段页式虚拟存储器一般只在大型计算机系统中使用。

## 页面调度

如果选择的页面被频繁地装入和调出，这种现象称为&quot;抖动&quot;,应减少和避免抖动现象。常用的页面调度算法有以下几种。
**最优（OPT）算法**。&lt;mark&gt;选择不再使用或最远的将来才被使用的页&lt;/mark&gt;，难以实现，常用于淘汰算法的
比较。
**随机（RAND）算法**。&lt;mark&gt;随机地选择被淘汰的页&lt;/mark&gt;，开销小，但是可以选中立即就要访问的页。
先进先出（First in First out,FIFO）算法，又称轮转法（RR）。选择在内存驻留时间最长的
页，似乎合理，但可能淘汰掉频繁使用的页。另外，使用FIFO算法时，在未给予进程分配足够的页面数时，有时会出现给予进程的页面数增多，缺页次数反而增加的异常现象。FIFO算法简单，可采用队列实现。
**最近最少使用（Least Recently Used缩写为LRU）算法**。&lt;mark&gt;选择离当前时间最近的一段时间内使用得最少的页&lt;/mark&gt;。这个算法的主要出发点是，如果某个页被访问了，则它可能马上就要被访问；反之，如果某个页长时间未被访问，则它在最近一段时间也不会被访问。
另外，还有最不经常使用的页面先淘汰（LFU,least frequent used）、最近没有使用的页面先淘汰（NUR）、最优淘汰算法（OPT,optimal replacement algorithm）等。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/other/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之其他知识点</h3> <p class="card-description" data-astro-cid-dohjnao5># 其他

## 数据结构

### 强连通分量

有向非强连通图的&lt;mark&gt;极大&lt;/mark&gt;强连通子图，称为强连通分量

### 霍夫曼编码

[霍夫曼（Huffman）压缩（文件压缩机制）](https://blog.csdn.net/Charlesix59/article/details/119975011)

## 计算机组成原理

- 立即寻址：指令的地址字段指出的不是操作数的地址，而是操作数本身

- 直接寻址：指令中的形式地址部分即为有效地址

- 间接寻址：指令中的形式地址不是操作数的地址，而是 “操作数地址的地址”

- 隐含寻址：指令中不直接给出操作数地址，操作数地址通常隐含在操作码或某个（约定）寄存器中

- 寄存器寻址：指令中的形式地址直接指出寄存器的编号，操作数存储于寄存器中

- 寄存器间接寻址：指令中的形式地址为寄存器的编号，寄存器的内容是操作数的有效地址

- 基址寻址：指令中的形式地址与基址寄存器内容之和为有效地址。

- 变址寻址：指令中的形式地址与变址寄存器内容之和为有效地址。

- 相对寻址：有效地址为程序计数器*PC*的值与形式地址之和。

- 堆栈寻址：

-

[寻址方式_百度百科 (baidu.com)](https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/3210621)

## 软件工程

### McCabe算法

`V(G)=m−n+2p`

其中，V(G) 是有向图 G 中的环路数，m 是图 G 中弧的个数，n 是图 G 中的结点数，p 是图 G 中的强连通分量个数

### SCI EMM

- L1：CMMI一级，完成级。在完成级水平上，企业对项目的 目标与要做的努力很清晰。项目的目标得以实现。因此，任务是完成了。 但是由于任务的完成带有很大的偶然性，企业无法保证在实施同类项目的时候仍然能够完成任务。企业在一级上的项目实施对实施人员有很大的依赖性。

- L2：CMMI二级，管理级。在管理级水平上，企业在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对相关的项目实施人员有相应的培训，对 整个流程有监测与控制，并与上级单位对项目与流程进行审查。企业在二级水平上体现了对项目的一系列的管理程序。这一系列的管理手段排除了企业在一级时完成 任务的随机性，保证了企业的所有项目实施都会得到成功。

- L3：CMMI三级，定义级。在定义级水平上，企业不仅仅能够对项目的实施有一整套的管理措施，并保障项目的完成；而且，企业能够根据自身的特殊情况以及 自己的标准流程，将这套管理体系与流程予以制度化。这样，企业不仅能够在同类的项目上得到成功的实施，在不同类的项目上一样能够得到成功的实施。科学的管 理成为企业的一种文化，企业的组织财富。

- L4：CMMI四级，量化管理级。在量化管理级水平上，企业的项目管理不仅仅形成了一种制度， 而且要实现数字化的管理。对管理流程要做到量化与数字化。通过量化技术来实现流程的稳定性，实现管理的精度，降低项目实施再质量上的波动。

- L5：CMMI五级，优化级。在优化级水品上， 企业的项目管理达到了最高的境界。企业仅仅能够通过信息手段与数字数手段来实现对项目的管理， 而且能够充分利用信息资料，对企业在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化


CMMI是英文Capacity Maturity Model Integrated的简称。 中文的译意是能力成熟度集成模型。CMMI是CMM模型的最新版本。早期的能力成熟度模型是一种单一的模型其英文缩写为CMM，较多地用于软件工程。

### 数据流图

[数据流图（DFD）_溢出的vector的博客-CSDN博客_数据流图](https://blog.csdn.net/weixin_46694417/article/details/120588235)

#### 数据流图平衡

[【软件工程】数据流图 ( 数据字典 | 数据流图平衡原则 | 父图与子图平衡 | 子图内平衡 | 数据流图绘制原则 )_韩曙亮的博客](https://blog.csdn.net/shulianghan/article/details/109276722)

### 统一过程 (RUP)

统一过程有四个阶段，每个阶段又有多个任务。

### 软件专利

这篇博客讲的还挺简单、详细的

[软考中级软件设计师---知识产权(自用)_嘟嘟的程序员铲屎官的博客](https://blog.csdn.net/weixin_42753193/article/details/124991506)

### 风险管理

**风险识别**

可以用不同的方法对风险进行分类。从宏观上来看，风险可以分为项目风险、技术风险和商业风险。&lt;mark&gt;项目风险识别潜在的预算、进度、个人、资源、用户和需求&lt;/mark&gt;方面的问题。&lt;mark&gt;技术风包括识别潜在的设计、实现、接口、检验和维护&lt;/mark&gt;方面的问题。而商业风险则主要来源于市场。
风险识别的重要工作就是将潜在的风险找到，文档化。

**风险估计**

风险估计使用两种方法来估计每一种风险。**一种方法是估计其发生的可能性；另一种方法是估计它可能带来的破坏性**。然后根据这样的结果对其进行排列优先级，对于那种可能性大、破坏力也大的风险就应该更加重视，拟定相应的解决方案才能够有效地防范。

**风险驾驭**

风险驾驭是指利用某种技术，如原型化、软件自动化、软件心理学、可靠性工程学，以及某些项目管理方法等设法避开或转移风险。

### 内聚的分类

内聚的种类由紧到松（越紧越好）依次为：

1. **功能内聚**：指模块内的所有元素共同作用完成一个功能，缺一不可。

2. **顺序内聚**：指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一个功能元素的输入。

3. **通信内聚**：指模块内所有处理元素都在同一个数据结构上。

4. **过程内聚**：指一个模块完成多个任务，这些任务必须按指定的过程执行。

5. **瞬时内聚**：把需要同时执行的任务或动作组合在一起（如初始化模块）。

6. **逻辑内聚**：模块完成逻辑上相关的一组任务。

7. **偶然内聚**：指一个模块内的各处理元素之间没有任何联系或有松散的联系。


### 耦合的分类

耦合的种类从高到低（越低越好）依次为：

1. **内容耦合**：一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种耦合关系就是内容耦合。

2. **公共耦合**：指一组模块访问一个公共数据环境，如全局数据结构。

3. **外部耦合**：指一组模块访问一个公共变量，这里指基本数据类型而不是数据结构（或者说对象）。

4. **控制耦合**：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值选择执行模块内某一功能。那么也就是说，被调用的模块应具有多个功能。

5. **标记耦合**：耦合模块之间以数据结构传递（比如在 java 程序中，传递的就是一个对象）。

6. **数据耦合**：耦合模块之间有调用关系，传递的是简单数据类型的值（比如在 java 程序中，传递的就是一个基本数据类型的值）。

7. **无直接耦合**：指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。


### 软件体系结构风格

~~考得不多，但不是不考~~

[13种常见软件体系结构风格定义分析、结构图、优缺点_Jayphone17的博客](https://blog.csdn.net/Jayphone17/article/details/103651076)

## 操作系统

### 进程分配图

[ 资源分配图化简法_coding1994的博客-CSDN博客](https://blog.csdn.net/coding1994/article/details/52474731)

### 硬盘位视图

[位示图_百度百科 (baidu.com)](https://baike.baidu.com/item/%E4%BD%8D%E7%A4%BA%E5%9B%BE/2475925?fr=aladdin)

一bit代表一个硬盘块

### Flynn算法

[Flynn分类法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/413778318)

### 实时系统

实时操作系统是保证在一定时间限制内完成特定功能的操作系统。

#### 分类

实时操作系统有硬实时和软实时之分，**硬实时要求在规定的时间内必须完成操作**，这是在操作系统设计时保证的；**软实时则只要按照任务的优先级，尽可能快地完成操作即可**。我们通常使用的操作系统在经过一定改变之后就可以变成实时操作系统。

#### 要求

- 多任务

- 处理能被区分优先次序的进程线

- 一个中断水平的充分数量


#### 特征

- 高精度计时系统

- 多级中断机制

- 实时调度机制


## 计网

### 实现IPv4到IPv6的通信

#### 双栈协议

在IPv6实现之前，使一部分主机装有双协议栈：一个IPv4和一个IPv6。经过IPv4网络时将IPv6报文头转化为IPv4报文头

#### 隧道技术

在IPv6报文将要进入IPv4网络的时候将IPv6数据报封装在IPv4数据报里面</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/salf/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之安全性措施</h3> <p class="card-description" data-astro-cid-dohjnao5># 安全性措施

## 加密算法

### 术语

- [明文](https://baike.baidu.com/item/%E6%98%8E%E6%96%87?fromModule=lemma_inlink)，即原始的或未加密的[数据](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE?fromModule=lemma_inlink)。通过[加密算法](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95?fromModule=lemma_inlink)对其进行加密

- 密文，明文加密后的格式，是加密算法的输出信息。密文不应为无[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5?fromModule=lemma_inlink)的用户理解，用于数据的存储以及传输；

- 加密，把明文转换为密文的过程；

- 加密算法，加密所采用的变换方法,[加密算法](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95?fromModule=lemma_inlink)的输入信息为明文和[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5?fromModule=lemma_inlink)；

- 密钥，是由数字、字母或特殊符号组成的字符串，用它控制数据加密、解密的过程；加密算法是公开的，[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5?fromModule=lemma_inlink)则是不公开的

- 解密，对密文实施与加密相逆的变换，从而获得明文的过程；

- 解密算法，解密所采用的变换方法。


### 简介

数据加密是对明文按照某种加密算法进行处理，形成密文。这样一来，密文即使被截获，截获方也无法或难以解码，从而防止泄露信息。

- 秘密密钥加密体制K1=K2:加密和解密采用相同的密钥，因而又称为对称密码体制。因为加密速度快，通常用来加密大批量的数据。

- 公开密钥加密体制K1≠K2:又称不对称密码体制，其加密和解密使用不同的密钥；其中一个密钥是公开的，另一个密钥则是保密的。由于加密速度较慢，所以往往用在数据量较小的通信业务中。


### 目的

- 提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改；

- 应具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握；

- 密码体制的安全性应该不依赖于算法的保密，其安全性仅以加密密钥的保密为基础；

- 实现经济，运行有效，并且适用于多种完全不同的应用。


### 具体算法

#### DES算法

**简介**：

DES全称为Data Encryption Standard，即数据加密标准，是一种使用[密钥加密](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/5928903?fromModule=lemma_inlink)的块算法

**参数：**

DES算法的入口参数有三个：**Key、Data、Mode**。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。

**历史沿革**：

一般DES算法的密钥长度为56位，为了加速DES算法和RSA算法的执行过程，可以用硬件电路来实现加密和解密。针对DES密钥短的问题，科学家又研制了80位的密钥，以及在DES的基础上采用三重DES和双密钥加密的方法。即用两个56位的密钥K1、K2,发送方用K1加密，K2解密，再使用K1加密。接收方则使用K1解密，K2加密，再使用K1解密，其效果相当于将密钥长度加倍。

#### RSA算法

**简介**

在公开密钥密码体制中，**加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的**。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK

**过程**

先生成一对RSA密钥，**其中之一是保密密钥，由用户保存**；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与[公开密钥加密](https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/8090774?fromModule=lemma_inlink)方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要

**算法**

略，可参考[RSA算法_百度百科](https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95)

#### 其他算法

- 国际数据加密算法（IDEA）在1990年正式公布。这种算法是在DES算法的基础上发展起来的，类似于三重DES.发展IDEA也是因为感到DES具有密钥太短等缺点，IDEA的密钥为128位，这么长的密钥在今后若干年内应该是安全的。

- 1993年4月16日，美国政府推出了cipper密码芯片，该芯片采用美国国家安全局设计的Skipjack加密算法。采用Cipper的加密体制能为信息传输提供高等级的安全和保密，该体制是以防篡改硬件器件（Cipper芯片）和密钥Escrow（第三方托管）系统为基础的。

- 1994年2月14日，美国政府宣布了Escrow加密标准，其加密算法使用Skipjack.该算法采用80位密钥和合法强制访问字段（aw Enforcement Access Fied,EAF），以便在防篡改芯片和硬件上实现。由于使用了80位的密钥，Skipjack算法具有较高的强度。


| 名称   | 对称性 | 特点           | 密钥长度（通常） |
|------|-----|--------------|----------|
| DES  | 对称  | 不够安全         | 56       |
| RSA  | 不对称 | 安全性高，速度慢     | 512      |
| IDEA | 对称  | 速度快，密钥管理复杂困难 | 128      |

## 身份认证技术

数字签名用来保证信息传输过程中信息的完整和提供信息发送者的身份认证和不可抵赖性，该技术利用公开密钥算法对于电子信息进行数学变换，通过这一过程，数字签名存在于文档之中，不能被复制

### 哈希签名

Hash签名不属于强计算密集型算法，应用较广泛。Hash的主要局限是接收方必须持有用户密钥的副本以检验签名，因为双方都知道生成签名的密钥，较容易攻破，存在伪造签名的可能。

#### MD5

MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的[密码散列函数](https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/14937715?fromModule=lemma_inlink)，**可以产生出一个128位（16[字节](https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318?fromModule=lemma_inlink)）的散列值（hash value）**，用于确保信息传输完整一致。

### RSA签名

RSA既可以用来加密数据，也可以用于身份认证。

RSA算法中数字签名技术实际上是通过一个Hash函数来实现的。数字签名的特点是它代表了文件的特征，文件如果发生改变，数字签名的值也将发生变化。不同的文件将得到不同的数字签名。

### DSS算法

对数字签名和公开密钥加密技术来说，都会面临公开密钥的分发问题，即如何把一个用户的公钥以一种安全可靠的方式发送给需要的另一方。这就要求管理这些公钥的系统必须是值得信赖的。

所以，必须有一项技术来解决公钥与合法拥有者身份的绑定问题。假设有一个人自称某一个公钥是自己的，必须有一定的措施和技术来对其进行验证。

**数字证书**是解决这一问题的有效方法。它通常是一个签名文档，标记特定对象的公开密钥。**数字证书由一个认证中心（CA）签发**，认证中心类似于现实生活中公证人的角色，它具有权威性，是一个普遍可信的第三方。当通信双方都信任同一个CA时，两者就可以得到对方的公开密钥，从而能进行秘密通信、签名和检验。

#### 数字证书的基本工作原理：

第一，发送方在发送信息前，需先与接收方联系，同时利用公钥加密信息，信息在进行传输的过程当中一直是处于[密文](https://baike.baidu.com/item/%E5%AF%86%E6%96%87/9684333?fromModule=lemma_inlink)状态，包括接收方接收后也是加密的，确保了信息传输的[单一性](https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E6%80%A7/6153534?fromModule=lemma_inlink)，若信息被窃取或截取，也必须利用接收方的[私钥](https://baike.baidu.com/item/%E7%A7%81%E9%92%A5/8973452?fromModule=lemma_inlink)才可解读数据，而无法更改数据，这也有利保障信息的完整性和安全性。 [3]

第二，数字证书的数据[签名](https://baike.baidu.com/item/%E7%AD%BE%E5%90%8D/2890277?fromModule=lemma_inlink)类似于[加密](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748?fromModule=lemma_inlink)过程，数据在实施加密后，只有接收方才可打开或更改数据信息，并加上自己的[签名](https://baike.baidu.com/item/%E7%AD%BE%E5%90%8D/2890277?fromModule=lemma_inlink)后再传输至发送方，而接收方的[私钥](https://baike.baidu.com/item/%E7%A7%81%E9%92%A5/8973452?fromModule=lemma_inlink)具唯一性和[私密性](https://baike.baidu.com/item/%E7%A7%81%E5%AF%86%E6%80%A7/7896067?fromModule=lemma_inlink)，这也保证了签名的[真实性](https://baike.baidu.com/item/%E7%9C%9F%E5%AE%9E%E6%80%A7/6345696?fromModule=lemma_inlink)和[可靠性](https://baike.baidu.com/item/%E5%8F%AF%E9%9D%A0%E6%80%A7/512935?fromModule=lemma_inlink)，进而保障信息的安全性。

简单来说，发送方用**公钥**加密信息，接收方收到后用**接收方的私钥**解密</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/subject/qccstp/sr/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>软考复习之软件需求</h3> <p class="card-description" data-astro-cid-dohjnao5># 软件需求

软件需求是
(1)用户解决问题或达到目标所需条件或权能(Capability)。

(2)系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能。

(3)一种反映上面(1)或(2)所述条件或权能的文档说明。

它包括功能性需求及非功能性需求，非功能性需求对设计和实现提出了限制，比如性能要求，质量标准，或者设计限制。

## 类型

- 业务需求（Business Requirments）：组织或者客户高层次的目标，从宏观上描述开发系统的必要性、意义和目标，具有以业务为想到、可度量、合理、可行的特点。BR的核心部分是业务建模，对当前企业当前业务流程进行评估，并对新开发系统的业务处理流程进行展望。
- 用户需求（User Requirements）：用户要求系统必须要完成的任务，即用户要系统做什么，产生什么业务价值。
- 系统需求（System Requirments）：整个系统的顶级需求，由系统分析人员对UR进行分析、提炼、整理，从而生成指导开发的、更准确地软件需求。完整的表达了软件项目的预期特征，为接下来的软件设计和测试提供了依据和基础。
- 功能需求（Functional Requirements）：规定开发人员必须在产品中要实现的软件功能

  ### 非功能性需求

- 产品必须遵从的规范、标准和合约
- 外部界面的具体细节
- 性能需求
- 设计或实现的约束条件及质量属性

  ## 过程标准

  清楚(Clear)、完整(Complete)、一致(Consistent)、可测试(Testable)。
  此外还有其他的概念，如可跟踪的、可修改的等等</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/technology/framework/fluid-tags-bug-fix/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>修复fluid的tags中的词云tag跳转异常问题</h3> <p class="card-description" data-astro-cid-dohjnao5># 修复fluid的tags中的词云tag跳转异常问题

## 前言

最近在尝试搭建自己的blog，再再三考量之下选择了**hexo**，不得不说这个blog框架还是很香的，配合github的托管能够快速搭建一个界面美观的博客。

但是在使用的过程中我发现了一个小问题，就是博客的tags并不能正常工作。

当我们从首页中的tag跳转时，可以跳转到正常的界面，如图：

![](../../essay/prose/imperial_edict/img1.png)

&lt;font color=red&gt;但是当我从tags界面的词云中跳转时就会出现错误&lt;/font&gt;

![](fluid-tags-bug-fix/img2.png)

错误界面如图:

![](fluid-tags-bug-fix/img3.png)

&lt;!-- more --&gt;

## 解决方法

&lt;font color=red&gt;我们可以很明显的观测到问题——url地址错误，重复了一次&#39;tags/&#39;目录&lt;/font&gt;

我们首先说解决方案：

&lt;font color=red&gt;找到目录`&lt;your hexo dirctory&gt;\node_modules\hexo\lib\plugins\helper`中的tagcloud.js文件，将文件第71行改为：&lt;/font&gt;

```javascript
`&lt;a href=&quot;${url_for.call(this, tag.path).substring(5)}&quot; style=&quot;${style}&quot;${attr}&gt;${transform ? transform(tag.name) : tag.name}&lt;/a&gt;`
//原代码为：
//`&lt;a href=&quot;${url_for.call(this, tag.path))}&quot; style=&quot;${style}&quot;${attr}&gt;${transform ? transform(tag.name) : tag.name}&lt;/a&gt;`
//加上了一个子字符串分割
```

***注意！这个方法只适合跟我描述的错误相同的朋友，如果问题不同请不要随意更改！***

## 详细解释

这一部分讲述我怎么分析并解决问题的，如果不感兴趣可以直接关掉网页了

首先发现到这一点后，我企图弄清楚fluid是如何生成tags这个html文件的。但是我观察文件夹时并没有和明显的察觉到这一点。于是我找到`public`文件夹，**这个文件夹存放的是通过hexo生成的html文件。** 然后我们找到`tags`文件夹下的`index.html`   文件，随着翻阅html文件，我发现了这样的一块代码：

```html
&lt;div class=&quot;text-center tagcloud&quot;&gt;
  &lt;a href=&quot;tags/node-js/&quot; style=&quot;font-size: 15px; color: #bbe&quot;&gt;node.js&lt;/a&gt; &lt;a href=&quot;tags/前端/&quot; style=&quot;font-size: 15px; color: #bbe&quot;&gt;前端&lt;/a&gt;
&lt;/div&gt;
```

毫无疑问，这就是生成词云的代码，但是我已经生成为html的文件我们并不能直接改，因为如果要这样解决问题，每次生成新的html之后我们都要手动修改一次，这是很没有效率的。于是我们顺藤摸瓜继续寻找问题。

于是我在webstrom使用&lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;r&lt;/kbd&gt;全局查找tagcloud，发现在fluid的layout中有一个名为`tags.ejs`文件，这显然是生成tags的文件之一。其中有这样的一块代码：

```ejs
&lt;div class=&quot;text-center tagcloud&quot;&gt;
  &lt;%- tagcloud({
    min_font: min_font,
    max_font: max_font,
    amount: 999,
    unit: unit,
    color: true,
    start_color,
    end_color
  }) %&gt;
&lt;/div&gt;
```

很明显，这是生成上面那个html的映射文件，但是这其中依然没有修改herf的方法。于是我们继续向源头寻找。

然后我们发现tagcloud包是被引用进来的，而他的源码就在我们面提到过的文件夹中。

```javascript
`&lt;a href=&quot;${url_for.call(this, tag.path)}&quot; style=&quot;${style}&quot;${attr}&gt;${transform ? transform(tag.name) : tag.name}&lt;/a&gt;`
```

这一行很明显就是生成每个小tag的代码。虽然我们看不太懂`${url_for.call(this, tag.path)}`这行代码的意思，但是我们知道最终他都会被解析为字符串。如果你熟悉js，就会知道js拥有将所有东西转化为字符串的能力😂因此我们直接使用substring方法来更改这一行代码就可以解决问题了</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/technology/framework/fix-fluid-open-err-page-bug/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>修復hexo fluid归档、分类、标签界面查看文章404错误</h3> <p class="card-description" data-astro-cid-dohjnao5># 修復fluid归档、分类、标签界面查看文章404错误
## 前言
上次遇到了[tag跳转的问题](https://charlesix59.github.io/2022/09/01/fluid-tags-bug-fix/)之后，我又遇到了这个奇怪的问题。按照按图索骥的原则，我又用那篇文章中提到过的方法进行了纠错，最终也是顺利的解决了这个bug。
错误如图：
![](../../essay/prose/imperial_edict/img1.png)
&lt;!-- more --&gt;
## 解决方案
&lt;font color=red&gt;还是和以前一样，先说结论&lt;/font&gt;
&lt;font color=orange&gt;警告⚠：如果你的错误和我的不同，请不要随意修改&lt;/font&gt;
首先找到fluid主题的目录中的`&lt;your fluid dir&gt;/layout/_partials`
打开`category-list.ejs`文件
修改第**45行**为
```html
&lt;a href=&quot;../&lt;%= url_for(cat.path) %&gt;&quot; style=&quot;text-align: center&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;
```
修改第**50**行为
```html
&lt;a href=&quot;../&lt;%= url_for(post.path) %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot;
```
然后打开`archieve-list.ejs`
修改第10行为
```html
&lt;a href=&quot;../&lt;%= url_for(post.path) %&gt;&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;
```
然后**复制**整个文档，**新建**一个名为`sub-archive-list.ejs`（名字可以自定）的文件，将复制的内容**粘贴**过去
并修改第10行为
```html
&lt;a href=&quot;../../&lt;%= url_for(post.path) %&gt;&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;
```
然后回到上一级目录，找到`tag.ejs`，修改第12行引用的文件为你新建的那个文件：
```ejs
&lt;%- partial(&#39;_partials/sub-archive-list.ejs&#39;, { params: { key: page.layout, postTotal: tag ? tag.posts.length : 0 } }) %&gt;
```
同时如上修改`category.ejs`中的第12行为：
```ejs
&lt;%- partial(&#39;_partials/sub-archive-list.ejs&#39;, { params: { key: page.layout, postTotal: cat ? cat.posts.length : 0 } }) %&gt;
```
## 其他
我不知道是不是因为我配置不完全或者安装出现问题才导致有这么多的bug，但是随着我的重装这个问题也没有得到很好的解决。
如果你也遇到了相似的问题可以尝试用这种方法解决
如果你对详细的解决思路感兴趣，你可以查看[前言](#前言)中提到的文章</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/technology/framework/el-tree_not_work/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>el-tree选取父节点不能同时选中子节点的解决方案</h3> <p class="card-description" data-astro-cid-dohjnao5>之前在用`element-ui`的`el-tree`组件时，发现当父组件没有展开过的时候，
我们调用`check-change`方法时，子组件虽然会被选中但是不会触发事件。对于这个问题，
我坚信`element-ui`官方一定考虑过并给出了解决方案。

但是在搜索引擎中排名最高的解决方案是：使用`check`方法代替`check-change`事件，但是实际上
这种方法并没有效果。如果要解决问题，一个直觉但是不考虑需求的方案是默认展开所有节点，
即在组件中添加`default-expand-all`属性。但是这个方法麻烦而且并不是直接解决问题，
最好的解决方案存在与官方文档中，我们只需要添加一个属性：
**`render-after-expand: false`**

在`el-tree`中，为了提高加载的效率，防止一口气加载所有节点引起阻塞，因此tree组件默认是
每次展开才会渲染子节点的，这就导致我们的子节点因为没有被渲染所以没有触发`check-change`事件。

因此只要饥饿加载tree节点即可简单的解决问题。</p> </div> </div> </a>  </div><div class="card-item" data-astro-cid-p3vyftr4> <a href="/blog/technology/framework/recognize_pagintor/" class="card-link" data-astro-cid-dohjnao5> <div class="card" data-astro-cid-dohjnao5> <div class="card-image" data-astro-cid-dohjnao5>  </div> <div class="card-content" data-astro-cid-dohjnao5> <h3 class="card-title" data-astro-cid-dohjnao5>认识与修改hexo的paginator(分页)系统</h3> <p class="card-description" data-astro-cid-dohjnao5># 认识与修改hexo的pagintor(分页)系统

## 前言

为啥我会出这篇博客呢？不出意外的当然是又出意外了。我的分页系统出现了一点问题。
当然，它可能从最开始就有一点问题，只不过是随着页面的增加我才渐渐注意到而已。
问题就是它会跳到当前页面+当前页面+分页，比如在archives界面点击第二页就会跳转到
`domain/archives/archives/page/2`
这个界面。这很明显是错误的
为了修正这个问题我又是对着各种源码一顿查找。

&lt;!-- more --&gt;

## 修改方案

老规矩，先贴出来修改方案。如果问题和我不同的就不要跟着做了。
首先找到我们需要修改的文件夹

`&lt;your hexo directory&gt;/node_modules/hexo/lib/plugins/helper/pagintor`

将第八行更改为

```javascript
return i =&gt; &#39;/&#39; + url_for.call(ctx, i === 1 ? base : base + format.replace(&#39;%d&#39;, i));
```

同时要保证在hexo目录中的配置文件`_config.yml`中主目录的地址路由为&#39;&#39;

即`index_generator`中的`path`属性的值为`&#39;&#39;`

```yaml
index_generator:
  path: &#39;&#39;
  per_page: 10
  order_by: -date
```

## 详解paginator

我觉得我直接贴注释就好

```javascript
&#39;use strict&#39;;

const { htmlTag, url_for } = require(&#39;hexo-util&#39;);

//这个函数就是用来创建链接的，它决定了路径的内容
const createLink = (options, ctx) =&gt; {
  const { base, format } = options;

    //加一个&#39;/&#39;是为了能够返回主目录
  return i =&gt; &#39;/&#39; + url_for.call(ctx, i === 1 ? base : base + format.replace(&#39;%d&#39;, i));
};

//这个函数生成html界面的内容，具体说就是界面的按钮（数字加链接）
const createPageTag = (options, ctx) =&gt; {
  const link = createLink(options, ctx);
  const { current, escape, transform } = options;

  return i =&gt; {
    if (i === current) {
      return htmlTag(&#39;span&#39;, { class: &#39;page-number current&#39; }, transform ? transform(i) : i, escape);
    }
    return htmlTag(&#39;a&#39;, { class: &#39;page-number&#39;, href: link(i) }, transform ? transform(i) : i, escape);
  };
};

//为生成的所有的按钮进行排序与包装
const showAll = (tags, options, ctx) =&gt; {
  const { total } = options;

  const pageLink = createPageTag(options, ctx);

  for (let i = 1; i &lt;= total; i++) {
    tags.push(pageLink(i));
  }
};

const pagenasionPartShow = (tags, options, ctx) =&gt; {
  const {
    current,
    total,
    space,
    end_size: endSize,
    mid_size: midSize
  } = options;

  const leftEnd = Math.min(endSize, current - 1);
  const rightEnd = Math.max(total - endSize + 1, current + 1);
  const leftMid = Math.max(leftEnd + 1, current - midSize);
  const rightMid = Math.min(rightEnd - 1, current + midSize);
  const spaceHtml = htmlTag(&#39;span&#39;, { class: &#39;space&#39; }, space, false);

  const pageTag = createPageTag(options, ctx);

  // Display pages on the left edge
  for (let i = 1; i &lt;= leftEnd; i++) {
    tags.push(pageTag(i));
  }

  // Display spaces between edges and middle pages
  if (space &amp;&amp; leftMid - leftEnd &gt; 1) {
    tags.push(spaceHtml);
  }

  // Display left middle pages
  for (let i = leftMid; i &lt; current; i++) {
    tags.push(pageTag(i));
  }

  // Display the current page
  tags.push(pageTag(current));

  // Display right middle pages
  for (let i = current + 1; i &lt;= rightMid; i++) {
    tags.push(pageTag(i));
  }

  // Display spaces between edges and middle pages
  if (space &amp;&amp; rightEnd - rightMid &gt; 1) {
    tags.push(spaceHtml);
  }

  // Display pages on the right edge
  for (let i = rightEnd; i &lt;= total; i++) {
    tags.push(pageTag(i));
  }
};

//这是函数的入口，它接受option参数
function paginatorHelper(options = {}) {
  options = Object.assign({
    base: this.page.base || &#39;&#39;, //文章的路径
    current: this.page.current || 0,    //当前页
    format: `${this.config.pagination_dir}/%d/`,    //待格式化的page路径
    total: this.page.total || 1,    //总页面
    end_size: 1,
    mid_size: 2,
    space: &#39;…&#39;,
    next_text: &#39;Next&#39;,  //下一个界面的信息 
    prev_text: &#39;Prev&#39;,  //上一个界面的信息
    prev_next: true,
    escape: true
  }, options);

  const {
    current,
    total,
    prev_text: prevText,
    next_text: nextText,
    prev_next: prevNext,
    escape
  } = options;

  if (!current) return &#39;&#39;;

  const link = createLink(options, this);

  const tags = [];

  // Display the link to the previous page
  if (prevNext &amp;&amp; current &gt; 1) {
    tags.push(htmlTag(&#39;a&#39;, { class: &#39;extend prev&#39;, rel: &#39;prev&#39;, href: link(current - 1)}, prevText, escape));
  }

  if (options.show_all) {
    showAll(tags, options, this);
  } else {
    pagenasionPartShow(tags, options, this);
  }

  // Display the link to the next page
  if (prevNext &amp;&amp; current &lt; total) {
    tags.push(htmlTag(&#39;a&#39;, { class: &#39;extend next&#39;, rel: &#39;next&#39;, href: link(current + 1) }, nextText, escape));
  }

  return tags.join(&#39;&#39;);
}

module.exports = paginatorHelper;
```

## 碎碎念

本来以为分页应该也是在ejs中生成的，我只需要修改ejs文件即可。

可是万万没想到hexo的分页是直接通过一个插件的函数生成html内容然后显示上的

所以这个改的还挺艰难的，差点给我愁死😭</p> </div> </div> </a>  </div> </div>  <nav class="pagination" aria-label="Pagination Navigation" data-astro-cid-d776pwuy><a href="/page/4/" class="pagination-link pagination-prev" title="上一页" data-astro-cid-d776pwuy>
← 上一页
</a><div class="pagination-numbers" data-astro-cid-d776pwuy><a href="/" class="pagination-number " data-astro-cid-d776pwuy>1</a><span class="pagination-ellipsis" data-astro-cid-d776pwuy>...</span><a href="/page/3/" class="pagination-number " data-astro-cid-d776pwuy>3</a><a href="/page/4/" class="pagination-number " data-astro-cid-d776pwuy>4</a><a href="/page/5/" class="pagination-number active" aria-current="page" data-astro-cid-d776pwuy>5</a><a href="/page/6/" class="pagination-number " data-astro-cid-d776pwuy>6</a><a href="/page/7/" class="pagination-number " data-astro-cid-d776pwuy>7</a></div><a href="/page/6/" class="pagination-link pagination-next" title="下一页" data-astro-cid-d776pwuy>
下一页 →
</a></nav> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2026 @charlesix59. All rights reserved.
<div class="social-links" data-astro-cid-sz7xmlte> <a href="https://https://github.com/charlesix59" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>find me on Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg> </a> </div> </footer>  </body></html>